/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa;

import org.metaeffekt.core.inventory.processor.model.*;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.AeaaAdvisoryEntry;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.store.AeaaAdvisoryTypeIdentifier;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatus;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusHistoryEntry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.function.Function;

/**
 * Mirrors structure of <code>com.metaeffekt.mirror.contents.base.VulnerabilityContextInventory</code>
 * until separation of inventory report generation from ae core inventory processor.
 */
public class AeaaVulnerabilityContextInventory {

    private static final Logger LOG = LoggerFactory.getLogger(AeaaVulnerabilityContextInventory.class);

    private final Inventory inventory;
    private final String vulnerabilityContextName;

    private final Set<AeaaVulnerability> vulnerabilities = new LinkedHashSet<>();
    private final Set<AeaaAdvisoryEntry> securityAdvisories = new LinkedHashSet<>();

    private final Map<String, AeaaVulnerability> vulnerabilityByName = new HashMap<>();
    private final Map<String, AeaaAdvisoryEntry> advisoryByName = new HashMap<>();

    protected AeaaVulnerabilityContextInventory(Inventory inventory, String vulnerabilityContextName) {
        this.inventory = inventory;
        this.vulnerabilityContextName = vulnerabilityContextName;
    }

    protected AeaaVulnerabilityContextInventory(Inventory inventory) {
        this(inventory, VulnerabilityMetaData.VULNERABILITY_ASSESSMENT_CONTEXT_DEFAULT);
    }

    public Inventory getInventory() {
        return inventory;
    }

    public Set<AeaaVulnerability> getVulnerabilities() {
        return vulnerabilities;
    }

    public Set<AeaaVulnerability> getShallowCopyVulnerabilities() {
        return new LinkedHashSet<>(vulnerabilities);
    }

    public List<AeaaVulnerability> getSortedVulnerabilities() {
        final List<AeaaVulnerability> sortedVulnerabilities = new ArrayList<>(vulnerabilities);
        sortedVulnerabilities.sort(Comparator.comparing(AeaaVulnerability::getId).reversed());
        return sortedVulnerabilities;
    }

    public Set<AeaaAdvisoryEntry> getSecurityAdvisories() {
        return securityAdvisories;
    }

    public Set<AeaaAdvisoryEntry> getShallowCopySecurityAdvisories() {
        return new LinkedHashSet<>(securityAdvisories);
    }

    public List<AeaaAdvisoryEntry> getSoredSecurityAdvisories() {
        final List<AeaaAdvisoryEntry> sortedSecurityAdvisories = new ArrayList<>(securityAdvisories);
        sortedSecurityAdvisories.sort(Comparator.comparing(AeaaAdvisoryEntry::getId));
        return sortedSecurityAdvisories;
    }

    /* EFFECTIVE INFORMATION CALCULATION */

    public void calculateEffectiveCvssVectorsForVulnerabilities(CentralSecurityPolicyConfiguration securityPolicy) {
        synchronized (this.vulnerabilities) {
            for (AeaaVulnerability vulnerability : this.vulnerabilities) {
                vulnerability.selectEffectiveCvssVectors(securityPolicy);
            }
        }
    }

    public void applyEffectiveVulnerabilityStatus(CentralSecurityPolicyConfiguration securityPolicy) {
        synchronized (this.vulnerabilities) {
            for (AeaaVulnerability vulnerability : this.vulnerabilities) {
                final boolean isInsignificant = securityPolicy.isVulnerabilityInsignificant(vulnerability);
                final AeaaVulnerabilityStatus vulnerabilityStatus = vulnerability.getOrCreateNewVulnerabilityStatus();

                // remove baked information first
                vulnerabilityStatus.getStatusHistorySet().removeIf(e -> e.equalsTemplate(AeaaVulnerabilityStatusHistoryEntry.IN_REVIEW));
                vulnerabilityStatus.getStatusHistorySet().removeIf(e -> e.equalsTemplate(AeaaVulnerabilityStatusHistoryEntry.INSIGNIFICANT));

                vulnerabilityStatus.reorderChronologically(vulnerability, isInsignificant, securityPolicy.getInsignificantThreshold());

                if (vulnerabilityStatus.getStatusHistory().stream().noneMatch(AeaaVulnerabilityStatusHistoryEntry::isActive)) {
                    vulnerabilityStatus.addHistoryEntry(AeaaVulnerabilityStatusHistoryEntry.IN_REVIEW);
                }
            }
        }
    }

    /* DATA ACCESS */

    public void add(AeaaVulnerability vulnerability) {
        synchronized (this.vulnerabilities) {
            this.vulnerabilities.add(vulnerability);
        }
        reAssociateVulnerability(vulnerability);
        updateVulnerabilityByName(vulnerability);
    }

    public void add(VulnerabilityMetaData vmd) {
        final AeaaVulnerability vulnerability = AeaaVulnerability.fromVulnerabilityMetaData(vmd);
        synchronized (this.vulnerabilities) {
            this.vulnerabilities.add(vulnerability);
        }
        reAssociateVulnerability(vulnerability);
        updateVulnerabilityByName(vulnerability);
    }

    public void addAllVulnerabilities(List<AeaaVulnerability> vulnerabilities) {
        synchronized (this.vulnerabilities) {
            this.vulnerabilities.addAll(vulnerabilities);
        }
        this.reAssociateVulnerabilities();
        for (AeaaVulnerability vulnerability : vulnerabilities) {
            this.updateVulnerabilityByName(vulnerability);
        }
    }

    public void add(AeaaAdvisoryEntry securityAdvisory) {
        synchronized (this.securityAdvisories) {
            this.securityAdvisories.add(securityAdvisory);
        }
        this.reAssociateAdvisory(securityAdvisory);
        this.updateSecurityAdvisoryByName(securityAdvisory);
    }

    public void add(AdvisoryMetaData amd) {
        final AeaaAdvisoryEntry securityAdvisory = AeaaAdvisoryEntry.fromAdvisoryMetaData(amd);
        synchronized (this.securityAdvisories) {
            this.securityAdvisories.add(securityAdvisory);
        }
        this.reAssociateAdvisory(securityAdvisory);
        this.updateSecurityAdvisoryByName(securityAdvisory);
    }

    public void addAllAdvisories(List<AeaaAdvisoryEntry> securityAdvisories) {
        synchronized (this.securityAdvisories) {
            this.securityAdvisories.addAll(securityAdvisories);
        }
        this.reAssociateAdvisories();
        for (AeaaAdvisoryEntry securityAdvisory : securityAdvisories) {
            this.updateSecurityAdvisoryByName(securityAdvisory);
        }
    }

    public void remove(AeaaVulnerability vulnerability) {
        synchronized (this.vulnerabilities) {
            this.vulnerabilities.remove(vulnerability);
        }
        synchronized (this.vulnerabilityByName) {
            this.vulnerabilityByName.remove(vulnerability.getId());
        }
    }

    public void remove(VulnerabilityMetaData vulnerability) {
        final AeaaVulnerability removed;
        synchronized (this.vulnerabilityByName) {
            removed = this.vulnerabilityByName.remove(vulnerability.get(VulnerabilityMetaData.Attribute.NAME));
        }
        synchronized (this.vulnerabilities) {
            this.vulnerabilities.remove(removed);
        }
    }

    public void remove(AeaaAdvisoryEntry securityAdvisory) {
        synchronized (this.securityAdvisories) {
            this.securityAdvisories.remove(securityAdvisory);
        }
        synchronized (this.advisoryByName) {
            this.advisoryByName.remove(securityAdvisory.getId());
        }
    }

    public void remove(AdvisoryMetaData securityAdvisory) {
        final AeaaAdvisoryEntry removed;
        synchronized (this.advisoryByName) {
            removed = this.advisoryByName.remove(securityAdvisory.get(AdvisoryMetaData.Attribute.NAME));
        }
        synchronized (this.securityAdvisories) {
            this.securityAdvisories.remove(removed);
        }
    }

    private void updateVulnerabilityByName(AeaaVulnerability vulnerability) {
        if (vulnerability == null) return;
        synchronized (vulnerabilityByName) {
            vulnerabilityByName.put(vulnerability.getId(), vulnerability);
        }
    }

    private void updateSecurityAdvisoryByName(AeaaAdvisoryEntry advisoryEntry) {
        if (advisoryEntry == null) return;
        synchronized (this.advisoryByName) {
            this.advisoryByName.put(advisoryEntry.getId(), advisoryEntry);
        }
    }

    public Optional<AeaaVulnerability> findVulnerabilityByName(String name) {
        if (name == null) return Optional.empty();

        final AeaaVulnerability vulnerability = this.vulnerabilityByName.get(name);
        if (vulnerability == null) return Optional.empty();

        if (!this.vulnerabilities.contains(vulnerability)) {
            synchronized (this.vulnerabilities) {
                this.vulnerabilities.remove(vulnerability);
            }
            return Optional.empty();
        }

        return Optional.of(vulnerability);
    }

    public AeaaVulnerability findOrCreateVulnerabilityByName(String name) {
        return findVulnerabilityByName(name).orElseGet(() -> {
            final AeaaVulnerability vulnerability = new AeaaVulnerability(name);
            add(vulnerability);
            return vulnerability;
        });
    }

    public AeaaVulnerability findOrAppendVulnerabilityByVulnerability(AeaaVulnerability searchVulnerability) {
        if (searchVulnerability == null) {
            throw new IllegalArgumentException("Query vulnerability must not be null when searching/creating vulnerabilities");
        }
        if (searchVulnerability.getId() == null) {
            throw new IllegalArgumentException("Query vulnerability must have an id when searching/creating vulnerabilities, but got: " + searchVulnerability.toJson());
        }
        return findVulnerabilityByName(searchVulnerability.getId()).orElseGet(() -> {
            add(searchVulnerability);
            return searchVulnerability;
        });
    }

    public AeaaVulnerability findOrCreateWithoutAddingVulnerabilityByName(String name) {
        return findVulnerabilityByName(name).orElseGet(() -> new AeaaVulnerability(name));
    }

    public Optional<AeaaAdvisoryEntry> findAdvisoryEntryByName(String name) {
        if (name == null) return Optional.empty();

        final AeaaAdvisoryEntry advisoryEntry = this.advisoryByName.get(name);

        if (advisoryEntry == null) return Optional.empty();
        if (!this.securityAdvisories.contains(advisoryEntry)) {
            synchronized (this.advisoryByName) {
                this.advisoryByName.remove(name);
            }
            synchronized (this.vulnerabilities) {
                this.vulnerabilities.forEach(v -> v.removeSecurityAdvisory(advisoryEntry));
            }
            return Optional.empty();
        }

        return Optional.of(advisoryEntry);
    }

    public AeaaAdvisoryEntry findOrCreateAdvisoryEntryByName(String name, Function<String, AeaaAdvisoryEntry> constructor) {
        return findAdvisoryEntryByName(name).orElseGet(() -> {
            final AeaaAdvisoryEntry advisoryEntry = constructor.apply(name);
            add(advisoryEntry);
            return advisoryEntry;
        });
    }

    public AeaaAdvisoryEntry findOrAppendAdvisoryEntryByAdvisoryEntry(AeaaAdvisoryEntry searchAdvisoryEntry) {
        if (searchAdvisoryEntry == null) {
            throw new IllegalArgumentException("Query advisory entry must not be null when searching/creating advisory entries");
        }
        if (searchAdvisoryEntry.getId() == null) {
            throw new IllegalArgumentException("Query advisory entry must have an id when searching/creating advisory entries, but got: " + searchAdvisoryEntry.toJson());
        }
        return findAdvisoryEntryByName(searchAdvisoryEntry.getId()).orElseGet(() -> {
            add(searchAdvisoryEntry);
            return searchAdvisoryEntry;
        });
    }

    @Override
    public String toString() {
        return "VulnerabilityContextInventory@" + Integer.toHexString(hashCode()) +
                "[" + inventory.getArtifacts().size() + ", " + vulnerabilities.size() + ", " + securityAdvisories.size() + ']';
    }

    public void extractMatchingArtifacts(AeaaMatchableDetailsAmbDataClass<?, ?> dc, Map<String, Map<Artifact, List<String>>> affectsArtifacts) {
        // affectsArtifacts is a map of:
        //   Artifact Field Names --> Artifact --> List of Vulnerability Names

        for (Map.Entry<String, Set<Artifact>> keyToArtifacts : dc.getAffectedArtifacts().entrySet()) {
            final String key = keyToArtifacts.getKey();
            final Set<Artifact> artifacts = keyToArtifacts.getValue();

            for (Artifact artifact : artifacts) {
                affectsArtifacts
                        .computeIfAbsent(key, k -> new HashMap<>())
                        .computeIfAbsent(artifact, k -> new ArrayList<>()).add(dc.getId());
            }
        }
    }

    public void reAssociateVulnerabilities() {
        synchronized (this.vulnerabilities) {
            for (AeaaVulnerability vulnerability : this.vulnerabilities) {
                this.reAssociateVulnerability(vulnerability);
            }
        }
    }

    protected void reAssociateVulnerability(AeaaVulnerability vulnerability) {
        vulnerability.getSecurityAdvisories().clear();

        synchronized (vulnerability.getReferencedSecurityAdvisories()) {
            for (Map.Entry<AeaaAdvisoryTypeIdentifier<?>, Set<String>> refEntry : vulnerability.getReferencedSecurityAdvisories().entrySet()) {
                final AeaaAdvisoryTypeIdentifier<?> source = refEntry.getKey();
                final Set<String> ids = refEntry.getValue();

                    ids.stream()
                            .map(this::findAdvisoryEntryByName)
                            .filter(Optional::isPresent).map(Optional::get)
                            .forEach(securityAdvisory -> {
                                if (securityAdvisory.getSourceIdentifier() != source) {
                                    LOG.warn("Overwriting source for advisory [{}] from [{}] to [{}] due to more detailed information on vulnerability [{}]",
                                            securityAdvisory.getId(), securityAdvisory.getSourceIdentifier(), source, vulnerability.getId());
                                    securityAdvisory.setSourceIdentifier(source);
                                }
                                vulnerability.addSecurityAdvisory(securityAdvisory);
                            });
            }
        }
    }

    public void reAssociateAdvisories() {
        synchronized (this.securityAdvisories) {
            for (AeaaAdvisoryEntry advisoryEntry : this.securityAdvisories) {
                this.reAssociateAdvisory(advisoryEntry);
            }
        }
    }

    protected void reAssociateAdvisory(AeaaAdvisoryEntry advisoryEntry) {
        synchronized (this.vulnerabilities) {
            // find vulnerabilities that reference this advisory and add it to the list of security advisories
            for (AeaaVulnerability vulnerability : this.vulnerabilities) {
                if (!vulnerability.getReferencedSecurityAdvisories().isEmpty()) {
                    final boolean hasMatchingAdvisories = vulnerability.deepCopyReferencedSecurityAdvisories().values().stream()
                            .flatMap(Collection::stream)
                            .anyMatch(e -> Objects.equals(advisoryEntry.getId(), e));
                    if (hasMatchingAdvisories) {
                        vulnerability.addSecurityAdvisory(advisoryEntry);
                    }
                }
            }
        }
    }

    public void parse() {
        parse(inventory.getArtifacts(), inventory.getVulnerabilityMetaData(vulnerabilityContextName), inventory.getAdvisoryMetaData());
    }

    protected void parse(List<Artifact> artifacts, List<VulnerabilityMetaData> vmds, List<AdvisoryMetaData> amds) {
        final long startTime = System.currentTimeMillis();
        // find all artifacts that reference vulnerabilities and collect them
        final Map<String, Map<String, List<Artifact>>> affectsArtifacts = new HashMap<>();
        for (Artifact artifact : artifacts) {
            extractAffectsArtifactsForKey(artifact, affectsArtifacts, Artifact.Attribute.VULNERABILITY);
            extractAffectsArtifactsForKey(artifact, affectsArtifacts, AeaaInventoryAttribute.VULNERABILITIES_FIXED_BY_KB);
            extractAffectsArtifactsForKey(artifact, affectsArtifacts, AeaaInventoryAttribute.INAPPLICABLE_CVE);
            extractAffectsArtifactsForKey(artifact, affectsArtifacts, AeaaInventoryAttribute.ADDON_CVES);
        }

        // parse individual vulnerabilities
        synchronized (this.vulnerabilities) {
            for (VulnerabilityMetaData vmd : vmds) {
                final AeaaVulnerability vulnerability = AeaaVulnerability.fromVulnerabilityMetaData(vmd);
                this.vulnerabilities.add(vulnerability);
                this.vulnerabilityByName.put(vulnerability.getId(), vulnerability);

                // add all artifacts that reference this vulnerability
                final Map<String, List<Artifact>> artifactMap = affectsArtifacts.get(vulnerability.getId());
                if (artifactMap != null) {
                    for (Map.Entry<String, List<Artifact>> artifactEntry : artifactMap.entrySet()) {
                        final String key = artifactEntry.getKey();
                        final List<Artifact> artifactsForVulnerability = artifactEntry.getValue();
                        for (Artifact artifact : artifactsForVulnerability) {
                            vulnerability.manuallyAffectsArtifact(key, artifact);
                        }
                    }
                }
            }
        }

        // parse individual security advisories
        synchronized (this.securityAdvisories) {
            for (AdvisoryMetaData amd : amds) {
                final AeaaAdvisoryEntry advisoryEntry = AeaaAdvisoryEntry.fromAdvisoryMetaData(amd);
                this.securityAdvisories.add(advisoryEntry);
                this.advisoryByName.put(advisoryEntry.getId(), advisoryEntry);

                // add all artifacts that reference this advisory
                final Map<String, List<Artifact>> artifactMap = affectsArtifacts.get(advisoryEntry.getId());
                if (artifactMap != null) {
                    for (Map.Entry<String, List<Artifact>> artifactEntry : artifactMap.entrySet()) {
                        final String key = artifactEntry.getKey();
                        final List<Artifact> artifactsForVulnerability = artifactEntry.getValue();
                        for (Artifact artifact : artifactsForVulnerability) {
                            advisoryEntry.manuallyAffectsArtifact(key, artifact);
                        }
                    }
                }
            }
        }

        // add advisory references on vulnerabilities where applicable
        this.reAssociateVulnerabilities();

        LOG.debug("Parsed [{}] vulnerabilities and [{}] security advisories in [{}] ms",
                this.vulnerabilities.size(), this.securityAdvisories.size(), System.currentTimeMillis() - startTime);
    }

    private static void extractAffectsArtifactsForKey(Artifact artifact, Map<String, Map<String, List<Artifact>>> affectsArtifacts, AbstractModelBase.Attribute attribute) {
        final String vulnerabilityString = artifact.get(attribute);
        if (StringUtils.hasText(vulnerabilityString)) {
            final Set<String> vulnerabilityNames = new HashSet<>(Arrays.asList(vulnerabilityString.split(", ")));
            for (String name : vulnerabilityNames) {
                affectsArtifacts
                        .computeIfAbsent(name, k -> new HashMap<>())
                        .computeIfAbsent(attribute.getKey(), k -> new ArrayList<>())
                        .add(artifact);
            }
        }
    }

    public static AeaaVulnerabilityContextInventory fromInventory(Inventory inventory) {
        final AeaaVulnerabilityContextInventory vInventory = new AeaaVulnerabilityContextInventory(inventory);
        vInventory.parse();
        return vInventory;
    }

    public static AeaaVulnerabilityContextInventory fromInventory(Inventory inventory, String vulnerabilityContextName) {
        final AeaaVulnerabilityContextInventory vInventory = new AeaaVulnerabilityContextInventory(inventory, vulnerabilityContextName);
        vInventory.parse();
        return vInventory;
    }

    public static AeaaVulnerabilityContextInventory fromInventory(Inventory inventory, AssetMetaData assetMetaData) {
        final String assessment = assetMetaData.get(AssetMetaData.Attribute.ASSESSMENT);
        return fromInventory(inventory, assessment);
    }

    public static AeaaVulnerabilityContextInventory empty() {
        return new AeaaVulnerabilityContextInventory(new Inventory());
    }
}
