/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa;

import org.apache.commons.lang3.ObjectUtils;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.Artifact;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.AeaaAdvisoryEntry;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.keywords.AeaaKeywordSet;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.score.AeaaVulnerabilityPriorityCalculator;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.store.AeaaAdvisoryTypeIdentifier;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.store.AeaaVulnerabilityTypeIdentifier;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.store.AeaaVulnerabilityTypeStore;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatus;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusConverter;
import org.metaeffekt.core.security.cvss.CvssSource;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.metaeffekt.core.security.cvss.KnownCvssEntities;
import org.metaeffekt.core.security.cvss.processor.CvssSelectionResult;
import org.metaeffekt.core.security.cvss.processor.CvssSelectionResult.CvssScoreVersionSelectionPolicy;
import org.metaeffekt.core.security.cvss.processor.CvssSelector;
import org.metaeffekt.core.security.cvss.processor.CvssVectorSet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.stream.Collectors;

public class AeaaVulnerability extends AeaaMatchableDetailsAmbDataClass<VulnerabilityMetaData, AeaaVulnerability> {

    private static final Logger LOG = LoggerFactory.getLogger(AeaaVulnerability.class);

    private final static Set<String> CONVERSION_KEYS_AMB = new HashSet<String>(AeaaMatchableDetailsAmbDataClass.CONVERSION_KEYS_AMB) {{
        addAll(Arrays.asList(
                VulnerabilityMetaData.Attribute.NAME.getKey(),
                VulnerabilityMetaData.Attribute.SOURCE.getKey(),
                VulnerabilityMetaData.Attribute.SOURCE_IMPLEMENTATION.getKey(),
                AeaaInventoryAttribute.DESCRIPTION.getKey(),
                VulnerabilityMetaData.Attribute.URL.getKey(),
                AeaaInventoryAttribute.VULNERABILITY_UPDATED_DATE_TIMESTAMP.getKey(),
                AeaaInventoryAttribute.VULNERABILITY_CREATED_DATE_TIMESTAMP.getKey(),
                VulnerabilityMetaData.Attribute.REFERENCES.getKey(),
                VulnerabilityMetaData.Attribute.WEAKNESS.getKey(),
                AeaaInventoryAttribute.TAGS.getKey(),
                AeaaInventoryAttribute.VULNERABILITY_STATUS.getKey()
        ));
    }};

    private final static Set<String> CONVERSION_KEYS_MAP = new HashSet<String>(AeaaMatchableDetailsAmbDataClass.CONVERSION_KEYS_MAP) {{
        addAll(Arrays.asList(
                "name", "description", "notes", "url", "cvssVectors", "createDate", "updateDate", "cwe",
                "vulnerable_software", "references", "tags", "vulnerabilityStatus"
        ));
    }};

    /**
     * Stores what provider this vulnerability originates from.<br>
     * Must be defined on all vulnerability instances.
     */
    protected AeaaVulnerabilityTypeIdentifier<?> sourceIdentifier;

    private String description;
    private String notes;
    private String url;

    protected Date createDate;
    protected Date updateDate;

    private final CvssVectorSet cvssVectors = new CvssVectorSet();
    private CvssSelectionResult cvssSelectionResult;

    private final Set<AeaaReference> references = new LinkedHashSet<>();
    private final Set<String> cwes = new LinkedHashSet<>();

    private final Set<AeaaAdvisoryEntry> securityAdvisories = new LinkedHashSet<>();

    private final Set<String> tags = new LinkedHashSet<>();
    private AeaaKevData kevData;

    private AeaaEpssData epssData;

    private AeaaVulnerabilityStatus vulnerabilityStatus;

    public AeaaVulnerability() {
    }

    public AeaaVulnerability(String id) {
        super.setId(id);
    }

    public void setSourceIdentifier(AeaaVulnerabilityTypeIdentifier<?> source) {
        if (source == null) {
            throw new IllegalArgumentException("Advisory source must not be null");
        }
        if (LOG.isDebugEnabled() && source != this.sourceIdentifier && this.sourceIdentifier != null) {
            LOG.warn("Explicitly assigned source differs from originally assigned [{}] --> [{}]", this.sourceIdentifier.toExtendedString(), source.toExtendedString());
        }
        this.sourceIdentifier = source;
    }

    @Override
    public AeaaVulnerabilityTypeIdentifier<?> getSourceIdentifier() {
        return sourceIdentifier;
    }

    /**
     * <p>Compute the effective state of this instance based on the given other instance.
     * The effective instances is either a new instance or the same instance, depending on the implementation.</p>
     * <p><i>'Effective'</i> is defined as the state of the instance that is the result of the computation of the
     * instance and the other instance. What this means specifically is up to the implementation.
     * This method returns <code>this</code> instance (itself) by default.</p>
     * <p>The effective instance should not be written back into an inventory, rather should be recalculated whenever
     * access to the effective instance is required to ensure data is not duplicated or left unmaintained in
     * inventories. Only use this to generate e.g. vulnerability-specific views on the VAD or other Reports.</p>
     *
     * @param other The other instance to compute the effective state from.
     * @return A new effective instance or the same instance, depending on the implementation.
     */
    public AeaaVulnerability computeEffectiveState(AeaaAdvisoryEntry other) {
        return this;
    }

    public void bakeEffectiveSecurityAdvisories() {
        synchronized (this.securityAdvisories) {
            final Set<AeaaAdvisoryEntry> effective = this.securityAdvisories.stream()
                    .map(advisory -> advisory.computeEffectiveState(this))
                    .collect(Collectors.toSet());
            this.securityAdvisories.clear();
            this.securityAdvisories.addAll(effective);
        }
    }

    @Override
    public Map<AeaaVulnerabilityTypeIdentifier<?>, Set<String>> getReferencedVulnerabilities() {
        return referencedVulnerabilities;
    }

    @Override
    public Map<AeaaAdvisoryTypeIdentifier<?>, Set<String>> getReferencedSecurityAdvisories() {
        return referencedSecurityAdvisories;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }

    public String getNotes() {
        return notes;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getUrl() {
        if (url != null) {
            return url;
        } else {
            if (id.startsWith("CVE-")) {
                return "https://nvd.nist.gov/vuln/detail/" + id;
            } else {
                return null;
            }
        }
    }

    public void setCreateDate(Date createDate) {
        this.createDate = createDate;
    }

    public Date getCreateDate() {
        return createDate;
    }

    public boolean isCreatedAfter(Date date) {
        return createDate != null && createDate.after(date);
    }

    public boolean isCreatedBefore(Date date) {
        return createDate != null && createDate.before(date);
    }

    public void setUpdateDate(Date updateDate) {
        this.updateDate = updateDate;
    }

    public Date getUpdateDate() {
        return updateDate;
    }

    public boolean isUpdatedAfter(Date date) {
        return updateDate != null && updateDate.after(date);
    }

    public boolean isUpdatedBefore(Date date) {
        return updateDate != null && updateDate.before(date);
    }

    public void addReference(AeaaReference reference) {
        this.references.add(reference);
    }

    public void addReferences(Collection<AeaaReference> references) {
        this.references.addAll(references);
    }

    public Set<AeaaReference> getReferences() {
        return references;
    }

    public void addCwe(String cwe) {
        if (cwe != null) this.cwes.add(cwe);
    }

    public void addCwe(String... cwe) {
        addCwes(Arrays.asList(cwe));
    }

    private void addCwes(Collection<String> cwes) {
        cwes.forEach(this::addCwe);
    }

    public Set<String> getCwes() {
        return cwes;
    }

    public String getCweString() {
        return String.join(", ", cwes);
    }

    public void setVulnerabilityStatus(AeaaVulnerabilityStatus vulnerabilityStatus) {
        this.vulnerabilityStatus = vulnerabilityStatus;
    }

    public AeaaVulnerabilityStatus getVulnerabilityStatus() {
        return vulnerabilityStatus;
    }

    public Optional<AeaaVulnerabilityStatus> optVulnerabilityStatus() {
        return Optional.ofNullable(vulnerabilityStatus);
    }

    public AeaaVulnerabilityStatus getOrCreateNewVulnerabilityStatus() {
        if (vulnerabilityStatus == null) {
            vulnerabilityStatus = new AeaaVulnerabilityStatus();
        }
        return vulnerabilityStatus;
    }

    public void addTag(String tag) {
        this.tags.add(tag);
    }

    public void addTags(Collection<String> tags) {
        this.tags.addAll(tags);
    }

    public Set<String> getTags() {
        return this.tags;
    }

    public boolean hasTag(String tag) {
        return this.tags.contains(tag);
    }

    /* SECURITY ADVISORIES */

    public Map<AeaaAdvisoryTypeIdentifier<?>, Set<String>> deepCopyReferencedSecurityAdvisories() {
        final Map<AeaaAdvisoryTypeIdentifier<?>, Set<String>> copy = new HashMap<>();
        synchronized (this.referencedSecurityAdvisories) {
            for (Map.Entry<AeaaAdvisoryTypeIdentifier<?>, Set<String>> referencedEntry : referencedSecurityAdvisories.entrySet()) {
                copy.put(referencedEntry.getKey(), new HashSet<>(referencedEntry.getValue()));
            }
        }
        return copy;
    }

    public void addSecurityAdvisory(AeaaAdvisoryEntry advisoryEntry) {
        this.securityAdvisories.add(advisoryEntry);
        this.addReferencedSecurityAdvisory(advisoryEntry.getSourceIdentifier(), advisoryEntry.getId());
    }

    public void removeSecurityAdvisory(AeaaAdvisoryEntry advisoryEntry) {
        this.securityAdvisories.remove(advisoryEntry);
        this.addReferencedSecurityAdvisory(advisoryEntry.getSourceIdentifier(), advisoryEntry.getId());
    }

    public Set<AeaaAdvisoryEntry> getSecurityAdvisories() {
        return securityAdvisories;
    }

    public Set<AeaaAdvisoryEntry> getRelatedAdvisoriesOfType(String type) {
        return getRelatedAdvisoriesOfType(type, this.securityAdvisories);
    }

    public static Set<AeaaAdvisoryEntry> getRelatedAdvisoriesOfType(String type, Collection<AeaaAdvisoryEntry> securityAdvisories) {
        if (org.apache.commons.lang3.StringUtils.isBlank(type)) {
            return Collections.emptySet();
        }

        return securityAdvisories.stream()
                .filter(advisoryEntry -> Objects.equals(advisoryEntry.getType(), type))
                .collect(Collectors.toSet());
    }

    public Set<AeaaAdvisoryEntry> getRelatedAdvisorsOfSource(AeaaAdvisoryTypeIdentifier<?> source) {
        if (source == null) {
            return Collections.emptySet();
        }

        return securityAdvisories.stream()
                .filter(advisoryEntry -> advisoryEntry.getSourceIdentifier() == source)
                .collect(Collectors.toSet());
    }

    public <A extends AeaaAdvisoryEntry> List<A> getRelatedAdvisorsOfSource(AeaaAdvisoryTypeIdentifier<?> type, Class<A> typeClass) {
        if (type == null || typeClass == null) {
            return Collections.emptyList();
        }

        return getRelatedAdvisorsOfSource(type).stream()
                .filter(typeClass::isInstance)
                .map(typeClass::cast)
                .collect(Collectors.toList());
    }

    public Set<AeaaAdvisoryTypeIdentifier<?>> getRelatedAdvisorsTypes() {
        return securityAdvisories.stream()
                .map(AeaaAdvisoryEntry::getSourceIdentifier)
                .collect(Collectors.toSet());
    }

    public void setKevData(AeaaKevData kevData) {
        this.kevData = kevData;
    }

    public AeaaKevData getKevData() {
        return kevData;
    }

    public void setEpssData(AeaaEpssData epssData) {
        this.epssData = epssData;
    }

    public AeaaEpssData getEpssData() {
        return epssData;
    }

    /* CVSS */

    public CvssVectorSet getCvssVectors() {
        return this.cvssVectors;
    }

    /**
     * This method will only return a meaningful result if the instance has been created via the
     * {@link AeaaVulnerabilityContextInventory} class or if the
     * {@link #securityAdvisories} and {@link #affectedArtifacts} have manually been filled appropriately.
     * <p>
     * Effective in this context means that the {@link CvssVector}s from the {@link #securityAdvisories} are
     * added to the {@link #cvssVectors} if the {@link CvssVector#getApplicabilityCondition()} is met.
     * To determine whether this is the case, several factors like MSRC information from the affected artifacts are
     * taken into account.
     * <p>
     * Consider using {@link #selectEffectiveCvssVectors(CvssSelector, CvssSelector, List)} to pre-calculate the effective
     * {@link CvssVector}s if you expect to call this method multiple times to reduce the overhead of the calculation.
     *
     * @return a {@link CvssVectorSet} containing the effective {@link CvssVector}s for this vulnerability.
     */
    public CvssVectorSet calculateEffectiveCvssVectors() {
        return calculateEffectiveCvssVectors(this.cvssVectors);
    }

    public CvssVectorSet calculateEffectiveCvssVectors(CvssVectorSet cvssVectors) {
        final CvssVectorSet effectiveCvssVectors = new CvssVectorSet();

        // add all cvss vectors from the vulnerability itself
        effectiveCvssVectors.addAllCvssVectors(cvssVectors);

        // add all cvss vectors from the security advisories that are applicable
        for (AeaaAdvisoryEntry advisoryEntry : this.securityAdvisories) {
            for (CvssVector sourcedCvssVector : advisoryEntry.getCvssVectors().getCvssVectors()) {
                if (isCvssVectorApplicable(sourcedCvssVector.getApplicabilityCondition())) {
                    effectiveCvssVectors.addCvssVector(sourcedCvssVector);
                }
            }
        }

        return effectiveCvssVectors;
    }

    protected boolean isCvssVectorApplicable(JSONObject applicabilityCondition) {
        if (applicabilityCondition == null || applicabilityCondition.isEmpty()) {
            return true;
        }

        final Object findMsProductIdsObj = applicabilityCondition.opt(AeaaInventoryAttribute.MATCHES_ON_MS_PRODUCT_ID.getKey());
        if (findMsProductIdsObj instanceof JSONArray) {
            final List<String> findMsProductIds = ((JSONArray) findMsProductIdsObj).toList().stream().map(String::valueOf).collect(Collectors.toList());
            boolean foundMatchingArtifact = false;

            for (Artifact artifact : this.getAffectedArtifactsByDefaultKey()) {
                final String msProductId = artifact.get(AeaaInventoryAttribute.MS_PRODUCT_ID);
                if (msProductId == null) {
                    continue;
                }
                final List<String> artifactMsProductIds = Arrays.asList(msProductId.split(", "));
                if (artifactMsProductIds.stream().anyMatch(findMsProductIds::contains)) {
                    foundMatchingArtifact = true;
                    break;
                }
            }

            if (!foundMatchingArtifact) {
                return false;
            }
        }

        return true;
    }

    public CvssSelectionResult selectEffectiveCvssVectors(CvssVectorSet cvssVectorSet, CvssSelector baseSelector, CvssSelector effectiveSelector, List<CvssScoreVersionSelectionPolicy> versionSelectionPolicy) {
        return new CvssSelectionResult(
                cvssVectorSet,
                baseSelector, effectiveSelector,
                versionSelectionPolicy
        );
    }

    public CvssSelectionResult selectEffectiveCvssVectors(CvssVectorSet cvssVectorSet, CentralSecurityPolicyConfiguration config) {
        return selectEffectiveCvssVectors(
                cvssVectorSet,
                config.getInitialCvssSelector(), config.getContextCvssSelector(),
                config.getCvssVersionSelectionPolicy()
        );
    }

    public void selectEffectiveCvssVectors(CvssSelector baseSelector, CvssSelector effectiveSelector, List<CvssScoreVersionSelectionPolicy> versionSelectionPolicy) {
        this.cvssSelectionResult = selectEffectiveCvssVectors(
                this.calculateEffectiveCvssVectors(),
                baseSelector, effectiveSelector,
                versionSelectionPolicy
        );
    }

    public void selectEffectiveCvssVectors(CentralSecurityPolicyConfiguration config) {
        selectEffectiveCvssVectors(
                config.getInitialCvssSelector(), config.getContextCvssSelector(),
                config.getCvssVersionSelectionPolicy()
        );
    }

    public CvssSelectionResult getCvssSelectionResult() {
        if (cvssSelectionResult == null) {
            throw new IllegalStateException("No cvss selection result available. Please call selectEffectiveCvssVectors() first, or use the getCvssSelectionResult(CentralSecurityPolicyConfiguration) method to select the effective cvss vectors on the fly.");
        }
        return cvssSelectionResult;
    }

    public CvssSelectionResult getCvssSelectionResult(CentralSecurityPolicyConfiguration config) {
        if (cvssSelectionResult == null) {
            if (config == null) {
                throw new IllegalStateException("No cvss selection result available and passed CentralSecurityPolicyConfiguration is null, cannot select cvss vectors on the fly.");
            }
            selectEffectiveCvssVectors(config);
        }
        return cvssSelectionResult;
    }

    public void clearCvssSelectionResult() {
        this.cvssSelectionResult = null;
    }

    public void mapCvssSelectionResult(Function<CvssSelectionResult, CvssSelectionResult> mapper) {
        if (this.cvssSelectionResult == null) {
            throw new IllegalStateException("No cvss selection result available. Please call selectEffectiveCvssVectors() first, or use the getCvssSelectionResult(CentralSecurityPolicyConfiguration) method to select the effective cvss vectors on the fly.");
        }
        this.cvssSelectionResult = mapper.apply(this.cvssSelectionResult);
    }

    public List<AeaaKeywordSet> parseKeywords() {
        return AeaaKeywordSet.fromVulnerability(this);
    }

    public AeaaVulnerabilityPriorityCalculator.AeaaPriorityScoreResult calculatePriorityScore(CentralSecurityPolicyConfiguration config) {
        if (config == null) {
            throw new IllegalArgumentException("CentralSecurityPolicyConfiguration must not be null.");
        }
        return new AeaaVulnerabilityPriorityCalculator().contribute(this).calculatePriorityScore(config);
    }

    /* CLEANING DATA */

    public void clearNonTransferableStatusDetails() {
        this.setAdditionalAttribute(VulnerabilityMetaData.Attribute.STATUS, null);
        this.setAdditionalAttribute(VulnerabilityMetaData.Attribute.RATIONALE, null);
        this.setAdditionalAttribute(VulnerabilityMetaData.Attribute.RISK, null);

        this.setAdditionalAttribute(AeaaInventoryAttribute.STATUS_ACCEPTED, null);
        this.setAdditionalAttribute(AeaaInventoryAttribute.STATUS_REPORTED, null);
        this.setAdditionalAttribute(AeaaInventoryAttribute.STATUS_HISTORY, null);
        this.setAdditionalAttribute(AeaaInventoryAttribute.STATUS_TITLE, null);

        this.setAdditionalAttribute(AeaaInventoryAttribute.REVIEWED_ADVISORIES, null);
    }

    /* TYPE CONVERSION METHODS */

    @Override
    public VulnerabilityMetaData constructBaseModel() {
        return new VulnerabilityMetaData();
    }

    @Override
    protected Set<String> conversionKeysAmb() {
        return CONVERSION_KEYS_AMB;
    }

    @Override
    protected Set<String> conversionKeysMap() {
        return CONVERSION_KEYS_MAP;
    }

    public static AeaaVulnerability fromVulnerabilityMetaData(VulnerabilityMetaData vmd) {
        if (vmd == null) return null;
        return new AeaaVulnerability()
                .performAction(v -> v.appendFromBaseModel(vmd));
    }

    public static AeaaVulnerability fromInputMap(Map<String, Object> map) {
        if (map == null) return null;
        return new AeaaVulnerability()
                .performAction(v -> v.appendFromMap(map));
    }

    public static AeaaVulnerability fromJson(JSONObject json) {
        if (json == null) return null;
        return fromInputMap(json.toMap());
    }

    @Override
    public void appendFromBaseModel(VulnerabilityMetaData vmd) {
        super.appendFromBaseModel(vmd);

        this.setId(vmd.get(VulnerabilityMetaData.Attribute.NAME));

        final String vulnerabilitySource = vmd.get(VulnerabilityMetaData.Attribute.SOURCE);
        final String vulnerabilitySourceImplementation = vmd.get(VulnerabilityMetaData.Attribute.SOURCE_IMPLEMENTATION);
        if (StringUtils.hasText(vulnerabilitySource) || StringUtils.hasText(vulnerabilitySourceImplementation)) {
            this.setSourceIdentifier(AeaaVulnerabilityTypeStore.get().fromNameAndImplementation(vulnerabilitySource, vulnerabilitySourceImplementation));
        } else {
            AeaaVulnerabilityTypeStore.get().fromId(this.getId()).ifPresent(inferred -> {
                LOG.debug("Inferred source identifier [{}] for vulnerability [{}]", inferred.toExtendedString(), this.getId());
                setSourceIdentifier(inferred);
            });
        }

        this.setDescription(vmd.get(AeaaInventoryAttribute.DESCRIPTION.getKey()));
        this.setUrl(vmd.get(VulnerabilityMetaData.Attribute.URL));

        CvssSource.fromMultipleColumnHeaderStrings(vmd.getAttributes()).forEach((header, source) -> {
            if (StringUtils.hasText(vmd.get(header))) {
                this.cvssVectors.addCvssVector(source, vmd.get(header));
            }
        });

        if (StringUtils.hasText(vmd.get(AeaaInventoryAttribute.VULNERABILITY_UPDATED_DATE_TIMESTAMP.getKey()))) {
            this.setUpdateDate(new Date(Long.parseLong(vmd.get(AeaaInventoryAttribute.VULNERABILITY_UPDATED_DATE_TIMESTAMP.getKey()))));
        }
        if (StringUtils.hasText(vmd.get(AeaaInventoryAttribute.VULNERABILITY_CREATED_DATE_TIMESTAMP.getKey()))) {
            this.setCreateDate(new Date(Long.parseLong(vmd.get(AeaaInventoryAttribute.VULNERABILITY_CREATED_DATE_TIMESTAMP.getKey()))));
        }

        if (StringUtils.hasText(vmd.get(VulnerabilityMetaData.Attribute.REFERENCES))) {
            final String referencesString = vmd.get(VulnerabilityMetaData.Attribute.REFERENCES);

            if (referencesString.startsWith("[")) {
                final List<AeaaReference> references = AeaaReference.fromJsonArray(new JSONArray(referencesString));
                this.addReferences(references);
            } else {
                for (String ref : referencesString.split(", ?")) {
                    final Matcher matcher = AeaaReference.REFERENCE_STRING_PATTERN.matcher(ref);
                    if (matcher.matches()) {
                        this.addReference(AeaaReference.fromTitleAndUrl(matcher.group(1) + "(" + matcher.group(3) + ")", matcher.group(2)));
                    } else {
                        this.addReference(AeaaReference.fromUrl(ref));
                    }
                }
            }
        }

        if (StringUtils.hasText(vmd.get(VulnerabilityMetaData.Attribute.WEAKNESS))) {
            this.addCwes(Arrays.asList(vmd.get(VulnerabilityMetaData.Attribute.WEAKNESS).split(", ?")));
        }

        if (vmd.get(AeaaInventoryAttribute.KEV_DATA) != null) {
            this.setKevData(AeaaKevData.fromJson(new JSONObject(vmd.get(AeaaInventoryAttribute.KEV_DATA))));
        }

        if (vmd.get(AeaaInventoryAttribute.EPSS_DATA) != null) {
            this.setEpssData(AeaaEpssData.fromJson(new JSONObject(vmd.get(AeaaInventoryAttribute.EPSS_DATA))));
        }

        final String tagsString = vmd.get(AeaaInventoryAttribute.TAGS.getKey());
        if (StringUtils.hasText(tagsString)) {
            this.addTags(Arrays.asList(tagsString.split(", ")));
        }

        if (StringUtils.hasText(vmd.get(AeaaInventoryAttribute.VULNERABILITY_STATUS))) {
            this.setVulnerabilityStatus(AeaaVulnerabilityStatusConverter.fromJson(new JSONObject(vmd.get(AeaaInventoryAttribute.VULNERABILITY_STATUS))));
        }
    }

    @Override
    public void appendToBaseModel(VulnerabilityMetaData vmd) {
        super.appendToBaseModel(vmd);

        if (this.url != null) {
            vmd.set(VulnerabilityMetaData.Attribute.URL, this.url);
        } else if (StringUtils.hasText(this.id) && this.id.startsWith("CVE-")) {
            vmd.set(VulnerabilityMetaData.Attribute.URL, "https://nvd.nist.gov/vuln/detail/" + this.id);
        } else {
            vmd.set(VulnerabilityMetaData.Attribute.URL, null);
        }

        if (!this.cwes.isEmpty()) {
            vmd.set(VulnerabilityMetaData.Attribute.WEAKNESS, String.join(", ", this.cwes));
        } else {
            vmd.set(VulnerabilityMetaData.Attribute.WEAKNESS, null);
        }

        if (this.epssData != null) {
            vmd.set(AeaaInventoryAttribute.EPSS_DATA, this.epssData.toJson().toString());
        } else {
            vmd.set(AeaaInventoryAttribute.EPSS_DATA, null);
        }

        for (CvssVector entry : this.cvssVectors.getCvssVectors()) {
            if (entry.getCvssSource() == null) {
                LOG.warn("Using NVD-CNA-NVD for cvss vector [{}] for vulnerability [{}] as it has no source.", entry, this.id);
                vmd.set(new CvssSource(KnownCvssEntities.NVD, CvssSource.CvssIssuingEntityRole.CNA, KnownCvssEntities.NVD, entry.getClass()).toColumnHeaderString(), entry.toString());
            } else {
                vmd.set(entry.getCvssSource().toColumnHeaderString(), entry.toString());
            }
        }

        if (this.createDate != null) {
            vmd.set(AeaaInventoryAttribute.VULNERABILITY_CREATED_DATE_TIMESTAMP.getKey(), Long.toString(this.createDate.getTime()));
            vmd.set(AeaaInventoryAttribute.VULNERABILITY_CREATED_DATE_FORMATTED.getKey(), AeaaTimeUtils.formatNormalizedDate(this.createDate));
        } else {
            vmd.set(AeaaInventoryAttribute.VULNERABILITY_CREATED_DATE_TIMESTAMP.getKey(), null);
        }
        if (this.updateDate != null) {
            vmd.set(AeaaInventoryAttribute.VULNERABILITY_UPDATED_DATE_TIMESTAMP.getKey(), Long.toString(this.updateDate.getTime()));
            vmd.set(AeaaInventoryAttribute.VULNERABILITY_UPDATED_DATE_FORMATTED.getKey(), AeaaTimeUtils.formatNormalizedDate(this.updateDate));
        } else {
            vmd.set(AeaaInventoryAttribute.VULNERABILITY_UPDATED_DATE_TIMESTAMP.getKey(), null);
        }

        if (!this.references.isEmpty()) {
            final List<AeaaReference> mergedReferences = AeaaReference.mergeReferences(this.references, AeaaReference.fromJsonArray((vmd.get(VulnerabilityMetaData.Attribute.REFERENCES))));
            vmd.set(VulnerabilityMetaData.Attribute.REFERENCES, new JSONArray(mergedReferences.stream().map(AeaaReference::toJson).collect(Collectors.toList())).toString());
        } else {
            vmd.set(VulnerabilityMetaData.Attribute.REFERENCES, null);
        }

        if (this.description != null) {
            vmd.set(AeaaInventoryAttribute.DESCRIPTION.getKey(), this.description);
        } else {
            vmd.set(AeaaInventoryAttribute.DESCRIPTION.getKey(), null);
        }

        if (this.kevData != null) {
            vmd.set(AeaaInventoryAttribute.KEV_DATA, kevData.toJson().toString());
        } else {
            vmd.set(AeaaInventoryAttribute.KEV_DATA, null);
        }

        if (this.epssData != null) {
            vmd.set(AeaaInventoryAttribute.EPSS_DATA, epssData.toJson().toString());
        } else {
            vmd.set(AeaaInventoryAttribute.EPSS_DATA, null);
        }


        if (!this.tags.isEmpty()) {
            vmd.set(AeaaInventoryAttribute.TAGS.getKey(), String.join(", ", this.tags));
        } else {
            vmd.set(AeaaInventoryAttribute.TAGS.getKey(), null);
        }

        if (this.vulnerabilityStatus != null) {
            vmd.set(AeaaInventoryAttribute.VULNERABILITY_STATUS, this.vulnerabilityStatus.toJson().toString());
        } else {
            vmd.set(AeaaInventoryAttribute.VULNERABILITY_STATUS, null);
        }
    }

    @Override
    public void appendFromDataClass(AeaaVulnerability dataClass) {
        super.appendFromDataClass(dataClass);

        if (StringUtils.hasText(dataClass.getDescription())) {
            this.setDescription(dataClass.getDescription());
        }
        if (StringUtils.hasText(dataClass.getNotes())) {
            this.setNotes(dataClass.getNotes());
        }
        if (StringUtils.hasText(dataClass.getUrl())) {
            this.setUrl(dataClass.getUrl());
        }

        if (dataClass.getCreateDate() != null) {
            this.setCreateDate(dataClass.getCreateDate());
        }
        if (dataClass.getUpdateDate() != null) {
            this.setUpdateDate(dataClass.getUpdateDate());
        }

        this.cvssVectors.addAllCvssVectors(dataClass.getCvssVectors());

        this.addReferences(dataClass.getReferences());
        this.addCwes(dataClass.getCwes());

        this.setKevData(dataClass.getKevData());


        this.setEpssData(dataClass.getEpssData());

        this.getReferencedVulnerabilities().putAll(dataClass.getReferencedVulnerabilities());
        this.getReferencedSecurityAdvisories().putAll(dataClass.getReferencedSecurityAdvisories());

        dataClass.getSecurityAdvisories().forEach(this::addSecurityAdvisory);

        if (dataClass.getVulnerabilityStatus() != null) {
            this.setVulnerabilityStatus(dataClass.getVulnerabilityStatus());
        }

        this.addTags(dataClass.getTags());
    }

    @Override
    public void appendFromMap(Map<String, Object> input) {
        super.appendFromMap(input);

        this.setId(getStringOrNullFromMap(input, "name"));

        final String source = (String) input.getOrDefault("source", null);
        final String sourceImplementation = (String) input.getOrDefault("sourceImplementation", null);
        if (source != null || sourceImplementation != null) {
            this.setSourceIdentifier(AeaaVulnerabilityTypeStore.get().fromNameAndImplementation(source, sourceImplementation));
        }

        this.setDescription(getStringOrNullFromMap(input, "description"));
        this.setNotes(getStringOrNullFromMap(input, "notes"));
        this.setUrl(getStringOrNullFromMap(input, "url"));

        if (input.get("cvss") != null) {
            final JSONArray cvssVectorsJson;
            if (input.get("cvss") instanceof String) {
                final String cvssVectors = (String) input.get("cvss");
                cvssVectorsJson = new JSONArray(cvssVectors);
            } else if (input.get("cvss") instanceof JSONArray) {
                cvssVectorsJson = (JSONArray) input.get("cvss");
            } else if (input.get("cvss") instanceof Collection) {
                cvssVectorsJson = new JSONArray((Collection) input.get("cvss"));
            } else {
                throw new RuntimeException("Unable to parse cvss vectors from input map: " + input.get("cvss"));
            }
            this.cvssVectors.addAllCvssVectors(CvssVectorSet.fromJson(cvssVectorsJson));
        }

        this.setCreateDate(ObjectUtils.firstNonNull(getDateOrNullFromMap(input, "createDate"), getDateOrNullFromMap(input, "publishedDate")));
        this.setUpdateDate(ObjectUtils.firstNonNull(getDateOrNullFromMap(input, "updateDate"), getDateOrNullFromMap(input, "lastModifiedDate")));

        for (String cwe : ((Collection<String>) input.getOrDefault("cwe", Collections.EMPTY_SET))) {
            this.addCwe(cwe);
        }


        final Object ref = input.get("references");
        if (ref instanceof ArrayList) {
            for (Object reference : (ArrayList<Object>) ref) {
                if (reference instanceof Map) {
                    this.addReference(AeaaReference.fromMap((Map<String, Object>) reference));
                } else {
                    LOG.warn("Reference in custom vulnerability [{}] is not of type Map: {}", this.getId(), reference);
                }
            }
        }

        if (input.get("tags") != null) {
            this.addTags((Collection<String>) input.get("tags"));
        }

        if (input.get("vulnerabilityStatus") != null) {
            this.setVulnerabilityStatus(AeaaVulnerabilityStatusConverter.fromJson(new JSONObject((Map<String, Object>) input.get("vulnerabilityStatus"))));
        }
    }

    @Override
    public void appendToJson(JSONObject json) {
        super.appendToJson(json);

        json.put("name", getId());
        json.put("description", getDescription());
        json.put("notes", getNotes());
        json.put("url", getUrl());

        json.put("cvss", this.cvssVectors.toJson());

        json.put("createDate", getCreateDate() != null ? getCreateDate().getTime() : null);
        json.put("updateDate", getUpdateDate() != null ? getUpdateDate().getTime() : null);

        json.put("cwe", getCwes());
        json.put("references", new JSONArray(getReferences().stream().map(AeaaReference::toJson).collect(Collectors.toList())));

        json.put("tags", getTags());
        json.put("vulnerabilityStatus", getVulnerabilityStatus() != null ? getVulnerabilityStatus().toJson() : null);
    }

    private static boolean isNoInfoOtherCwe(String value) {
        value = value.toLowerCase();
        return value.equals("nvd-cwe-noinfo") || value.equals("nvd-cwe-other");
    }

    private static String getStringOrNullFromMap(Map<String, Object> map, String key) {
        Object value = map.getOrDefault(key, null);
        if (value == null) return null;
        return String.valueOf(value);
    }

    private static Date getDateOrNullFromMap(Map<String, Object> map, String key) {
        Object value = map.getOrDefault(key, null);
        if (value == null) return null;
        return AeaaTimeUtils.tryParse(value.toString());
    }

    @Override
    public String toString() {
        return getId();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AeaaVulnerability that = (AeaaVulnerability) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    /* STATIC UTILITIES */

    public final static Comparator<AeaaVulnerability> COMPARE_BY_NAME = Comparator.comparing(AeaaVulnerability::getId);

    public static Map<Artifact, List<AeaaVulnerability>> groupVulnerabilitiesByArtifact(Collection<AeaaVulnerability> vulnerabilities) {
        final Map<Artifact, List<AeaaVulnerability>> groupedVulnerabilities = new HashMap<>();

        for (AeaaVulnerability vulnerability : vulnerabilities) {
            for (Artifact artifact : vulnerability.getAffectedArtifactsByDefaultKey()) {
                groupedVulnerabilities.computeIfAbsent(artifact, k -> new ArrayList<>()).add(vulnerability);
            }
        }

        return groupedVulnerabilities;
    }
}
