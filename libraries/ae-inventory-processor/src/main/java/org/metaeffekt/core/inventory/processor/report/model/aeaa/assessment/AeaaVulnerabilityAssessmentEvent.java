/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment;

import com.google.gson.reflect.TypeToken;
import lombok.*;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaTimeUtils;
import org.metaeffekt.core.security.cvss.CvssSource;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.metaeffekt.core.security.cvss.KnownCvssEntities;
import org.springframework.lang.NonNull;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment.AeaaVulnerabilityAssessmentOperations.GSON;
import static org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment.AeaaVulnerabilityAssessmentOperations.parseIfPresent;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Slf4j
public class AeaaVulnerabilityAssessmentEvent implements Comparable<AeaaVulnerabilityAssessmentEvent> {
    /**
     * If there are later events, this event and all prior ones are discarded.
     * If this is the latest event, it remains active.
     */
    @Builder.Default
    private boolean discardOnSubsequentEvents = false;
    /**
     * When this flag is set, all prior assessment events are discarded,
     * and the current event becomes the new baseline for calculating the effective result.<br>
     * This leads to only the latest <code>reset</code> entry to be the effective starting point.
     */
    @Builder.Default
    private boolean discardPriorEvents = false;

    @Builder.Default
    private boolean active = true;

    @Builder.Default
    private AeaaVulnerabilityAssessment.Scope scope = AeaaVulnerabilityAssessment.Scope.VULNERABILITY;

    private String status;
    private String rationale, risk, measures;
    private String author;
    private Long date;
    private Double score;
    @Builder.Default
    private int priority = 0;

    private CvssModificationGroup cvssV2;
    private CvssModificationGroup cvssV3P0;
    private CvssModificationGroup cvssV3P1;
    private CvssModificationGroup cvssV4P0;

    @Builder.Default
    private List<ReviewedAdvisory> reviewedAdvisories = new ArrayList<>();

    private MatchReason matchReason;

    // SECTION: query

    public AeaaVulnerabilityAssessmentEvent deriveMatched(MatchReason matchReason) {
        final AeaaVulnerabilityAssessmentEvent matched = fromJson(toJson());
        matched.matchReason = matchReason;
        return matched;
    }

    public void addReviewedAdvisory(List<AeaaVulnerabilityAssessmentEvent> refEvents, String id) {
        final boolean selfContains = reviewedAdvisories.stream().anyMatch(a -> id.equals(a.getId()));
        if (selfContains) {
            return;
        }

        final boolean anyRefContains = refEvents.stream().anyMatch(e -> e.reviewedAdvisories.stream().anyMatch(a -> id.equals(a.getId())));
        if (anyRefContains) {
            return;
        }

        reviewedAdvisories.add(new ReviewedAdvisory(id, "No rationale provided"));
    }

    // SECTION: serialize

    public String toJson() {
        return GSON.toJson(this);
    }

    public static String toJson(Collection<AeaaVulnerabilityAssessmentEvent> events) {
        return GSON.toJson(events);
    }

    public JSONObject toJsonObject() {
        return new JSONObject(GSON.toJson(this));
    }

    public static JSONArray toJsonArray(Collection<AeaaVulnerabilityAssessmentEvent> events) {
        return new JSONArray(GSON.toJson(events));
    }

    @Override
    public String toString() {
        return toJson();
    }

    // SECTION: deserialize

    public static AeaaVulnerabilityAssessmentEvent fromJson(String json) {
        return GSON.fromJson(json, AeaaVulnerabilityAssessmentEvent.class);
    }

    public static List<AeaaVulnerabilityAssessmentEvent> fromJsonArray(String json) {
        return GSON.fromJson(json, new TypeToken<List<AeaaVulnerabilityAssessmentEvent>>() {
        }.getType());
    }

    public static AeaaVulnerabilityAssessmentEvent fromJson(JSONObject json) {
        return fromJson(json.toString());
    }

    public static List<AeaaVulnerabilityAssessmentEvent> fromJsonArray(JSONArray json) {
        return fromJsonArray(json.toString());
    }

    public static AeaaVulnerabilityAssessmentEvent fromMap(Map<String, Object> event) {
        final AeaaVulnerabilityAssessmentEvent assessmentEvent = new AeaaVulnerabilityAssessmentEvent();

        assessmentEvent.active = (Boolean) event.getOrDefault("active", true);

        assessmentEvent.discardOnSubsequentEvents = (Boolean) event.getOrDefault("discard on subsequent events", false);
        assessmentEvent.discardPriorEvents = (Boolean) event.getOrDefault("discard prior events", false);

        assessmentEvent.status = (String) event.get("status");
        assessmentEvent.rationale = (String) event.get("rationale");
        assessmentEvent.risk = (String) event.get("risk");
        assessmentEvent.measures = (String) event.get("measures");
        assessmentEvent.author = (String) event.get("author");
        assessmentEvent.date = parseIfPresent(event, "date", String.class, 0L, d -> AeaaTimeUtils.tryParse(d).getTime());
        assessmentEvent.score = event.containsKey("score") ? Double.parseDouble(event.get("score").toString()) : null;
        assessmentEvent.priority = (Integer) event.getOrDefault("priority", 0);


        if (event.get("cvss") != null && event.get("cvss") instanceof List) {
            final List<Object> cvss = (List<Object>) event.get("cvss");

            for (Object entry : cvss) {
                if (entry instanceof Map) {
                    final CvssModificationGroup cvssV2 = parseIfPresent((Map) entry, "v2.0", Map.class, null, CvssModificationGroup::fromMap);
                    final CvssModificationGroup cvssV3P0 = parseIfPresent((Map) entry, "v3.0", Map.class, null, CvssModificationGroup::fromMap);
                    final CvssModificationGroup cvssV3P1 = parseIfPresent((Map) entry, "v3.1", Map.class, null, CvssModificationGroup::fromMap);
                    final CvssModificationGroup cvssV4P0 = parseIfPresent((Map) entry, "v4.0", Map.class, null, CvssModificationGroup::fromMap);

                    final String overallRationale = parseIfPresent((Map) entry, "rationale", String.class, null, Function.identity());

                    if (cvssV2 != null && cvssV2.containsModification()) {
                        cvssV2.appendRationale(overallRationale);
                        if (assessmentEvent.cvssV2 == null) {
                            assessmentEvent.cvssV2 = cvssV2;
                        } else {
                            assessmentEvent.cvssV2.append(cvssV2);
                        }
                    }

                    if (cvssV3P0 != null && cvssV3P0.containsModification()) {
                        cvssV3P0.appendRationale(overallRationale);
                        if (assessmentEvent.cvssV3P0 == null) {
                            assessmentEvent.cvssV3P0 = cvssV3P0;
                        } else {
                            assessmentEvent.cvssV3P0.append(cvssV3P0);
                        }
                    }

                    if (cvssV3P1 != null && cvssV3P1.containsModification()) {
                        cvssV3P1.appendRationale(overallRationale);
                        if (assessmentEvent.cvssV3P1 == null) {
                            assessmentEvent.cvssV3P1 = cvssV3P1;
                        } else {
                            assessmentEvent.cvssV3P1.append(cvssV3P1);
                        }
                    }

                    if (cvssV4P0 != null && cvssV4P0.containsModification()) {
                        cvssV4P0.appendRationale(overallRationale);
                        if (assessmentEvent.cvssV4P0 == null) {
                            assessmentEvent.cvssV4P0 = cvssV4P0;
                        } else {
                            assessmentEvent.cvssV4P0.append(cvssV4P0);
                        }
                    }
                }
            }

        } else if (event.get("cvss") != null && event.get("cvss") instanceof Map) {
            log.error("Invalid CVSS modification group type, expected list, got old map syntax: {}", event.get("cvss"));
        }

        final Object reviewedAdvisories = event.get("advisory reviewed");
        if (reviewedAdvisories instanceof List) {
            for (Object reviewedAdvisory : (List) reviewedAdvisories) {
                assessmentEvent.reviewedAdvisories.add(ReviewedAdvisory.fromMap(reviewedAdvisory));
            }
            assessmentEvent.reviewedAdvisories.removeIf(Objects::isNull);
        }

        assessmentEvent.matchReason = parseIfPresent(event, "matchReason", Map.class, null, MatchReason::fromMap);

        // validation
        if (assessmentEvent.date == null || assessmentEvent.date == 0) {
            log.warn("Missing date in assessment event, setting to current date");
            assessmentEvent.setDate(AeaaTimeUtils.utcNow());
        }

        return assessmentEvent;
    }

    // SECTION: sorting

    private final static List<String> VULNERABILITY_STATUS_ORDER_DESCENDING = Arrays.asList(
            VulnerabilityMetaData.STATUS_VALUE_APPLICABLE,
            VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW,
            VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE,
            VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT,
            VulnerabilityMetaData.STATUS_VALUE_VOID);

    /**
     * <p>Since events are collected in potentially any order, they need to have an intrinsic ordering criteria that always allows
     * ordering them for evaluation.
     * The following rules are evaluated step by step, and the first matching one is the criteria that specifies the order
     * between the two events.</p>
     * <ol>
     * <li>The entry with the higher <code>priority</code> is moved upwards.</li>
     * <li>The entry with the <code>inventory</code> scope is moved downwards.</li>
     * <li>The inactive entry is moved downwards.</li>
     * <li>The entry with a date specified at all is moved upwards.</li>
     * <li>The entry with the later <code>date</code> is moved upwards.</li>
     * </ol>
     * <p>Since <code>date</code> is mandatory, this is usually the end of the comparison.
     * To ensure a consistent order, other properties are still evaluated:</p>
     * <ol>
     * <li>The entry with a rationale, measures, or risk is moved upwards.</li>
     * <li>The entry with a status is moved upwards.</li>
     * <li>The entry with the more severe status is moved upwards.</li>
     * </ol>
     *
     * @param o the object to be compared.
     * @return a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.
     */
    @Override
    public int compareTo(AeaaVulnerabilityAssessmentEvent o) {
        if (o == null) {
            return 1;
        }

        // higher priority first
        if (this.priority != o.priority) {
            return Integer.compare(o.priority, this.priority);
        }

        // inventory scope last
        if (this.scope != o.scope) {
            return this.scope == AeaaVulnerabilityAssessment.Scope.INVENTORY ? 1 : -1;
        }

        // inactive last
        if (this.active != o.active) {
            return this.active ? -1 : 1;
        }

        // if one of them does not have a date, it is moved downwards
        if (this.date == null || o.date == null) {
            return this.date == null ? 1 : -1;
        }
        // later date first
        if (!this.date.equals(o.date)) {
            return o.date.compareTo(this.date);
        }

        // rationale, measures, or risk first
        if (this.rationale != null || this.measures != null || this.risk != null) {
            return -1;
        }
        if (o.rationale != null || o.measures != null || o.risk != null) {
            return 1;
        }

        // status first
        if (this.status != null && o.status == null) {
            return -1;
        }
        if (o.status != null && this.status == null) {
            return 1;
        }

        // more severe status first
        final int thisStatusIndex = VULNERABILITY_STATUS_ORDER_DESCENDING.indexOf(this.status);
        final int oStatusIndex = VULNERABILITY_STATUS_ORDER_DESCENDING.indexOf(o.status);
        return Integer.compare(thisStatusIndex, oStatusIndex);
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CvssModificationGroup {
        private List<CvssModification> reset;
        private List<CvssModification> overwrite;
        private List<CvssModification> lowerScore;
        private List<CvssModification> lowerMetric;
        private List<CvssModification> upperScore;
        private List<CvssModification> upperMetric;

        public static CvssModificationGroup aggregateContributions(Collection<CvssModificationGroup> referenceGroups, Supplier<CvssVector> constructor) {
            final CvssModificationGroup group = new CvssModificationGroup();
            group.populateEmpty();

            for (CvssModificationGroup referenceGroup : referenceGroups) {
                final Set<String> resetMetrics = referenceGroup.findResetMetrics();
                group.getOverwrite().get(0).aggregateContributions(referenceGroup.getOverwrite(), resetMetrics, constructor);
                group.getLowerScore().get(0).aggregateContributions(referenceGroup.getLowerScore(), resetMetrics, constructor);
                group.getLowerMetric().get(0).aggregateContributions(referenceGroup.getLowerMetric(), resetMetrics, constructor);
                group.getUpperScore().get(0).aggregateContributions(referenceGroup.getUpperScore(), resetMetrics, constructor);
                group.getUpperMetric().get(0).aggregateContributions(referenceGroup.getUpperMetric(), resetMetrics, constructor);
            }

            group.clearEmpty();
            return group;
        }

        public static CvssModificationGroup fromMap(Object cvssModificationGroup) {
            if (cvssModificationGroup instanceof Map) {
                final Map<String, Object> cvssModificationGroupMap = (Map<String, Object>) cvssModificationGroup;
                final CvssModificationGroup group = new CvssModificationGroup();
                group.reset = parseIfPresent(cvssModificationGroupMap, "reset modification", List.class, null, CvssModification::fromList);
                group.overwrite = parseIfPresent(cvssModificationGroupMap, "overwrite metric", List.class, null, CvssModification::fromList);
                group.lowerScore = parseIfPresent(cvssModificationGroupMap, "lower score", List.class, null, CvssModification::fromList);
                group.lowerMetric = parseIfPresent(cvssModificationGroupMap, "lower metric", List.class, null, CvssModification::fromList);
                group.upperScore = parseIfPresent(cvssModificationGroupMap, "upper score", List.class, null, CvssModification::fromList);
                group.upperMetric = parseIfPresent(cvssModificationGroupMap, "upper metric", List.class, null, CvssModification::fromList);
                return group;
            }
            log.warn("Invalid CVSS modification group type [{}], skipping", cvssModificationGroup);
            return null;
        }

        public Set<String> findResetMetrics() {
            if (reset == null) return Collections.emptySet();

            final Set<String> resetMetrics = new HashSet<>();
            for (CvssModification resetModification : reset) {
                if (StringUtils.hasText(resetModification.getMetrics())) {
                    if ("all".equalsIgnoreCase(resetModification.getMetrics())) {
                        return Collections.singleton("all");
                    } else {
                        resetMetrics.addAll(Arrays.asList(resetModification.getMetrics().split("[/,] *")));
                    }
                }
            }
            return resetMetrics;
        }

        public void populateEmpty() {
            overwrite = new ArrayList<>(Collections.singletonList(CvssModification.empty()));
            lowerScore = new ArrayList<>(Collections.singletonList(CvssModification.empty()));
            lowerMetric = new ArrayList<>(Collections.singletonList(CvssModification.empty()));
            upperScore = new ArrayList<>(Collections.singletonList(CvssModification.empty()));
            upperMetric = new ArrayList<>(Collections.singletonList(CvssModification.empty()));
        }

        public boolean containsModification() {
            return (reset != null && !reset.isEmpty()) ||
                    (overwrite != null && !overwrite.isEmpty()) ||
                    (lowerScore != null && !lowerScore.isEmpty()) ||
                    (lowerMetric != null && !lowerMetric.isEmpty()) ||
                    (upperScore != null && !upperScore.isEmpty()) ||
                    (upperMetric != null && !upperMetric.isEmpty());
        }

        public void clearEmpty() {
            if (reset != null && !reset.isEmpty()) reset.removeIf(CvssModification::areMetricsEmpty);
            if (overwrite != null && !overwrite.isEmpty()) overwrite.removeIf(CvssModification::areMetricsEmpty);
            if (lowerScore != null && !lowerScore.isEmpty()) lowerScore.removeIf(CvssModification::areMetricsEmpty);
            if (lowerMetric != null && !lowerMetric.isEmpty()) lowerMetric.removeIf(CvssModification::areMetricsEmpty);
            if (upperScore != null && !upperScore.isEmpty()) upperScore.removeIf(CvssModification::areMetricsEmpty);
            if (upperMetric != null && !upperMetric.isEmpty()) upperMetric.removeIf(CvssModification::areMetricsEmpty);
            if (reset != null && reset.isEmpty()) reset = null;
            if (overwrite != null && overwrite.isEmpty()) overwrite = null;
            if (lowerScore != null && lowerScore.isEmpty()) lowerScore = null;
            if (lowerMetric != null && lowerMetric.isEmpty()) lowerMetric = null;
            if (upperScore != null && upperScore.isEmpty()) upperScore = null;
            if (upperMetric != null && upperMetric.isEmpty()) upperMetric = null;
        }

        public <T extends CvssVector> List<T> createVectors(BiFunction<String, CvssSource, T> constructor, Class<T> clazz) {
            final List<T> vectors = new ArrayList<>();
            vectors.addAll(createVectorsFromModifications(overwrite, constructor, clazz, KnownCvssEntities.ASSESSMENT_ALL));
            vectors.addAll(createVectorsFromModifications(lowerScore, constructor, clazz, KnownCvssEntities.ASSESSMENT_LOWER));
            vectors.addAll(createVectorsFromModifications(lowerMetric, constructor, clazz, KnownCvssEntities.ASSESSMENT_LOWER_METRIC));
            vectors.addAll(createVectorsFromModifications(upperScore, constructor, clazz, KnownCvssEntities.ASSESSMENT_HIGHER));
            vectors.addAll(createVectorsFromModifications(upperMetric, constructor, clazz, KnownCvssEntities.ASSESSMENT_HIGHER_METRIC));
            return vectors;
        }

        private <T extends CvssVector> List<T> createVectorsFromModifications(List<CvssModification> modifications, BiFunction<String, CvssSource, T> constructor, Class<T> clazz, CvssSource.CvssEntity type) {
            if (modifications == null || modifications.isEmpty()) {
                return Collections.emptyList();
            }
            return modifications.stream()
                    .map(mod -> createVector(mod.getMetrics(), constructor, clazz, type))
                    .collect(Collectors.toList());
        }

        private <T extends CvssVector> T createVector(String vector, BiFunction<String, CvssSource, T> constructor, Class<T> clazz, CvssSource.CvssEntity type) {
            return constructor.apply(vector, new CvssSource(KnownCvssEntities.ASSESSMENT, type, clazz));
        }

        public void append(CvssModificationGroup ref) {
            if (ref == null) {
                return;
            }

            if (ref.reset != null) {
                if (reset == null) reset = new ArrayList<>();
                reset.addAll(ref.reset);
            }

            if (ref.overwrite != null) {
                if (overwrite == null) overwrite = new ArrayList<>();
                overwrite.addAll(ref.overwrite);
            }

            if (ref.lowerScore != null) {
                if (lowerScore == null) lowerScore = new ArrayList<>();
                lowerScore.addAll(ref.lowerScore);
            }

            if (ref.lowerMetric != null) {
                if (lowerMetric == null) lowerMetric = new ArrayList<>();
                lowerMetric.addAll(ref.lowerMetric);
            }

            if (ref.upperScore != null) {
                if (upperScore == null) upperScore = new ArrayList<>();
                upperScore.addAll(ref.upperScore);
            }

            if (ref.upperMetric != null) {
                if (upperMetric == null) upperMetric = new ArrayList<>();
                upperMetric.addAll(ref.upperMetric);
            }

            this.clearEmpty();
        }

        public void appendRationale(String rationale) {
            if (overwrite != null) {
                overwrite.forEach(m -> m.appendRationale(rationale));
            }
            if (lowerScore != null) {
                lowerScore.forEach(m -> m.appendRationale(rationale));
            }
            if (lowerMetric != null) {
                lowerMetric.forEach(m -> m.appendRationale(rationale));
            }
            if (upperScore != null) {
                upperScore.forEach(m -> m.appendRationale(rationale));
            }
            if (upperMetric != null) {
                upperMetric.forEach(m -> m.appendRationale(rationale));
            }
        }
    }

    @Data
    @AllArgsConstructor
    public static class CvssModification {
        private String metrics;
        private String rationale;

        public void aggregateContributions(Collection<CvssModification> referenceModifications, Set<String> resetMetrics, Supplier<CvssVector> constructor) {
            boolean noReferenceModifications = referenceModifications == null || referenceModifications.isEmpty();

            if (noReferenceModifications && resetMetrics.isEmpty()) {
                return;
            }

            final CvssVector vector = constructor.get();
            if (!resetMetrics.contains("all")) {
                vector.applyVector(metrics);
            } else {
                rationale = null;
            }
            if (!resetMetrics.isEmpty()) {
                for (String resetMetric : resetMetrics) {
                    vector.applyVectorArgument(resetMetric, "ND");
                    vector.applyVectorArgument(resetMetric, "X");
                }
            }

            if (noReferenceModifications) {
                metrics = vector.toString();
                return;
            }

            for (CvssModification reference : referenceModifications) {
                vector.applyVector(reference.getMetrics());
                this.appendRationale(reference.getRationale());
            }

            metrics = vector.toString();

            if (StringUtils.isEmpty(rationale)) {
                rationale = "Aggregated CVSS modifications from multiple sources";
            }
        }

        public void appendRationale(String rationale) {
            final boolean refHasRationale = StringUtils.hasText(rationale);
            final boolean thisHasRationale = StringUtils.hasText(this.rationale);
            if (refHasRationale && thisHasRationale) {
                this.rationale = this.rationale + "\n" + rationale;
            } else if (refHasRationale) {
                this.rationale = rationale;
            }
        }

        public boolean areMetricsEmpty() {
            return metrics == null || metrics.isEmpty();
        }

        public static CvssModification empty() {
            return new CvssModification("", null);
        }

        public static CvssModification fromMap(Object cvssModification) {
            if (cvssModification instanceof Map) {
                final Map<String, Object> cvssModificationMap = (Map<String, Object>) cvssModification;
                if (!cvssModificationMap.containsKey("metrics")) {
                    log.warn("Invalid CVSS modification, missing metrics: {}", cvssModification);
                }
                if (!cvssModificationMap.containsKey("rationale")) {
                    log.warn("Invalid CVSS modification, missing rationale: {}", cvssModification);
                }
                return new CvssModification((String) cvssModificationMap.getOrDefault("metrics", ""), (String) cvssModificationMap.getOrDefault("rationale", "No rationale provided"));
            }
            log.warn("Invalid CVSS modification type [{}], skipping", cvssModification);
            return null;
        }

        public static List<CvssModification> fromList(Object cvssModification) {
            if (cvssModification instanceof List) {
                final List<CvssModification> modifications = new ArrayList<>();
                for (Object modification : (List) cvssModification) {
                    modifications.add(fromMap(modification));
                }
                modifications.removeIf(Objects::isNull);
                return modifications;
            }
            log.warn("Invalid CVSS modification list type [{}], skipping", cvssModification);
            return Collections.emptyList();
        }
    }

    @Data
    @AllArgsConstructor
    public static class ReviewedAdvisory {
        private String id;
        private String rationale;

        public static ReviewedAdvisory fromMap(Object reviewedAdvisory) {
            if (reviewedAdvisory instanceof Map) {
                final Map<String, Object> reviewedAdvisoryMap = (Map<String, Object>) reviewedAdvisory;
                if (!reviewedAdvisoryMap.containsKey("id")) {
                    log.warn("Invalid reviewed advisory, missing id: {}", reviewedAdvisory);
                }
                if (!reviewedAdvisoryMap.containsKey("rationale")) {
                    log.warn("Invalid reviewed advisory, missing rationale: {}", reviewedAdvisory);
                }
                return new ReviewedAdvisory((String) reviewedAdvisoryMap.getOrDefault("id", ""), (String) reviewedAdvisoryMap.getOrDefault("rationale", "No rationale provided"));
            }
            log.warn("Invalid reviewed advisory type [{}], skipping", reviewedAdvisory);
            return null;
        }

        public String toJson() {
            return GSON.toJson(this);
        }

        public static String toJson(Collection<ReviewedAdvisory> reviewedAdvisories) {
            return GSON.toJson(reviewedAdvisories);
        }

        public static ReviewedAdvisory fromJson(String json) {
            return GSON.fromJson(json, ReviewedAdvisory.class);
        }

        public static List<ReviewedAdvisory> fromJsonArray(String json) {
            return GSON.fromJson(json, new TypeToken<List<ReviewedAdvisory>>() {
            }.getType());
        }

        // SECTION: query

        public static ReviewedAdvisory findReviewedEntry(@NonNull String id, List<ReviewedAdvisory> advisories) {
            return advisories.stream().filter(a -> id.equals(a.getId())).findFirst().orElse(null);
        }
    }

    @Data
    public static class MatchReason {
        final MatchType type;
        final String value;

        public MatchReason(MatchType type, String value) {
            this.type = type == null ? MatchType.VULNERABILITY : type;
            this.value = value == null ? "none" : value;
        }

        public static MatchReason fromMap(Map<String, Object> input) {
            if (input == null) {
                return null;
            }
            final MatchType type = MatchType.valueOf((String) input.get("type"));
            final String value = (String) input.get("value");
            return new MatchReason(type, value);
        }

        public String toDisplayString() {
            final String name = type.name().replace("_", " ").toLowerCase();
            if (StringUtils.hasText(value)) {
                return String.format(Locale.GERMANY, "%s: %s", name, value);
            } else {
                return name;
            }
        }
    }

    @Getter
    @AllArgsConstructor
    public enum MatchType {
        VULNERABILITY,
        CPE,
        CWE,
        CONDITION,
        INVENTORY_SCOPE,
    }

    // SECTION: templates

    public static AeaaVulnerabilityAssessmentEvent VOID() {
        return AeaaVulnerabilityAssessmentEvent.builder()
                .status(VulnerabilityMetaData.STATUS_VALUE_VOID)
                .rationale("The component affected by this vulnerability is not included in the current asset version.")
                .date(AeaaTimeUtils.utcNow())
                .build();
    }

    public static AeaaVulnerabilityAssessmentEvent INSIGNIFICANT(double insignificantThreshold) {
        return AeaaVulnerabilityAssessmentEvent.builder()
                .status(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT)
                .rationale(String.format(Locale.GERMANY, "Vulnerability severity score is below insignificant threshold of %s.", insignificantThreshold))
                .date(AeaaTimeUtils.utcNow())
                .build();
    }

    public static AeaaVulnerabilityAssessmentEvent IN_REVIEW() {
        return AeaaVulnerabilityAssessmentEvent.builder()
                .status(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW)
                .rationale("The vulnerability has automatically been marked as in review.")
                .date(AeaaTimeUtils.utcNow())
                .build();
    }
}
