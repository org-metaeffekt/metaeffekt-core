/*
 * Copyright 2009-2026 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment;

import com.google.gson.reflect.TypeToken;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.tuple.Pair;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaTimeUtils;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment.AeaaVulnerabilityAssessmentEvent.CvssModificationElement.AeaaModificationType;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment.AeaaVulnerabilityAssessmentOperations.AeaaSchemaVersion;
import org.metaeffekt.core.security.cvss.CvssSource;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.metaeffekt.core.security.cvss.KnownCvssEntities;
import org.metaeffekt.core.security.cvss.v2.Cvss2;
import org.metaeffekt.core.security.cvss.v3.Cvss3P0;
import org.metaeffekt.core.security.cvss.v3.Cvss3P1;
import org.metaeffekt.core.security.cvss.v4P0.Cvss4P0;
import org.springframework.lang.NonNull;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment.AeaaVulnerabilityAssessmentOperations.GSON;
import static org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment.AeaaVulnerabilityAssessmentOperations.parseIfPresent;

@Data
@Accessors(chain = true)
@AllArgsConstructor
@NoArgsConstructor
@Slf4j
public class AeaaVulnerabilityAssessmentEvent implements Comparable<AeaaVulnerabilityAssessmentEvent> {

    private String schemaVersion = AeaaSchemaVersion.VERSION_LATEST.toString();
    private String uid = UUID.randomUUID().toString();

    /**
     * Indicates whether this event was automatically appended for display purposes and should
     * be treated differently when evaluating the {@link #isDiscardOnSubsequentEvents()} flag
     * in the {@link AeaaEffectiveVulnerabilityAssessment#fromEvents(List)} /
     * {@link AeaaEffectiveVulnerabilityAssessment#filterDiscardedEvents(List)} methods.
     * <p>
     * When set to {@code true}, this event will not trigger
     * the {@link #isDiscardOnSubsequentEvents()} behavior of earlier events, even if this event
     * appears before them in the list. This is currently only used for the automatically appended
     * assessments {@link AeaaVulnerabilityAssessmentEvent#IN_REVIEW()} and
     * {@link AeaaVulnerabilityAssessmentEvent#INSIGNIFICANT(double)}.
     * <p>
     * <b>Behavior Details:</b>
     * <ul>
     *   <li>If an event has {@link #isDiscardOnSubsequentEvents()} set to {@code true}, it will
     *       discard itself and all subsequent events <b>only if</b> there exists at least one
     *       event before it that is <b>not</b> marked as {@code isAutoAppendedForDisplay}.</li>
     *   <li>If all events before the {@code discardOnSubsequentEvents} event are marked as
     *       {@code isAutoAppendedForDisplay}, the discard behavior is <b>not</b> triggered.</li>
     * </ul>
     * <p>
     * <b>Examples:</b>
     * <ol>
     *   <li>
     *     Discard is triggered because a non-auto-appended event exists before.
     *     <pre>
     *     Event 1: No flags set
     *     Event 2: isAutoAppendedForDisplay = true
     *     Event 3: discardOnSubsequentEvents = true
     *     Result: Event 3 is discarded because Event 1 is not auto-appended.
     *     </pre>
     *   </li>
     *   <li>
     *     Discard is <b>not</b> triggered because only auto-appended events exist before.
     *     <pre>
     *     Event 1: isAutoAppendedForDisplay = true
     *     Event 2: isAutoAppendedForDisplay = true
     *     Event 3: discardOnSubsequentEvents = true
     *     Result: No events are discarded because all prior events are auto-appended.
     *     </pre>
     *   </li>
     * </ol>
     */
    private boolean isAutoAppendedForDisplay = false;
    /**
     * If there are later events, this event and all prior ones are discarded.
     * If this is the latest event, it remains active.
     */
    private boolean discardOnSubsequentEvents = false;
    /**
     * Essentially a <code>reset</code> flag, allowing to restart the assessment process.
     * When this flag is set, all prior assessment events are discarded,
     * and the current event becomes the new baseline for calculating the effective result.<br>
     * This leads to only the latest <code>discardPriorEvents</code> entry to be the effective starting point.
     */
    private boolean discardPriorEvents = false;
    /**
     * Differs from the {@link #discardPriorEvents} parameter such that it only ignores the assessments between this one
     * and the latest baseline assessment.
     * This is to allow re-starting an assessment as if none were made yet that build on the baseline assessment.
     */
    private boolean discardEventsUntilBaseline = false;

    private boolean active = true;

    private AeaaVulnerabilityAssessment.Scope scope = AeaaVulnerabilityAssessment.Scope.VULNERABILITY;

    private String status;
    private String rationale;
    private String risk;
    private String measures;
    private String author;
    private String authorId;
    private Long date;
    private Double score;
    private int priority = 0;

    private List<AeaaCvssModificationsContainer> cvss = new ArrayList<>();

    private List<ReviewedAdvisory> reviewedAdvisories = new ArrayList<>();

    private MatchReason matchReason;

    // SECTION: data access

    public AeaaVulnerabilityAssessmentEvent setSchemaVersion(String version) {
        this.schemaVersion = version;
        return this;
    }

    public AeaaVulnerabilityAssessmentEvent setSchemaVersion(AeaaSchemaVersion version) {
        return this.setSchemaVersion(version.toString());
    }

    // SECTION: query

    public AeaaVulnerabilityAssessmentEvent deriveMatched(MatchReason matchReason) {
        final AeaaVulnerabilityAssessmentEvent matched = fromJson(toJson());
        matched.matchReason = matchReason;
        return matched;
    }

    public void addReviewedAdvisory(List<AeaaVulnerabilityAssessmentEvent> refEvents, String id) {
        final boolean selfContains = reviewedAdvisories.stream().anyMatch(a -> id.equals(a.getId()));
        if (selfContains) {
            return;
        }

        final boolean anyRefContains = refEvents.stream().anyMatch(e -> e.reviewedAdvisories.stream().anyMatch(a -> id.equals(a.getId())));
        if (anyRefContains) {
            return;
        }

        reviewedAdvisories.add(new ReviewedAdvisory(id, "No rationale provided"));
    }

    // SECTION: serialize

    public String toJson() {
        return GSON.toJson(this);
    }

    public static String toJson(Collection<AeaaVulnerabilityAssessmentEvent> events) {
        return GSON.toJson(events);
    }

    public JSONObject toJsonObject() {
        return new JSONObject(GSON.toJson(this));
    }

    public static JSONArray toJsonArray(Collection<AeaaVulnerabilityAssessmentEvent> events) {
        return new JSONArray(GSON.toJson(events));
    }

    @Override
    public String toString() {
        return toJson();
    }

    // SECTION: deserialize

    public static AeaaVulnerabilityAssessmentEvent fromJson(String json) {
        return fromJson(new JSONObject(json));
    }

    public static List<AeaaVulnerabilityAssessmentEvent> fromJsonArray(String json) {
        return fromJsonArray(new JSONArray(json));
    }

    public static List<AeaaVulnerabilityAssessmentEvent> fromJsonArray(JSONArray json) {
        final List<AeaaVulnerabilityAssessmentEvent> events = new ArrayList<>();
        for (int i = 0; i < json.length(); i++) {
            events.add(fromJson(json.getJSONObject(i)));
        }
        return events;
    }

    public static AeaaVulnerabilityAssessment.AeaaCreationContext creationContextFromJson(JSONObject json) {
        final AeaaVulnerabilityAssessment.AeaaCreationContext outerContext = creationContextFromJsonSingle(json);
        if (outerContext != null) return outerContext;

        final JSONArray events = json.optJSONArray("events");
        if (events != null) {
            for (int i = 0; i < events.length(); i++) {
                final JSONObject event = events.optJSONObject(i);
                final AeaaVulnerabilityAssessment.AeaaCreationContext eventContext = creationContextFromJsonSingle(event);
                if (eventContext != null) return eventContext;
            }
        }

        return null;
    }

    private static AeaaVulnerabilityAssessment.AeaaCreationContext creationContextFromJsonSingle(JSONObject json) {
        final String createdForContext = json.optString("createdForContext");
        final String createdForVulnerability = json.optString("createdForVulnerability");

        if (StringUtils.hasText(createdForContext)) {
            final AeaaVulnerabilityAssessment.AeaaCreationContext creationContext = new AeaaVulnerabilityAssessment.AeaaCreationContext();
            creationContext.setAssetId(createdForContext);
            creationContext.putCustom("createdForVulnerability", createdForVulnerability);
            return creationContext;
        }
        return null;
    }

    public static AeaaVulnerabilityAssessmentEvent fromJson(JSONObject json) {
        final AeaaVulnerabilityAssessmentEvent event = new AeaaVulnerabilityAssessmentEvent();

        final Map<String, Object> asMap = json.toMap();
        final AeaaSchemaVersion inputSchemaVersion = AeaaSchemaVersion.parse(asMap, AeaaSchemaVersion.VERSION_2_0);

        event.uid = json.optString("uid", event.getUid());

        event.active = json.optBoolean("active", true);

        event.discardOnSubsequentEvents = json.optBoolean("discardOnSubsequentEvents", false);
        event.discardPriorEvents = json.optBoolean("discardPriorEvents", false);
        event.discardEventsUntilBaseline = json.optBoolean("discardEventsUntilBaseline", false);

        if (json.optString("scope", null) != null) {
            event.scope = AeaaVulnerabilityAssessment.Scope.fromString(json.getString("scope"));
        }

        event.status = json.optString("status", null);
        event.rationale = json.optString("rationale", null);
        event.risk = json.optString("risk", null);
        event.measures = json.optString("measures", null);
        event.author = json.optString("author", null);
        event.authorId = json.optString("authorId", null);
        if (json.has("date")) event.date = AeaaTimeUtils.tryParse(json.get("date")).getTime();
        event.score = json.has("score") ? Double.parseDouble(String.valueOf(json.get("score"))) : null;
        event.priority = json.optInt("priority", 0);

        if (inputSchemaVersion.between(AeaaSchemaVersion.VERSION_2_0, AeaaSchemaVersion.VERSION_2_1)) {
            if (asMap.get("cvss") != null) {
                if (asMap.get("cvss") instanceof List) {
                    final List<Object> cvss = (List<Object>) asMap.get("cvss");

                    for (Object entry : cvss) {
                        if (entry instanceof Map) {
                            final Map<String, Object> typedEntry = (Map<String, Object>) entry;

                            if (inputSchemaVersion.is(AeaaSchemaVersion.VERSION_2_0)) {
                                event.getCvss().addAll(AeaaCvssModificationsContainer.fromV2_0_Map(typedEntry));
                            } else if (inputSchemaVersion.is(AeaaSchemaVersion.VERSION_2_1)) {
                                event.getCvss().add(AeaaCvssModificationsContainer.fromV2_1_Map(typedEntry));
                            }
                        }
                    }

                } else {
                    log.error("Invalid CVSS modification group type, expected list: {}", asMap.get("cvss"));
                }
            } else if (inputSchemaVersion.is(AeaaSchemaVersion.VERSION_2_0)) {
                event.getCvss().addAll(AeaaCvssModificationsContainer.fromV2_0_Map(asMap));
            }
        }

        final JSONArray reviewedAdvisories = json.optJSONArray("reviewedAdvisories");
        if (reviewedAdvisories != null) {
            for (int i = 0; i < reviewedAdvisories.length(); i++) {
                final JSONObject reviewedAdvisory = reviewedAdvisories.optJSONObject(i);
                if (reviewedAdvisory == null) continue;
                event.reviewedAdvisories.add(ReviewedAdvisory.fromJson(reviewedAdvisory.toString()));
            }
            event.reviewedAdvisories.removeIf(Objects::isNull);
        }

        event.matchReason = parseIfPresent(asMap, "matchReason", Map.class, null, MatchReason::fromMap);

        // validation
        if (event.date == null || event.date == 0) {
            log.warn("Missing date in assessment event, setting to current date");
            event.setDate(AeaaTimeUtils.utcNow());
        }

        return event;
    }

    public static AeaaVulnerabilityAssessmentEvent fromMap(Map<String, Object> event) {
        final AeaaSchemaVersion schemaVersion = AeaaSchemaVersion.parse(event);
        if (event == null) return null;
        if (schemaVersion.getMajor() == 1) {
            log.warn("Please include a schema-version in the input for the assessment event, even if you provide the event through a KeywordSet to ensure proper parsing of the data model.");
        }

        return fromMap(schemaVersion, event);
    }

    public static AeaaVulnerabilityAssessmentEvent fromMap(AeaaSchemaVersion inputSchemaVersion, Map<String, Object> root) {
        final AeaaVulnerabilityAssessmentEvent event = new AeaaVulnerabilityAssessmentEvent();

        event.setSchemaVersion(AeaaSchemaVersion.VERSION_LATEST);
        event.uid = (String) root.getOrDefault("uid", event.getUid());

        event.active = (Boolean) root.getOrDefault("active", true);

        event.discardOnSubsequentEvents = (Boolean) root.getOrDefault("discard on subsequent events", false);
        event.discardPriorEvents = (Boolean) root.getOrDefault("discard prior events", false);
        event.discardEventsUntilBaseline = (Boolean) root.getOrDefault("reset to baseline", false);

        event.status = (String) root.get("status");
        event.rationale = (String) root.get("rationale");
        event.risk = (String) root.get("risk");
        event.measures = (String) root.get("measures");
        event.author = (String) root.get("author");
        event.authorId = (String) root.get("authorId");
        event.date = parseIfPresent(root, "date", String.class, 0L, d -> AeaaTimeUtils.tryParse(d).getTime());
        event.score = root.containsKey("score") ? Double.parseDouble(root.get("score").toString()) : null;
        event.priority = (Integer) root.getOrDefault("priority", 0);

        if (inputSchemaVersion.between(AeaaSchemaVersion.VERSION_2_0, AeaaSchemaVersion.VERSION_2_1)) {
            if (root.get("cvss") != null) {
                if (root.get("cvss") instanceof List) {
                    final List<Object> cvss = (List<Object>) root.get("cvss");

                    for (Object entry : cvss) {
                        if (entry instanceof Map) {
                            final Map<String, Object> typedEntry = (Map<String, Object>) entry;

                            if (inputSchemaVersion.is(AeaaSchemaVersion.VERSION_2_0)) {
                                event.getCvss().addAll(AeaaCvssModificationsContainer.fromV2_0_Map(typedEntry));
                            } else if (inputSchemaVersion.is(AeaaSchemaVersion.VERSION_2_1)) {
                                event.getCvss().add(AeaaCvssModificationsContainer.fromV2_1_Map(typedEntry));
                            }
                        }
                    }

                } else {
                    log.error("Invalid CVSS modification group type, expected list: {}", root.get("cvss"));
                }
            } else if (inputSchemaVersion.is(AeaaSchemaVersion.VERSION_2_0)) {
                event.getCvss().addAll(AeaaCvssModificationsContainer.fromV2_0_Map(root));
            }
        }

        final Object reviewedAdvisories = root.get("advisory reviewed");
        if (reviewedAdvisories instanceof List) {
            for (Object reviewedAdvisory : (List) reviewedAdvisories) {
                event.reviewedAdvisories.add(ReviewedAdvisory.fromMap(reviewedAdvisory));
            }
            event.reviewedAdvisories.removeIf(Objects::isNull);
        }


        event.matchReason = parseIfPresent(root, "matchReason", Map.class, null, MatchReason::fromMap);

        // validation
        if (event.date == null || event.date == 0) {
            log.warn("Missing date in assessment event, setting to current date");
            event.setDate(AeaaTimeUtils.utcNow());
        }

        return event;
    }

    // SECTION: sorting

    private final static List<String> VULNERABILITY_STATUS_ORDER_DESCENDING = Arrays.asList(
            VulnerabilityMetaData.STATUS_VALUE_APPLICABLE,
            VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW,
            VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE,
            VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT,
            VulnerabilityMetaData.STATUS_VALUE_VOID);

    private final static int COMP_MOVE_UP = -1;
    private final static int COMP_MOVE_DOWN = 1;

    /**
     * <p>Since events are collected in potentially any order, they need to have an intrinsic ordering criteria that always allows
     * ordering them for evaluation.
     * The following rules are evaluated step by step, and the first matching one is the criteria that specifies the order
     * between the two events.</p>
     * <ol>
     * <li>The entry with the higher <code>priority</code> is moved upwards.</li>
     * <li>The entry with the <code>inventory</code> scope is moved downwards.</li>
     * <li>The inactive entry is moved downwards.</li>
     * <li>The entry with a date specified at all is moved upwards.</li>
     * <li>The entry with the later <code>date</code> is moved upwards.</li>
     * </ol>
     * <p>Since <code>date</code> is mandatory, this is usually the end of the comparison.
     * To ensure a consistent order, other properties are still evaluated:</p>
     * <ol>
     * <li>The entry with a rationale, measures, or risk is moved upwards.</li>
     * <li>The entry with a status is moved upwards.</li>
     * <li>The entry with the more severe status is moved upwards.</li>
     * </ol>
     *
     * @param o the object to be compared.
     * @return a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.
     */
    @Override
    public int compareTo(AeaaVulnerabilityAssessmentEvent o) {
        if (o == null) {
            return 1;
        }

        // higher priority first
        if (this.priority != o.priority) {
            return Integer.compare(o.priority, this.priority);
        }

        // inventory scope last
        if (this.scope != o.scope) {
            return this.scope == AeaaVulnerabilityAssessment.Scope.INVENTORY ? COMP_MOVE_DOWN : COMP_MOVE_UP;
        }

        // inactive last
        if (this.active != o.active) {
            return this.active ? COMP_MOVE_UP : COMP_MOVE_DOWN;
        }

        // if one of them does not have a date, it is moved downwards
        if (this.date == null || o.date == null) {
            return this.date == null ? COMP_MOVE_DOWN : COMP_MOVE_UP;
        }
        // later date first
        if (!this.date.equals(o.date)) {
            return o.date.compareTo(this.date);
        }

        // rationale, measures, or risk first
        if (this.rationale != null || this.measures != null || this.risk != null) {
            return COMP_MOVE_UP;
        }
        if (o.rationale != null || o.measures != null || o.risk != null) {
            return COMP_MOVE_DOWN;
        }

        // status first
        if (this.status != null && o.status == null) {
            return COMP_MOVE_UP;
        }
        if (o.status != null && this.status == null) {
            return COMP_MOVE_DOWN;
        }

        // more severe status first
        final int thisStatusIndex = VULNERABILITY_STATUS_ORDER_DESCENDING.indexOf(this.status);
        final int oStatusIndex = VULNERABILITY_STATUS_ORDER_DESCENDING.indexOf(o.status);
        return Integer.compare(thisStatusIndex, oStatusIndex);
    }

    @Data
    public static class AeaaCvssModificationsContainer {
        private String rationale;
        private List<CvssModificationElement> modifications = new ArrayList<>();

        public AeaaCvssModificationsContainer shallowClone() {
            return new AeaaCvssModificationsContainer().setRationale(this.rationale).setModifications(new ArrayList<>(this.modifications));
        }

        public CvssModificationElement newModification() {
            final CvssModificationElement mod = new CvssModificationElement();
            this.modifications.add(mod);
            return mod;
        }

        public AeaaCvssModificationsContainer addTo(Collection<AeaaCvssModificationsContainer> collection) {
            collection.add(this);
            return this;
        }

        public List<CvssVector> createVectors() {
            final List<CvssVector> vectors = new ArrayList<>();
            if (this.modifications == null || this.modifications.isEmpty()) {
                return vectors;
            }

            for (CvssModificationElement mod : modifications) {
                final CvssVector vector = createCvssVector(mod.getVersion());
                vector.applyVector(mod.getMetrics());

                final CvssSource.CvssEntity typeEntity;
                try {
                    final AeaaModificationType modType = AeaaModificationType.fromString(mod.getType());
                    switch (modType) {
                        case OVERWRITE:
                            typeEntity = KnownCvssEntities.ASSESSMENT_ALL;
                            break;
                        case LOWER_SCORE:
                            typeEntity = KnownCvssEntities.ASSESSMENT_LOWER;
                            break;
                        case LOWER_METRIC:
                            typeEntity = KnownCvssEntities.ASSESSMENT_LOWER_METRIC;
                            break;
                        case UPPER_SCORE:
                            typeEntity = KnownCvssEntities.ASSESSMENT_HIGHER;
                            break;
                        case UPPER_METRIC:
                            typeEntity = KnownCvssEntities.ASSESSMENT_HIGHER_METRIC;
                            break;
                        case RESET:
                            continue;
                        default:
                            log.warn("Unknown CVSS modification type [{}] encountered. Skipping.", mod.getType());
                            continue;
                    }
                } catch (IllegalArgumentException e) {
                    log.warn("Invalid CVSS modification type [{}]. Skipping.", mod.getType());
                    continue;
                }

                CvssSource source = new CvssSource(KnownCvssEntities.ASSESSMENT, typeEntity, vector.getClass());
                vectors.add(vector.deriveAddSource(source));
            }

            return vectors;
        }

        public static List<AeaaCvssModificationsContainer> filterForVersionAndType(List<AeaaCvssModificationsContainer> inputContainers, String version, String type) {
            return createNewFilteredView(inputContainers, element -> version.equalsIgnoreCase(element.getVersion()) && type.equalsIgnoreCase(element.getType()));
        }

        public static List<AeaaCvssModificationsContainer> createNewFilteredView(List<AeaaCvssModificationsContainer> inputContainers, Predicate<CvssModificationElement> predicate) {
            final List<AeaaCvssModificationsContainer> filtered = new ArrayList<>();
            for (AeaaCvssModificationsContainer inputContainer : inputContainers) {
                final AeaaCvssModificationsContainer outputContainer = inputContainer.shallowClone();
                outputContainer.getModifications().removeIf(element -> !predicate.test(element));
                if (!outputContainer.getModifications().isEmpty()) filtered.add(outputContainer);
            }
            return filtered;
        }

        public static List<AeaaCvssModificationsContainer> createNewWithReducedToOnePerVersionAndType(List<AeaaCvssModificationsContainer> cvss) {
            final List<AeaaCvssModificationsContainer> result = new ArrayList<>();

            // 1. Group all modification elements and their container rationales by version.
            final Map<String, List<Pair<CvssModificationElement, String>>> groupedByVersion = new HashMap<>();
            for (AeaaCvssModificationsContainer container : cvss) {
                String rationale = container.getRationale();
                if (container.getModifications() == null) continue;
                for (CvssModificationElement mod : container.getModifications()) {
                    groupedByVersion.computeIfAbsent(mod.getVersion(), k -> new ArrayList<>())
                            .add(Pair.of(mod, rationale));
                }
            }

            // 2. Process each version group.
            for (Map.Entry<String, List<Pair<CvssModificationElement, String>>> versionEntry : groupedByVersion.entrySet()) {
                final String version = versionEntry.getKey();
                final List<Pair<CvssModificationElement, String>> allModificationsForVersion = versionEntry.getValue();

                // 2a. Find all 'reset' modifications for this version and compute the resetMetrics set.
                final Set<String> resetMetrics = new HashSet<>();
                allModificationsForVersion.stream()
                        .map(Pair::getLeft)
                        .filter(e -> AeaaModificationType.RESET.getSchemaName().equalsIgnoreCase(e.getType()))
                        .map(CvssModificationElement::getMetrics)
                        .filter(StringUtils::hasText)
                        .forEach(metrics -> {
                            if ("all".equalsIgnoreCase(metrics)) {
                                resetMetrics.clear();
                                resetMetrics.add("all");
                            } else if (!resetMetrics.contains("all")) {
                                resetMetrics.addAll(Arrays.asList(metrics.split("[/,] *")));
                            }
                        });

                // 2b. Group the remaining modifications by type.
                final Map<String, List<Pair<CvssModificationElement, String>>> groupedByType = allModificationsForVersion.stream()
                        .filter(t -> !AeaaModificationType.RESET.getSchemaName().equalsIgnoreCase(t.getLeft().getType()))
                        .collect(Collectors.groupingBy(t -> t.getLeft().getType()));

                // 2c. For each type, aggregate the modifications.
                for (Map.Entry<String, List<Pair<CvssModificationElement, String>>> typeEntry : groupedByType.entrySet()) {
                    final String type = typeEntry.getKey();
                    final List<Pair<CvssModificationElement, String>> modificationsForType = typeEntry.getValue();

                    // Create a base vector for the version.
                    final CvssVector aggregatedVector = createCvssVector(version);
                    if (aggregatedVector == null) {
                        log.warn("Cannot create CVSS vector for unsupported version [{}]. Skipping aggregation.", version);
                        continue;
                    }

                    // Apply specific metric resets. "all" implies starting with a fresh vector, which we already do.
                    resetMetrics.stream().filter(m -> !"all".equals(m)).forEach(metric -> {
                        aggregatedVector.applyVectorArgument(metric, "ND");
                        aggregatedVector.applyVectorArgument(metric, "X");
                    });

                    // Apply all modifications for the current type.
                    for (Pair<CvssModificationElement, String> modPair : modificationsForType) {
                        aggregatedVector.applyVector(modPair.getLeft().getMetrics());
                    }

                    // Aggregate rationales from all containers that contributed to this type.
                    final String combinedRationale = modificationsForType.stream()
                            .map(Pair::getRight)
                            .filter(StringUtils::hasText)
                            .distinct()
                            .collect(Collectors.joining("\n"));

                    // Create the new, reduced container and element.
                    final AeaaCvssModificationsContainer newContainer = new AeaaCvssModificationsContainer();
                    newContainer.setRationale(combinedRationale);

                    final CvssModificationElement newElement = newContainer.newModification();
                    newElement.setVersion(version);
                    newElement.setType(type);
                    newElement.setMetrics(aggregatedVector.toString());

                    result.add(newContainer);
                }
            }

            return result;
        }

        private static CvssVector createCvssVector(String version) {
            if (version == null) return null;
            switch (version) {
                case "2.0":
                    return new Cvss2();
                case "3.0":
                    return new Cvss3P0();
                case "3.1":
                    return new Cvss3P1();
                case "4.0":
                    return new Cvss4P0();
                default:
                    throw new IllegalStateException("Unexpected value for CVSS version when creating vector: " + version);
            }
        }

        public static AeaaCvssModificationsContainer fromV2_1_Map(Map<String, Object> map) {
            final AeaaCvssModificationsContainer container = new AeaaCvssModificationsContainer();

            container.rationale = parseIfPresent(map, "rationale", String.class, null, Function.identity());

            final Object modifications = map.get("modifications");
            if (modifications instanceof List) {
                for (Object modification : ((List<Object>) modifications)) {
                    if (!(modification instanceof Map)) continue;
                    final Map<String, Object> typedModification = (Map<String, Object>) modification;

                    final CvssModificationElement mod = container.newModification();
                    mod.version = parseIfPresent(typedModification, "version", String.class, null, Function.identity());
                    mod.type = parseIfPresent(typedModification, "type", String.class, null, s -> {
                        try {
                            return AeaaModificationType.fromString(s).getSchemaName();
                        } catch (IllegalArgumentException e) {
                            log.warn("Invalid CVSS modification type [{}] encountered during parsing. Keeping original value.", s);
                            return s;
                        }
                    });
                    mod.metrics = parseIfPresent(typedModification, "metrics", String.class, null, Function.identity());
                }
            }

            return container;
        }

        public static List<AeaaCvssModificationsContainer> fromV2_0_Map(Map<String, Object> map) {
            final List<AeaaCvssModificationsContainer> modifications = new ArrayList<>();
            if (map == null || map.isEmpty()) return modifications;

            for (String version : Arrays.asList("2.0", "3.0", "3.1", "4.0")) {
                final Object versionEntry = map.getOrDefault("v" + version,
                        map.getOrDefault(version, map.getOrDefault("v" + version, map.getOrDefault("cvssV" + version.replace(".", "P"), map.get("cvssV" + version.replace(".0", ""))))));
                if (!(versionEntry instanceof Map)) continue;

                for (Map.Entry<String, Object> modTypeEntry : ((Map<String, Object>) versionEntry).entrySet()) {
                    final String modType = modTypeEntry.getKey();
                    final Object metricList = modTypeEntry.getValue();
                    if (!(metricList instanceof List)) continue;

                    for (Object metricEntry : ((List<?>) metricList)) {
                        if (!(metricEntry instanceof Map)) continue;

                        final Map<String, Object> typedMetricEntry = (Map<String, Object>) metricEntry;
                        final Object metrics = typedMetricEntry.get("metrics");
                        final Object rationale = typedMetricEntry.get("rationale");

                        final AeaaCvssModificationsContainer container = new AeaaCvssModificationsContainer();
                        container.rationale = rationale != null ? String.valueOf(rationale) : "";
                        modifications.add(container);

                        final CvssModificationElement modification = container.newModification();
                        modification.metrics = metrics != null ? String.valueOf(metrics) : "";
                        modification.version = version;
                        modification.type = AeaaModificationType.fromString(modType).schemaName;
                    }
                }
            }

            return modifications;
        }
    }

    // use lombok @Getter I dare you
    public static class CvssModificationElement {
        private String version;
        private String type;
        private String metrics;

        public String getVersion() {
            return version;
        }

        public CvssModificationElement setVersion(String version) {
            this.version = version;
            return this;
        }

        public String getType() {
            return type;
        }

        public String getMetrics() {
            return metrics;
        }

        public CvssModificationElement setMetrics(String metrics) {
            this.metrics = metrics;
            return this;
        }

        public CvssModificationElement setType(String type) {
            this.type = type;
            return this;
        }

        public CvssModificationElement setType(AeaaModificationType type) {
            this.type = type.schemaName;
            return this;
        }

        public CvssModificationElement setVersionFromVector(CvssVector vector) {
            this.version = vector.getName().replace("CVSS:", "");
            return this;
        }

        @AllArgsConstructor
        @Getter
        public enum AeaaModificationType {
            RESET("reset", new String[]{"reset modification"}),
            OVERWRITE("overwrite", new String[]{"overwrite metric"}),
            LOWER_SCORE("lower score", new String[]{"lowerScore"}),
            LOWER_METRIC("lower metric", new String[]{"lowerMetric"}),
            UPPER_SCORE("upper score", new String[]{"upperScore"}),
            UPPER_METRIC("upper metric", new String[]{"upperMetric"});

            private final String schemaName;
            private final String[] alternateNames;

            @Override
            public String toString() {
                return this.schemaName;
            }

            public static AeaaModificationType fromString(String input) {
                for (AeaaModificationType value : AeaaModificationType.values()) {
                    if (value.name().equalsIgnoreCase(input) || value.schemaName.equalsIgnoreCase(input)) {
                        return value;
                    }
                }
                for (AeaaModificationType value : AeaaModificationType.values()) {
                    for (String alternateName : value.alternateNames) {
                        if (alternateName.equalsIgnoreCase(input)) {
                            return value;
                        }
                    }
                }
                throw new IllegalArgumentException("CVSS Modification Type [" + input + "] does not exist. Use one of " + Arrays.toString(values()));
            }
        }
    }

    @Data
    @AllArgsConstructor
    public static class ReviewedAdvisory {
        private String id;
        private String rationale;

        public static ReviewedAdvisory fromMap(Object reviewedAdvisory) {
            if (reviewedAdvisory instanceof Map) {
                final Map<String, Object> reviewedAdvisoryMap = (Map<String, Object>) reviewedAdvisory;
                if (!reviewedAdvisoryMap.containsKey("id")) {
                    log.warn("Invalid reviewed advisory, missing id: {}", reviewedAdvisory);
                }
                if (!reviewedAdvisoryMap.containsKey("rationale")) {
                    log.warn("Invalid reviewed advisory, missing rationale: {}", reviewedAdvisory);
                }
                return new ReviewedAdvisory((String) reviewedAdvisoryMap.getOrDefault("id", ""), (String) reviewedAdvisoryMap.getOrDefault("rationale", "No rationale provided"));
            }
            log.warn("Invalid reviewed advisory type [{}], skipping", reviewedAdvisory);
            return null;
        }

        public String toJson() {
            return GSON.toJson(this);
        }

        public static String toJson(Collection<ReviewedAdvisory> reviewedAdvisories) {
            return GSON.toJson(reviewedAdvisories);
        }

        public static ReviewedAdvisory fromJson(String json) {
            return GSON.fromJson(json, ReviewedAdvisory.class);
        }

        public static List<ReviewedAdvisory> fromJsonArray(String json) {
            return GSON.fromJson(json, new TypeToken<List<ReviewedAdvisory>>() {
            }.getType());
        }

        // SECTION: query

        public static ReviewedAdvisory findReviewedEntry(@NonNull String id, List<ReviewedAdvisory> advisories) {
            return advisories.stream().filter(a -> id.equals(a.getId())).findFirst().orElse(null);
        }
    }

    @Data
    public static class MatchReason {
        final MatchType type;
        final String value;

        public MatchReason(MatchType type, String value) {
            this.type = type == null ? MatchType.VULNERABILITY : type;
            this.value = value == null ? "none" : value;
        }

        public static MatchReason fromMap(Map<String, Object> input) {
            if (input == null) {
                return null;
            }
            final MatchType type = MatchType.valueOf((String) input.get("type"));
            final String value = (String) input.get("value");
            return new MatchReason(type, value);
        }

        public String toDisplayString() {
            final String name = type.name().replace("_", " ").toLowerCase();
            if (StringUtils.hasText(value)) {
                return String.format(Locale.GERMANY, "%s: %s", name, value);
            } else {
                return name;
            }
        }
    }

    @Getter
    @AllArgsConstructor
    public enum MatchType {
        VULNERABILITY,
        CPE,
        CWE,
        CONDITION,
        INVENTORY_SCOPE,
    }

    // SECTION: templates

    public static AeaaVulnerabilityAssessmentEvent VOID() {
        return new AeaaVulnerabilityAssessmentEvent()
                .setStatus(VulnerabilityMetaData.STATUS_VALUE_VOID)
                .setRationale("The component affected by this vulnerability is not included in the current asset version.")
                .setDate(AeaaTimeUtils.utcNow())
                .setDiscardPriorEvents(true);
    }

    public static AeaaVulnerabilityAssessmentEvent INSIGNIFICANT(double insignificantThreshold) {
        return new AeaaVulnerabilityAssessmentEvent()
                .setStatus(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT)
                .setRationale(String.format(Locale.GERMANY, "Vulnerability severity score is below insignificant threshold of %s.", insignificantThreshold))
                .setDate(AeaaTimeUtils.utcNow())
                .setAutoAppendedForDisplay(true);
    }

    public static AeaaVulnerabilityAssessmentEvent IN_REVIEW() {
        return new AeaaVulnerabilityAssessmentEvent()
                .setStatus(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW)
                .setRationale("The vulnerability has automatically been marked as in review.")
                .setDate(AeaaTimeUtils.utcNow())
                .setAutoAppendedForDisplay(true);
    }
}
