/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaTimeUtils;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatus;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusConverter;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusHistoryEntry;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusReviewedEntry;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.springframework.util.StringUtils;

import java.io.File;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

@Slf4j
public class AeaaVulnerabilityAssessmentOperations {

    // SECTION: deserialize

    public static List<AeaaVulnerabilityAssessment> fromMap(Map<String, Object> root) {
        return fromMap(null, root);
    }

    public static List<AeaaVulnerabilityAssessment> fromMap(File sourceFile, Map<String, Object> root) {
        final SchemaVersion schemaVersion = SchemaVersion.parse(root);
        if (root == null || schemaVersion.major == 0) {
            return new ArrayList<>();
        }
        if (schemaVersion.major == 1) {
            return Collections.singletonList(parseLegacyAssessment(root));
        }

        final List<Map<String, Object>> assessmentYamls = (List<Map<String, Object>>) root.get("assessments");
        if (assessmentYamls == null) {
            log.warn("No assessments found in assessment file");
            return new ArrayList<>();
        }

        final List<AeaaVulnerabilityAssessment> assessments = new ArrayList<>();
        for (Map<String, Object> assessmentYaml : assessmentYamls) {
            assessments.add(AeaaVulnerabilityAssessment.fromMap(sourceFile, assessmentYaml));
        }
        return assessments;
    }

    private static AeaaVulnerabilityAssessment parseLegacyAssessment(Map<String, Object> root) {
        // convert legacy assessment to new assessment format
        return convertLegacyStatusToAssessment(AeaaVulnerabilityStatusConverter.fromYaml(root));
    }

    public static List<AeaaVulnerabilityAssessment> convertLegacyStatusToAssessment(Collection<AeaaVulnerabilityStatus> legacyAssessment) {
        return legacyAssessment.stream()
                .map(AeaaVulnerabilityAssessmentOperations::convertLegacyStatusToAssessment)
                .collect(Collectors.toList());
    }

    public static AeaaVulnerabilityAssessment convertLegacyStatusToAssessment(AeaaVulnerabilityStatus legacyAssessment) {
        final AeaaVulnerabilityAssessment assessment = new AeaaVulnerabilityAssessment();

        assessment.setSchemaVersion("1.0");

        assessment.setScope(AeaaVulnerabilityAssessment.Scope.fromLegacyScope(legacyAssessment.getScope()));

        final AeaaVulnerabilityAssessmentEvent.CvssModificationGroup cvssV2 = parseLegacyAssessmentCvss(legacyAssessment.getCvss2(), legacyAssessment.getCvss2Lower(), legacyAssessment.getCvss2Higher());
        final AeaaVulnerabilityAssessmentEvent.CvssModificationGroup cvssV3 = parseLegacyAssessmentCvss(legacyAssessment.getCvss3P1(), legacyAssessment.getCvss3P1Lower(), legacyAssessment.getCvss3P1Higher());
        final AeaaVulnerabilityAssessmentEvent.CvssModificationGroup cvssV4 = parseLegacyAssessmentCvss(legacyAssessment.getCvss4(), legacyAssessment.getCvss4Lower(), legacyAssessment.getCvss4Higher());

        for (AeaaVulnerabilityStatusHistoryEntry legacyEvent : legacyAssessment.getStatusHistory()) {
            final AeaaVulnerabilityAssessmentEvent event = new AeaaVulnerabilityAssessmentEvent();
            if (assessment.getScope() == AeaaVulnerabilityAssessment.Scope.INVENTORY) {
                event.setDiscardPriorEvents(true);
            } else if (assessment.getScope() == AeaaVulnerabilityAssessment.Scope.VULNERABILITY) {
                event.setDiscardEventsUntilBaseline(true);
            }

            event.setScope(assessment.getScope());
            event.setActive(legacyEvent.isActive());
            event.setStatus(legacyEvent.getStatus());
            event.setRationale(legacyEvent.getRationale());
            event.setRisk(legacyEvent.getRisk());
            event.setMeasures(legacyEvent.getMeasures());
            event.setAuthor(legacyEvent.getAuthor());
            event.setDate(legacyEvent.getDate() != null ? legacyEvent.getDate().getTime() : null);
            event.setScore(legacyEvent.getScore());

            event.setCvssV2(cvssV2);
            event.setCvssV3P1(cvssV3);
            event.setCvssV4P0(cvssV4);

            assessment.getEvents().add(event);
        }

        // add the cvss vectors to a new event if no events are present
        if (assessment.getEvents().isEmpty()) {
            final AeaaVulnerabilityAssessmentEvent event = new AeaaVulnerabilityAssessmentEvent();
            if (assessment.getScope() == AeaaVulnerabilityAssessment.Scope.INVENTORY) {
                event.setDiscardPriorEvents(true);
            } else if (assessment.getScope() == AeaaVulnerabilityAssessment.Scope.VULNERABILITY) {
                event.setDiscardEventsUntilBaseline(true);
            }
            event.setCvssV2(cvssV2);
            event.setCvssV3P1(cvssV3);
            event.setCvssV4P0(cvssV4);
            assessment.getEvents().add(event);
        }

        if (!legacyAssessment.getReviewedAdvisories().isEmpty()) {
            final AeaaVulnerabilityAssessmentEvent reviewedAdvisoriesEvent = new AeaaVulnerabilityAssessmentEvent();
            reviewedAdvisoriesEvent.setDate(AeaaTimeUtils.utcNow());
            for (AeaaVulnerabilityStatusReviewedEntry legacyReviewedAdvisory : legacyAssessment.getReviewedAdvisories()) {
                reviewedAdvisoriesEvent.getReviewedAdvisories().add(new AeaaVulnerabilityAssessmentEvent.ReviewedAdvisory(legacyReviewedAdvisory.getId(), legacyReviewedAdvisory.getComment()));
            }
            assessment.getEvents().add(reviewedAdvisoriesEvent);
        }

        return assessment;
    }

    private static AeaaVulnerabilityAssessmentEvent.CvssModificationGroup parseLegacyAssessmentCvss(CvssVector legacyOverwrite, CvssVector legacyLower, CvssVector legacyUpper) {
        final AeaaVulnerabilityAssessmentEvent.CvssModificationGroup cvss = new AeaaVulnerabilityAssessmentEvent.CvssModificationGroup();

        boolean hasOverwrite = false;
        boolean hasLower = false;
        boolean hasUpper = false;

        if (legacyOverwrite != null) {
            final String str = legacyOverwrite.toString();
            if (StringUtils.hasText(str) && !str.equals(legacyOverwrite.getName())) {
                cvss.setOverwrite(Collections.singletonList(new AeaaVulnerabilityAssessmentEvent.CvssModification(str, "Overwriting all parts")));
                hasOverwrite = true;
            }
        }
        if (legacyLower != null) {
            final String str = legacyLower.toString();
            if (StringUtils.hasText(str) && !str.equals(legacyLower.getName())) {
                cvss.setLowerScore(Collections.singletonList(new AeaaVulnerabilityAssessmentEvent.CvssModification(str, "Applying only parts that lead to a lower/equal score")));
                hasLower = true;
            }
        }
        if (legacyUpper != null) {
            final String str = legacyUpper.toString();
            if (!str.equals(legacyUpper.getName())) {
                cvss.setUpperScore(Collections.singletonList(new AeaaVulnerabilityAssessmentEvent.CvssModification(str, "Applying only parts that lead to a higher/equal score")));
                hasUpper = true;
            }
        }

        if (!hasOverwrite && !hasLower && !hasUpper) {
            return null;
        }

        return cvss;
    }

    // SECTION: serialize

    protected final static Gson GSON;

    static {
        GSON = new GsonBuilder()
                .create();
    }

    // SECTION: utility

    protected static boolean validateEntryType(Map<String, ?> map, String key, Class<?>... anyOfType) {
        if (map == null || !map.containsKey(key)) {
            return false;
        }

        boolean noneMatches = Arrays.stream(anyOfType).noneMatch(allowedClass -> allowedClass.isAssignableFrom(map.get(key).getClass()));

        if (noneMatches) {
            final List<String> expectedType = Arrays.stream(anyOfType).map(Class::getSimpleName).collect(Collectors.toList());
            final String effectiveType = map.get(key).getClass().getSimpleName();
            throw new IllegalArgumentException(String.format("Expected %s on element [%s] but got [%s]", expectedType, key, effectiveType));
        }

        return true;
    }

    protected static <SRC, TAR> TAR parseIfPresent(Map<String, ?> map, String key, Class<? extends SRC> src, TAR defaultValue, Function<SRC, TAR> parser) {
        if (map == null || !map.containsKey(key) || !validateEntryType(map, key, src)) {
            return defaultValue;
        }

        return parser.apply((SRC) map.get(key));
    }

    protected static <SRC, TAR> TAR parseIfPresent(Map<String, ?> map, String[] keys, Class<? extends SRC> src, TAR defaultValue, Function<SRC, TAR> parser) {
        if (map == null) {
            return defaultValue;
        }
        for (String key : keys) {
            if (map.containsKey(key) && validateEntryType(map, key, src)) {
                return parser.apply((SRC) map.get(key));
            }
        }
        return defaultValue;
    }

    private static <I, T extends Collection<I>> T warnAboutEmptyCollection(T collection, String msg) {
        if (collection == null || collection.isEmpty()) {
            log.warn("{}", msg);
        }
        return collection;
    }

    @Getter
    private static class SchemaVersion {
        private final int minor;
        private final int major;

        private SchemaVersion(int major, int minor) {
            this.minor = minor;
            this.major = major;
        }

        private static SchemaVersion parse(String input) {
            final String[] parts = input.split("\\.");
            if (parts.length != 2) {
                throw new IllegalArgumentException("Invalid schema version format: " + input);
            }
            return new SchemaVersion(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]));
        }

        private static SchemaVersion parse(Map<String, Object> input) {
            if (input == null) {
                return new SchemaVersion(0, 0);
            }
            if (input.containsKey("schema-version")) {
                if (input.get("schema-version") instanceof String) {
                    return parse((String) input.get("schema-version"));
                } else if (input.get("schema-version") instanceof Double) {
                    final double version = (Double) input.get("schema-version");
                    log.warn("Schema version is a double value, make sure to enclose with \"\" next time: {}", version);
                    return new SchemaVersion((int) version, (int) ((version - (int) version) * 10));
                }
            }
            log.warn("No schema version found, defaulting to 1.0");
            return new SchemaVersion(1, 0);
        }
    }
}
