/*
 * Copyright 2009-2026 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment;

import com.google.gson.*;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaTimeUtils;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatus;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusConverter;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusHistoryEntry;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.springframework.util.StringUtils;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
public class AeaaVulnerabilityAssessmentOperations {

    // SECTION: deserialize

    private static AeaaVulnerabilityAssessment fromJson(JSONObject json) {
        if (json.has("uid")) { // assessment event
            final AeaaVulnerabilityAssessmentEvent event = AeaaVulnerabilityAssessmentEvent.fromJson(json);
            final AeaaVulnerabilityAssessment assessment = new AeaaVulnerabilityAssessment();
            assessment.setSchemaVersion(AeaaSchemaVersion.VERSION_LATEST);

            assessment.getEvents().add(event);
            if (event.getScope() != null) assessment.setScope(event.getScope());
            assessment.setIgnoreWhenVoidFromMap(json.toMap());
            final AeaaVulnerabilityAssessment.AeaaCreationContext creationContext = AeaaVulnerabilityAssessmentEvent.creationContextFromJson(json);
            if (creationContext != null) assessment.setCreationContext(creationContext);

            return assessment;
        } else {
            return AeaaVulnerabilityAssessment.fromJson(json);
        }
    }

    public static List<AeaaVulnerabilityAssessment> fromMap(Map<String, Object> root) {
        return fromMap(null, root);
    }

    public static List<AeaaVulnerabilityAssessment> fromMap(File sourceFile, Map<String, Object> root) {
        final AeaaSchemaVersion schemaVersion = AeaaSchemaVersion.parse(root);
        if (root == null || schemaVersion.is(AeaaSchemaVersion.VERSION_PARSE_ERROR)) {
            return new ArrayList<>();
        }
        if (schemaVersion.is(AeaaSchemaVersion.VERSION_1_0)) {
            final AeaaVulnerabilityAssessment assessment = parseLegacyAssessment(root);
            assessment.setSourceFile(sourceFile);
            return Collections.singletonList(assessment);
        }

        final List<Map<String, Object>> assessmentYamls = (List<Map<String, Object>>) root.get("assessments");
        if (assessmentYamls == null) {
            log.warn("No assessments found in assessment file");
            return new ArrayList<>();
        }

        final List<AeaaVulnerabilityAssessment> assessments = new ArrayList<>();
        for (Map<String, Object> assessmentYaml : assessmentYamls) {
            assessmentYaml.put("schema-version", schemaVersion.toString());
            assessments.add(AeaaVulnerabilityAssessment.fromMap(sourceFile, assessmentYaml));
        }
        return assessments;
    }

    private static AeaaVulnerabilityAssessment parseLegacyAssessment(Map<String, Object> root) {
        // convert legacy assessment to new assessment format
        return convertLegacyStatusToAssessment(AeaaVulnerabilityStatusConverter.fromYaml(root), root);
    }

    public static AeaaVulnerabilityAssessment convertLegacyStatusToAssessment(AeaaVulnerabilityStatus legacyAssessment, Map<String, Object> root) {
        final AeaaVulnerabilityAssessment assessment = new AeaaVulnerabilityAssessment();

        assessment.setSchemaVersion(AeaaSchemaVersion.VERSION_LATEST);

        assessment.setScope(AeaaVulnerabilityAssessment.Scope.fromLegacyScope(legacyAssessment.getScope()));

        final List<AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationsContainer> cvssV2 = parseLegacyAssessmentCvss(legacyAssessment.getCvss2(), legacyAssessment.getCvss2Lower(), legacyAssessment.getCvss2Higher());
        final List<AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationsContainer> cvssV3 = parseLegacyAssessmentCvss(legacyAssessment.getCvss3P1(), legacyAssessment.getCvss3P1Lower(), legacyAssessment.getCvss3P1Higher());
        final List<AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationsContainer> cvssV4 = parseLegacyAssessmentCvss(legacyAssessment.getCvss4(), legacyAssessment.getCvss4Lower(), legacyAssessment.getCvss4Higher());

        final Set<String> collectedIncludesLabels = new LinkedHashSet<>();
        final Set<String> collectedExcludesLabels = new LinkedHashSet<>();
        for (AeaaVulnerabilityStatusHistoryEntry legacyEvent : legacyAssessment.getStatusHistory()) {
            final AeaaVulnerabilityAssessmentEvent event = new AeaaVulnerabilityAssessmentEvent();
            if (assessment.getScope() == AeaaVulnerabilityAssessment.Scope.INVENTORY) {
                event.setDiscardPriorEvents(true);
            } else if (assessment.getScope() == AeaaVulnerabilityAssessment.Scope.VULNERABILITY) {
                event.setDiscardEventsUntilBaseline(true);
            }

            event.setScope(assessment.getScope());
            event.setActive(legacyEvent.isActive());
            event.setStatus(legacyEvent.getStatus());
            event.setRationale(legacyEvent.getRationale());
            event.setRisk(legacyEvent.getRisk());
            event.setMeasures(legacyEvent.getMeasures());
            event.setAuthor(legacyEvent.getAuthor());
            event.setDate(legacyEvent.getDate() != null ? legacyEvent.getDate().getTime() : null);
            collectedExcludesLabels.addAll(legacyEvent.getExcludeLabels() != null ? new LinkedHashSet<>(Arrays.asList(legacyEvent.getExcludeLabels())) : Collections.emptySet());
            collectedIncludesLabels.addAll(legacyEvent.getIncludeLabels() != null ? new LinkedHashSet<>(Arrays.asList(legacyEvent.getIncludeLabels())) : Collections.emptySet());
            event.setScore(legacyEvent.getScore());

            assessment.getEvents().add(event);
        }

        final List<AeaaVulnerabilityAssessmentEvent.AeaaReviewedAdvisory> reviewedAdvisories = legacyAssessment.getReviewedAdvisories().stream()
                .map(legacyReviewedAdvisory -> new AeaaVulnerabilityAssessmentEvent.AeaaReviewedAdvisory(legacyReviewedAdvisory.getId(), legacyReviewedAdvisory.getComment()))
                .collect(Collectors.toList());

        // consolidate CVSS and reviewed advisories into the latest event, or create a new one if no events exist
        final boolean hasAdditionalData = !cvssV2.isEmpty() || !cvssV3.isEmpty() || !cvssV4.isEmpty() || !reviewedAdvisories.isEmpty();
        if (hasAdditionalData) {
            final AeaaVulnerabilityAssessmentEvent targetEvent;
            if (assessment.getEvents().isEmpty()) {
                // no history events exist, so create a new one to hold this data
                targetEvent = new AeaaVulnerabilityAssessmentEvent();
                if (assessment.getScope() == AeaaVulnerabilityAssessment.Scope.INVENTORY) {
                    targetEvent.setDiscardPriorEvents(true);
                } else if (assessment.getScope() == AeaaVulnerabilityAssessment.Scope.VULNERABILITY) {
                    targetEvent.setDiscardEventsUntilBaseline(true);
                }
                targetEvent.setDate(AeaaTimeUtils.utcNow());
                assessment.getEvents().add(targetEvent);
            } else {
                assessment.orderEvents();
                targetEvent = assessment.getEvents().get(0);
            }

            targetEvent.getCvss().addAll(cvssV2);
            targetEvent.getCvss().addAll(cvssV3);
            targetEvent.getCvss().addAll(cvssV4);
            targetEvent.getReviewedAdvisories().addAll(reviewedAdvisories);
        }

        return assessment;
    }

    private static List<AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationsContainer> parseLegacyAssessmentCvss(CvssVector legacyOverwrite, CvssVector legacyLower, CvssVector legacyUpper) {
        final List<AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationsContainer> converted = new ArrayList<>();

        if (legacyOverwrite != null) {
            final String str = legacyOverwrite.toString();
            if (StringUtils.hasText(str) && !str.equals(legacyOverwrite.getName())) {
                new AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationsContainer().addTo(converted)
                        .setRationale("Overwriting all parts").newModification().setVersionFromVector(legacyOverwrite).setMetrics(str).setType(AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationElement.AeaaModificationType.OVERWRITE);
            }
        }
        if (legacyLower != null) {
            final String str = legacyLower.toString();
            if (StringUtils.hasText(str) && !str.equals(legacyLower.getName())) {
                new AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationsContainer().addTo(converted)
                        .setRationale("Applying only parts that lead to a lower/equal score").newModification().setVersionFromVector(legacyLower).setMetrics(str).setType(AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationElement.AeaaModificationType.LOWER_SCORE);
            }
        }
        if (legacyUpper != null) {
            final String str = legacyUpper.toString();
            if (!str.equals(legacyUpper.getName())) {
                new AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationsContainer().addTo(converted)
                        .setRationale("Applying only parts that lead to a higher/equal score").newModification().setVersionFromVector(legacyUpper).setMetrics(str).setType(AeaaVulnerabilityAssessmentEvent.AeaaCvssModificationElement.AeaaModificationType.UPPER_SCORE);
            }
        }

        return converted;
    }

    // SECTION: serialize

    protected final static Gson GSON;

    static {
        GSON = new GsonBuilder()
                .registerTypeAdapter(File.class, new FileTypeAdapter())
                .registerTypeAdapter(ReentrantReadWriteLock.class, new ReentrantReadWriteLockTypeAdapter())
                .registerTypeAdapter(Pattern.class, new PatternTypeAdapter())
                .setExclusionStrategies(new SerializationExcludeStrategy())
                .create();
    }

    public static class SerializationExcludeStrategy implements ExclusionStrategy {
        @Override
        public boolean shouldSkipClass(Class<?> clazz) {
            // Attempted to serialize java.lang.Class: <class>. Forgot to register a type adapter?
            return clazz == Class.class;
        }

        @Override
        public boolean shouldSkipField(FieldAttributes f) {
            return false;
        }
    }


    public static class ReentrantReadWriteLockTypeAdapter extends TypeAdapter<ReentrantReadWriteLock> {
        @Override
        public void write(JsonWriter out, ReentrantReadWriteLock lock) throws IOException {
            if (lock == null) {
                out.nullValue();
            } else {
                out.beginObject();
                out.name("isWriteLocked").value(lock.isWriteLocked());
                out.name("readLockCount").value(lock.getReadLockCount());
                out.endObject();
            }
        }

        @Override
        public ReentrantReadWriteLock read(JsonReader in) throws IOException {
            JsonParser.parseReader(in).getAsJsonObject();
            return new ReentrantReadWriteLock();
        }
    }

    public static class PatternTypeAdapter extends TypeAdapter<Pattern> {
        @Override
        public void write(JsonWriter out, Pattern pattern) throws IOException {
            if (pattern == null) {
                out.nullValue();
            } else {
                out.value(pattern.pattern());
            }
        }

        @Override
        public Pattern read(JsonReader in) throws IOException {
            return Pattern.compile(in.nextString());
        }
    }

    public static class FileTypeAdapter extends TypeAdapter<File> {
        @Override
        public void write(JsonWriter out, File file) throws IOException {
            if (file == null) {
                out.nullValue();
            } else {
                out.value(file.getAbsolutePath());
            }
        }

        @Override
        public File read(JsonReader in) throws IOException {
            return new File(in.nextString());
        }
    }

    // SECTION: utility

    protected static boolean validateEntryType(Map<String, ?> map, String key, Class<?>... anyOfType) {
        if (map == null || !map.containsKey(key)) {
            return false;
        }

        final Object value = map.get(key);
        if (value == null) {
            return false;
        }

        boolean noneMatches = Arrays.stream(anyOfType).noneMatch(allowedClass -> allowedClass.isAssignableFrom(value.getClass()));

        if (noneMatches) {
            final List<String> expectedType = Arrays.stream(anyOfType).map(Class::getSimpleName).collect(Collectors.toList());
            final String effectiveType = value.getClass().getSimpleName();
            throw new IllegalArgumentException(String.format("Expected %s on element [%s] but got [%s]: %s", expectedType, key, effectiveType, map));
        }

        return true;
    }

    protected static <SRC, TAR> TAR parseIfPresent(Map<String, ?> map, String key, Class<? extends SRC> src, TAR defaultValue, Function<SRC, TAR> parser) {
        if (map == null || !map.containsKey(key) || !validateEntryType(map, key, src)) {
            return defaultValue;
        }

        return parser.apply((SRC) map.get(key));
    }

    protected static <SRC, TAR> TAR parseIfPresent(Map<String, ?> map, String[] keys, Class<? extends SRC> src, TAR defaultValue, Function<SRC, TAR> parser) {
        if (map == null) {
            return defaultValue;
        }
        for (String key : keys) {
            if (map.containsKey(key) && validateEntryType(map, key, src)) {
                return parser.apply((SRC) map.get(key));
            }
        }
        return defaultValue;
    }

    private static <I, T extends Collection<I>> T warnAboutEmptyCollection(T collection, String msg) {
        if (collection == null || collection.isEmpty()) {
            log.warn("{}", msg);
        }
        return collection;
    }

    @Getter
    @AllArgsConstructor
    public static class AeaaSchemaVersion {
        private final int major;
        private final int minor;

        private static int warnCounter = 0;

        public boolean is(int major, int minor) {
            return this.major == major && this.minor == minor;
        }

        public boolean is(AeaaSchemaVersion other) {
            return other != null && is(other.major, other.minor);
        }

        public boolean before(AeaaSchemaVersion other) {
            if (other == null) return false;
            return this.major < other.major || (this.major == other.major && this.minor < other.minor);
        }

        public boolean after(AeaaSchemaVersion other) {
            if (other == null) return false;
            return other.before(this);
        }

        public boolean beforeOrEqual(AeaaSchemaVersion other) {
            if (other == null) return false;
            return !this.after(other);
        }

        public boolean afterOrEqual(AeaaSchemaVersion other) {
            if (other == null) return false;
            return !this.before(other);
        }

        public boolean between(AeaaSchemaVersion lower, AeaaSchemaVersion upper) {
            return this.afterOrEqual(lower) && this.beforeOrEqual(upper);
        }

        @Override
        public String toString() {
            return major + "." + minor;
        }

        public static AeaaSchemaVersion parse(String input) {
            final String[] parts = input.split("\\.");
            if (parts.length != 2) {
                throw new IllegalArgumentException("Invalid schema version format: " + input);
            }
            return new AeaaSchemaVersion(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]));
        }

        public static AeaaSchemaVersion parse(Map<String, Object> input) {
            return parse(input, VERSION_1_0);
        }

        public static AeaaSchemaVersion parse(Map<String, Object> input, AeaaSchemaVersion fallback) {
            if (input == null) {
                return new AeaaSchemaVersion(0, 0);
            }

            final Object schemaVersionObj = ObjectUtils.firstNonNull(input.get("schema-version"), input.get("schemaVersion"));
            if (schemaVersionObj != null) {
                if (schemaVersionObj instanceof String) {
                    return parse((String) schemaVersionObj);
                } else if (schemaVersionObj instanceof Double) {
                    final double version = (Double) schemaVersionObj;
                    log.warn("Schema version was passed as a double value but was expected to be a string ({}). Make sure to enclose the property (schema-version or schemaVersion) with \"\" next time.", version);
                    return new AeaaSchemaVersion((int) version, (int) ((version - (int) version) * 10));
                }
            }

            if (warnCounter < 10) {
                log.warn("Assessment parsing: No schema version found, defaulting to {}", fallback);
                warnCounter++;
            } else if (warnCounter == 10) {
                log.warn("Assessment parsing: No schema version found, defaulting to {}; further warnings of this kind will be suppressed.", fallback);
                warnCounter++;
            }

            // assume legacy version
            return fallback;
        }

        /**
         * Old, pre-dynamic dashboard assessments.
         * Still supported to not force update of all YAML files already created.
         */
        public final static AeaaSchemaVersion VERSION_1_0 = new AeaaSchemaVersion(1, 0);
        /**
         * Initial version of the dynamic dashboard.
         */
        public final static AeaaSchemaVersion VERSION_2_0 = new AeaaSchemaVersion(2, 0);
        /**
         * Several changes to the assessment format:
         * <ul>
         *     <li>Schema Version is included in the assessment events</li>
         *     <li>(De)serialization now properly respects the versions to allow expansion of properties in the future.</li>
         * </ul>
         */
        public final static AeaaSchemaVersion VERSION_2_1 = new AeaaSchemaVersion(2, 1);
        /**
         * <ul>
         *     <li>Added: Affects: Ability to specify a matchOperator (default: OR, alternatively: AND) to determine the behavior when multiple affects types are combined.</li>
         *     <li>Added: Affects: Added "Artifact Matcher" that uses the correlation matcher to match artifacts on vulnerabilities.</li>
         *     <li>Changed: Affects: replaced "Condition" (attribute filters) with a new criteria format providing configurable pre-programmed behaviors instead of a DSL for configuring custom rules. Criteria added: ["msrc fix present"].</li>
         *     <li>Changed: Updated Dashboard UI to expose all available assessment matcher capabilities.</li>
         * </ul>
         */
        public final static AeaaSchemaVersion VERSION_2_2 = new AeaaSchemaVersion(2, 2);
        public final static AeaaSchemaVersion VERSION_LATEST = VERSION_2_2;

        /**
         * Internal version used to indicate that the assessment instance passed was null.
         */
        public final static AeaaSchemaVersion VERSION_PARSE_ERROR = new AeaaSchemaVersion(0, 0);
    }
}
