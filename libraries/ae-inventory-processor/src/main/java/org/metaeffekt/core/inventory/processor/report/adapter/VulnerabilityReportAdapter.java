/*
 * Copyright 2009-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.adapter;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.*;
import org.metaeffekt.core.inventory.processor.report.StatisticsOverviewTable;
import org.metaeffekt.core.inventory.processor.report.VulnerabilitySummaryData;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.*;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.AeaaAdvisoryEntry;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.AeaaMsrcAdvisorEntry;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.msrc.AeaaMsrcRemediation;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatus;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusHistoryEntry;
import org.metaeffekt.core.security.cvss.CvssSeverityRanges;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.metaeffekt.core.security.cvss.KnownCvssEntities;
import org.metaeffekt.core.security.cvss.MultiScoreCvssVector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Dedicated adapter for producing the detailed vulnerability content.
 */
public class VulnerabilityReportAdapter {

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityReportAdapter.class);


    protected final Inventory inventory;
    private final AeaaVulnerabilityContextInventory vInventory;

    private final CentralSecurityPolicyConfiguration securityPolicy;

    public VulnerabilityReportAdapter(Inventory inventory, CentralSecurityPolicyConfiguration securityPolicy) {
        this.inventory = inventory;
        this.securityPolicy = securityPolicy;

        this.vInventory = AeaaVulnerabilityContextInventory.fromInventory(inventory);
        this.vInventory.calculateEffectiveCvssVectorsForVulnerabilities(securityPolicy);
        this.vInventory.applyEffectiveVulnerabilityStatus(securityPolicy);
    }

    @Deprecated
    public VulnerabilityReportAdapter(Inventory inventory) {
        this.inventory = inventory;
        this.securityPolicy = new CentralSecurityPolicyConfiguration();

        this.vInventory = AeaaVulnerabilityContextInventory.fromInventory(inventory);
        this.vInventory.calculateEffectiveCvssVectorsForVulnerabilities(securityPolicy);
        this.vInventory.applyEffectiveVulnerabilityStatus(securityPolicy);
    }

    public Inventory getInventory() {
        return inventory;
    }

    public AeaaVulnerabilityContextInventory getVInventory() {
        return vInventory;
    }

    public List<AeaaVulnerability> getAllVulnerabilities() {
        return vInventory.getSortedVulnerabilities();
    }

    /* VULNERABILITY / ADVISORY FILTERING */

    public List<AeaaVulnerability> getEffectiveVulnerabilitiesAll() {
        final List<AeaaVulnerability> vulnerabilities = vInventory.getSortedVulnerabilities();
        return vulnerabilities.stream()
                .filter(securityPolicy::isVulnerabilityIncludedRegardingAdvisoryProviders)
                .filter(securityPolicy::isVulnerabilityAboveIncludeScoreThreshold)
                .collect(Collectors.toList());
    }

    public List<AeaaVulnerability> getEffectiveVulnerabilitiesForDetails() {
        final List<AeaaVulnerability> vulnerabilities = getEffectiveVulnerabilitiesAll();
        return vulnerabilities.stream()
                .filter(this::shouldVulnerabilityBeDisplayedInDetails)
                .collect(Collectors.toList());
    }

    public boolean shouldVulnerabilityBeDisplayedInDetails(AeaaVulnerability vulnerability) {
        if (!vulnerability.getOrCreateNewVulnerabilityStatus().getStatusHistory().isEmpty()) {
            return true;
        } else if (!vulnerability.getSecurityAdvisories().isEmpty()) {
            return true;
        }
        return false;
    }

    public List<AeaaAdvisoryEntry> getEffectiveSecurityAdvisoriesForVulnerability(AeaaVulnerability vulnerability) {
        final Set<AeaaAdvisoryEntry> advisories = vulnerability.getSecurityAdvisories();
        return advisories.stream()
                .filter(securityPolicy::isSecurityAdvisoryIncludedRegardingEntrySourceType)
                .collect(Collectors.toList());
    }

    public Set<AeaaAdvisoryEntry> getRelatedAdvisoriesExcluding(Collection<AeaaAdvisoryEntry> baseEntries, Collection<AeaaAdvisoryEntry>... advisories) {
        if (advisories == null || advisories.length == 0) {
            return Collections.emptySet();
        }
        if (baseEntries.isEmpty()) {
            return Collections.emptySet();
        }

        final Set<AeaaAdvisoryEntry> advisoryEntries = new HashSet<>(baseEntries);
        for (Collection<AeaaAdvisoryEntry> advisory : advisories) {
            if (advisory == null) continue;
            advisoryEntries.removeAll(advisory);
        }

        return advisoryEntries;
    }

    public List<AeaaAdvisoryEntry> getSecurityAdvisories() {
        return vInventory.getSoredSecurityAdvisories();
    }

    /* OVERVIEW TABLE GENERATION */

    public StatisticsOverviewTable generateOverviewTable(List<AeaaVulnerability> vulnerabilities, boolean useEffectiveSeverityScores, AeaaContentIdentifiers filterAdvisory) {
        return StatisticsOverviewTable.buildTable(this.securityPolicy, vulnerabilities, filterAdvisory, useEffectiveSeverityScores);
    }

    public StatisticsOverviewTable generateOverviewTable(List<AeaaVulnerability> vulnerabilities, boolean useEffectiveSeverityScores, String filterAdvisory) {
        return StatisticsOverviewTable.buildTableStrFilterAdvisor(this.securityPolicy, vulnerabilities, filterAdvisory, useEffectiveSeverityScores);
    }

    /* CVSS */

    public CvssSeverityRanges.SeverityRange getSeverityForVectorScore(double score) {
        return securityPolicy.getCvssSeverityRanges().getRange(score);
    }

    /**
     * Performs several operations on a source string from the CVSS vector:
     * <ul>
     *     <li>Transforms <code>Assessment-all</code>, <code>Assessment-higher</code> and <code>Assessment-lower</code> into <code>Assessment</code></li>
     *     <li>Removes any trailing duplicate <code>+ Assessment</code> from the string</li>
     * </ul>
     * Example:
     * <pre>
     *     NVD-CNA-NVD --&gt; NVD-CNA-NVD
     *     NVD-CNA-NVD + Assessment + Assessment --&gt; NVD-CNA-NVD + Assessment
     *     NVD-CNA-NVD + Assessment-all + Assessment-lower --&gt; NVD-CNA-NVD + Assessment
     * </pre>
     *
     * @param combinedSourceString The combined source string obtained via {@link org.metaeffekt.core.security.cvss.CvssSource#toCombinedColumnHeaderString(Collection)}
     * @return The post-processed source string
     */
    public String postProcessCvssSource(String combinedSourceString) {
        if (StringUtils.isBlank(combinedSourceString)) return "unknown";

        if (combinedSourceString.contains(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_ALL.getName())) {
            combinedSourceString = combinedSourceString.replace(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_ALL.getName(), KnownCvssEntities.ASSESSMENT.getName());
        }
        if (combinedSourceString.contains(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_HIGHER.getName())) {
            combinedSourceString = combinedSourceString.replace(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_HIGHER.getName(), KnownCvssEntities.ASSESSMENT.getName());
        }
        if (combinedSourceString.contains(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_LOWER.getName())) {
            combinedSourceString = combinedSourceString.replace(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_LOWER.getName(), KnownCvssEntities.ASSESSMENT.getName());
        }

        while (combinedSourceString.endsWith(" + " + KnownCvssEntities.ASSESSMENT.getName() + " + " + KnownCvssEntities.ASSESSMENT.getName())) {
            combinedSourceString = combinedSourceString.substring(0, combinedSourceString.length() - (" + " + KnownCvssEntities.ASSESSMENT.getName()).length());
        }

        return combinedSourceString;
    }

    public boolean hasTemporalScore(CvssVector... vectors) {
        for (CvssVector vector : vectors) {
            if (vector instanceof MultiScoreCvssVector && !Double.isNaN(vector.getBakedScores().getTemporalScore())) {
                return true;
            }
        }
        return false;
    }

    public boolean hasEnvironmentalScore(CvssVector... vectors) {
        for (CvssVector vector : vectors) {
            if (vector instanceof MultiScoreCvssVector && !Double.isNaN(vector.getBakedScores().getEnvironmentalScore())) {
                return true;
            }
        }
        return false;
    }

    public boolean hasAdjustedImpactScore(CvssVector... vectors) {
        for (CvssVector vector : vectors) {
            if (vector instanceof MultiScoreCvssVector && !Double.isNaN(vector.getBakedScores().getAdjustedImpactScore())) {
                return true;
            }
        }
        return false;
    }

    /* MICROSOFT UTILITIES */

    protected Map<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> getMsrcAdvisorEntriesWithRemediationInformation(AeaaVulnerability vulnerability, Collection<Artifact> artifacts) {
        if (vulnerability == null) return Collections.emptyMap();

        final Map<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> result = new LinkedHashMap<>();

        for (AeaaMsrcAdvisorEntry securityAdvisory : vulnerability.getRelatedAdvisorsOfSource(AeaaContentIdentifiers.MSRC, AeaaMsrcAdvisorEntry.class)) {
            for (AeaaMsrcRemediation msRemediation : securityAdvisory.getMsRemediations()) {
                final Set<String> affectedProductIds = msRemediation.getAffectedProductIds();
                boolean found = false;
                for (Artifact artifact : artifacts) {
                    final Set<String> productIds = getMsrcProductIdsForArtifact(artifact);
                    for (String productId : productIds) {
                        if (affectedProductIds.contains(productId)) {
                            result.computeIfAbsent(securityAdvisory, k -> new ArrayList<>()).add(msRemediation);
                            found = true;
                            break;
                        }
                    }
                }
                if (found) break;
            }
        }

        return result;
    }

    public boolean hasVulnerabilityMicrosoftRemediationInformationOnArtifact(AeaaVulnerability vulnerability, Collection<Artifact> artifacts) {
        return !getMsrcAdvisorEntriesWithRemediationInformation(vulnerability, artifacts).isEmpty();
    }

    public Map<String, String> getMicrosoftRemediationUrlAndDescriptionForVulnerabilityOnArtifact(AeaaVulnerability vulnerability, Artifact artifact) {
        final Map<String, String> result = new LinkedHashMap<>();
        final Set<String> knownKbIds = new HashSet<>();

        final Map<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> remediationEntriesMap = getMsrcAdvisorEntriesWithRemediationInformation(vulnerability, Collections.singletonList(artifact));

        for (Map.Entry<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> entry : remediationEntriesMap.entrySet()) {
            final List<AeaaMsrcRemediation> remediations = entry.getValue();
            for (AeaaMsrcRemediation remediation : remediations) {
                final AeaaReference url = remediation.getUrl();
                final String description = remediation.getDescription();
                result.put(url.getUrl(), description);
                knownKbIds.add(description);
            }
        }

        final List<String> kbRemediations = getMicrosoftRemediationKBsForVulnerabilityOnArtifact(vulnerability, artifact);
        for (String kb : kbRemediations) {
            if (!knownKbIds.contains(kb)) {
                result.put("https://support.microsoft.com/en-us/help/" + kb, kb);
            }
        }

        return result;
    }

    public List<String> getMicrosoftRemediationKBsForVulnerabilityOnArtifact(AeaaVulnerability vulnerability, Artifact artifact) {
        final String msFixingKbIdentifiers = vulnerability.getAdditionalAttribute(AeaaInventoryAttribute.MS_FIXING_KB_IDENTIFIER);
        final JSONObject fixingKbIds = StringUtils.isNotBlank(msFixingKbIdentifiers) ? new JSONObject(msFixingKbIdentifiers) : new JSONObject();
        final Set<String> artifactProductIds = getMsrcProductIdsForArtifact(artifact);

        final List<String> result = new ArrayList<>();
        for (String productId : artifactProductIds) {
            final JSONArray kbIds = fixingKbIds.optJSONArray(productId);
            if (kbIds != null) {
                for (int i = 0; i < kbIds.length(); i++) {
                    final String kbId = kbIds.optString(i);
                    if (StringUtils.isNotBlank(kbId)) {
                        result.add(kbId);
                    }
                }
            }
        }

        return result.stream().sorted().distinct().collect(Collectors.toList());
    }

    public Set<String> getMsrcProductIdsForArtifact(Artifact artifact) {
        if (artifact == null) return Collections.emptySet();
        if (artifact.get(AeaaInventoryAttribute.MS_PRODUCT_ID) == null) return Collections.emptySet();
        return Arrays.stream(artifact.get(AeaaInventoryAttribute.MS_PRODUCT_ID).split(", ")).collect(Collectors.toSet());
    }

    /* VULNERABILITY STATUS */

    public String getBaseVulnerabilityStatus(AeaaVulnerability vulnerability) {
        final AeaaVulnerabilityStatus status = vulnerability.getOrCreateNewVulnerabilityStatus();
        final AeaaVulnerabilityStatusHistoryEntry latest = status.getLatestActiveStatusHistoryEntry();

        return latest == null || StringUtils.isBlank(latest.getStatus()) ? "in review" : latest.getStatus();
    }

    public String getEffectiveVulnerabilityStatus(AeaaVulnerability vulnerability) {
        final AeaaVulnerabilityStatus status = vulnerability.getOrCreateNewVulnerabilityStatus();

        final AeaaVulnerabilityStatusHistoryEntry latest = status.getLatestActiveStatusHistoryEntry();
        final String latestStatus = latest == null || StringUtils.isBlank(latest.getStatus()) ? null : latest.getStatus();

        return securityPolicy.getVulnerabilityStatusDisplayMapper().getMapper().apply(latestStatus);
    }

    public List<String> getEffectiveVulnerabilityStatusLabels(AeaaVulnerability vulnerability) {
        final String effectiveStatus = getEffectiveVulnerabilityStatus(vulnerability);
        final String baseStatus = getBaseVulnerabilityStatus(vulnerability);

        final List<String> labels = new ArrayList<>();

        if (effectiveStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW)) {
            labels.add("In Review");
        } else if (effectiveStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE)) {
            labels.add("Applicable");
        } else if (effectiveStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE)) {
            labels.add("Not Applicable");
        } else if (effectiveStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT)) {
            labels.add("Insignificant");
        } else if (effectiveStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_VOID) || effectiveStatus.equalsIgnoreCase("unset")) { // when would the value be "unset"?
            labels.add("Void Vulnerability");
        } else if (effectiveStatus.equalsIgnoreCase("potentially affected")) {
            labels.add("Potentially Affected");
        } else if (effectiveStatus.equalsIgnoreCase("affected")) {
            labels.add("Affected");
        } else if (effectiveStatus.equalsIgnoreCase("not affected")) {
            labels.add("Not Affected");
        } else {
            labels.add("In Review");
        }

        if (!effectiveStatus.equalsIgnoreCase(baseStatus)) {
            if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW)) {
                labels.add("In Review");
            } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE)) {
                labels.add("Applicable");
            } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE)) {
                labels.add("Not Applicable");
            } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT)) {
                labels.add("Insignificant");
            } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_VOID) || baseStatus.equalsIgnoreCase("unset")) { // when would the value be "unset"?
                labels.add("Void Vulnerability");
            } else {
                labels.add("In Review");
            }
        }

        if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW) || baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE)) {
            labels.add("Potential Risk");
        }

        return labels;
    }

    public boolean shouldDisplayEffectiveVulnerabilityStatusCvssSeverity(AeaaVulnerability vulnerability) {
        final String status = getEffectiveVulnerabilityStatus(vulnerability);

        // if the status is not (not applicable, void), then display the severity
        return !status.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE) && !status.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_VOID);
    }

    public Map<DisplayStatusData, List<AeaaVulnerability>> getVulnerabilitiesByEffectiveStatus(List<AeaaVulnerability> vulnerabilities) {
        final Map<DisplayStatusData, List<AeaaVulnerability>> result = new LinkedHashMap<>();

        // add all categories no matter what from the security policy
        final List<String> allStatuses = securityPolicy.getVulnerabilityStatusDisplayMapper().getStatusNames();
        for (String status : allStatuses) {
            result.put(new DisplayStatusData(status), new ArrayList<>());
        }

        for (AeaaVulnerability vulnerability : vulnerabilities) {
            final String status = getEffectiveVulnerabilityStatus(vulnerability);
            result.computeIfAbsent(new DisplayStatusData(status), k -> new ArrayList<>()).add(vulnerability);
        }

        final List<String> baseStatusNames = CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_UNMODIFIED.getStatusNames();
        result.values().forEach(vulns -> vulns.sort((o1, o2) -> {
            final String status1 = getBaseVulnerabilityStatus(o1);
            final String status2 = getBaseVulnerabilityStatus(o2);
            final int index1 = baseStatusNames.indexOf(status1);
            final int index2 = baseStatusNames.indexOf(status2);
            final int status = Integer.compare(index1, index2);

            if (status != 0) {
                return status;
            }

            final CvssVector cvssVector1 = o1.getCvssSelectionResult().getSelectedEffectiveIfAvailableOtherwiseBase();
            final CvssVector cvssVector2 = o2.getCvssSelectionResult().getSelectedEffectiveIfAvailableOtherwiseBase();

            if (cvssVector1 == null && cvssVector2 == null) {
                return 0;
            } else if (cvssVector1 == null) {
                return 1;
            } else if (cvssVector2 == null) {
                return -1;
            } else {
                return Double.compare(cvssVector2.getOverallScore(), cvssVector1.getOverallScore());
            }
        }));

        return result;
    }

    public static class DisplayStatusData {
        private final String normalized;
        private final String capitalized;
        private final String asXmlId;

        public DisplayStatusData(String input) {
            this.normalized = input.toLowerCase();
            this.capitalized = StatisticsOverviewTable.capitalizeWords(normalized);
            this.asXmlId = normalized.replaceAll(" ", "_");
        }

        public String getNormalized() {
            return normalized;
        }

        public String getCapitalized() {
            return capitalized;
        }

        public String getAsXmlId() {
            return asXmlId;
        }

        private final static Set<String> STATUS_VALUES_WITHOUT_CVSS = new HashSet<>(Arrays.asList(
                VulnerabilityMetaData.STATUS_VALUE_VOID,
                VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE,
                "not affected"
        ));

        public boolean shouldModifiedCvssBeDisplayed() {
            return !STATUS_VALUES_WITHOUT_CVSS.contains(normalized);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            DisplayStatusData that = (DisplayStatusData) o;
            return Objects.equals(normalized, that.normalized) && Objects.equals(capitalized, that.capitalized) && Objects.equals(asXmlId, that.asXmlId);
        }

        @Override
        public int hashCode() {
            return Objects.hash(normalized, capitalized, asXmlId);
        }
    }

    /* COMPONENTS */

    public List<String> getComponentsFromInventory() {
        return inventory.getArtifacts().stream().map(Artifact::getComponent).distinct().collect(Collectors.toList());
    }

    public List<Artifact> getArtifactsForComponent(String component) {
        if (component == null) return Collections.emptyList();
        return inventory.getArtifacts().stream()
                .filter(a -> a.getComponent() != null && a.getComponent().equals(component))
                .collect(Collectors.toList());
    }

    /* MATCHING SOURCES */

    public List<String> vulnerabilityMatchingSourceLabelsForOverview(AeaaVulnerability vulnerability) {
        final List<String> result = new ArrayList<>();

        for (AeaaDataSourceIndicator matchingSource : vulnerability.getMatchingSources()) {
            final AeaaDataSourceIndicator.Reason matchReason = matchingSource.getMatchReason();
            final AeaaContentIdentifiers provider = matchingSource.getDataSource();

            if (matchReason instanceof AeaaDataSourceIndicator.ArtifactCpeReason) {
                final AeaaDataSourceIndicator.ArtifactCpeReason artifactCpeReason = ((AeaaDataSourceIndicator.ArtifactCpeReason) matchReason);
                final String cpe = artifactCpeReason.getCpe();
                if (cpe != null) {
                    result.add(cpe);
                } else {
                    result.add("CPE not available");
                }

            } else if (matchReason instanceof AeaaDataSourceIndicator.MsrcProductReason) {
                final AeaaDataSourceIndicator.MsrcProductReason msrcProductReason = ((AeaaDataSourceIndicator.MsrcProductReason) matchReason);
                result.add("MS " + msrcProductReason.getMsrcProductId());

            } else if (matchReason instanceof AeaaDataSourceIndicator.AssessmentStatusReason) {
                final AeaaDataSourceIndicator.AssessmentStatusReason assessmentStatusReason = ((AeaaDataSourceIndicator.AssessmentStatusReason) matchReason);
                result.add("Assessment " + assessmentStatusReason.getOriginFileName());

            } else if (matchReason instanceof AeaaDataSourceIndicator.ArtifactGhsaReason) {
                final AeaaDataSourceIndicator.ArtifactGhsaReason artifactGhsaReason = ((AeaaDataSourceIndicator.ArtifactGhsaReason) matchReason);
                final String coordinates = artifactGhsaReason.getCoordinates();
                if (coordinates != null) {
                    result.add("GHSA " + coordinates);
                } else {
                    result.add("GHSA");
                }

            } else if (matchReason instanceof AeaaDataSourceIndicator.AnyArtifactReason) {
                final AeaaDataSourceIndicator.AnyArtifactReason anyArtifactReason = ((AeaaDataSourceIndicator.AnyArtifactReason) matchReason);
                result.add(anyArtifactReason.getArtifactId());

            } else if (matchReason instanceof AeaaDataSourceIndicator.AnyReason) {
                final AeaaDataSourceIndicator.AnyReason anyReason = ((AeaaDataSourceIndicator.AnyReason) matchReason);
                result.add(anyReason.getDescription());

            } else {

                if (provider == AeaaContentIdentifiers.GHSA) {
                    result.add("GHSA " + vulnerability.getId());
                } else {
                    result.add(matchReason.toString());
                }
            }
        }

        return result.stream().distinct().collect(Collectors.toList());
    }

    public List<String> splitVulnerabilityMatchingSourcesIntoMultipleLines(List<String> inputLines, int lineLengthStart, int lineLengthEnd) {
        final List<List<String>> outputLines = new ArrayList<>();

        for (Iterator<String> iterator = inputLines.iterator(); iterator.hasNext(); ) {
            final String line = iterator.next();
            final List<String> splitLines = new ArrayList<>();

            if (line.length() <= lineLengthEnd) {
                splitLines.add(line);
            } else {
                splitLines.addAll(splitLine(line, lineLengthStart, lineLengthEnd));
            }
            outputLines.add(splitLines);

            if (iterator.hasNext()) {
                outputLines.add(Collections.singletonList(""));
            }
        }

        return outputLines.stream().flatMap(Collection::stream).collect(Collectors.toList());
    }

    private List<String> splitLine(String line, int minLength, int maxLength) {
        final List<String> result = new ArrayList<>();
        while (line.length() > maxLength) {
            int splitIndex = findSplitIndex(line, minLength, maxLength);
            result.add(line.substring(0, splitIndex).trim());
            line = line.substring(splitIndex).trim();
        }
        result.add(line);
        return result;
    }

    private int findSplitIndex(String line, int minLength, int maxLength) {
        // try to split at natural breakpoints first
        int splitIndex = -1;

        // try to split at space
        for (int i = maxLength; i >= minLength; i--) {
            char c = line.charAt(i);
            if (c == ' ') {
                splitIndex = i;
                break;
            }
        }
        if (splitIndex != -1) {
            return splitIndex;
        }

        // then try to split at punctuation
        for (int i = maxLength; i >= minLength; i--) {
            char c = line.charAt(i);
            if (c == '.' || c == ',' || c == '-' || c == '_' || c == '/' || c == '\\' || c == ':') {
                // include punctuation
                splitIndex = i + 1;
                break;
            }
        }
        if (splitIndex != -1) {
            return splitIndex;
        }


        // if no natural breakpoint found, force split at maxLength
        return maxLength;
    }

    /* ADVISORIES */

    public String getAdvisoryHeader() {
        final List<String> includeAdvisoryTypes = securityPolicy.getIncludeAdvisoryTypes();

        if (includeAdvisoryTypes == null || includeAdvisoryTypes.isEmpty() || includeAdvisoryTypes.contains("all")) {
            return "Alerts / Notices / Updates";
        }

        final StringBuilder sb = new StringBuilder();

        if (includeAdvisoryTypes.contains("alert")) {
            sb.append("Alerts");
        }
        if (includeAdvisoryTypes.contains("notice")) {
            if (sb.length() > 0) sb.append(" / ");
            sb.append("Notices");
        }
        if (includeAdvisoryTypes.contains("news")) {
            if (sb.length() > 0) sb.append(" / ");
            sb.append("Updates");
        }

        return sb.toString();
    }

    public String getAdvisorPeriodicQueryPeriod() {
        // cert-periodic-query
        // Range End	Range Start
        // 2023-11-29	2023-06-01
        final InventoryInfo periodInfo = this.inventory.findInventoryInfo("cert-periodic-query");
        if (periodInfo == null) return null;

        final String rangeEnd = periodInfo.get("Range End");
        final String rangeStart = periodInfo.get("Range Start");
        if (rangeEnd == null || rangeStart == null) return null;

        return rangeStart + " - " + rangeEnd;
    }

    public List<AeaaAdvisoryEntry> filterSecurityAdvisoriesForReviewStatus(List<AeaaAdvisoryEntry> securityAdvisories, String status) {
        if (securityAdvisories == null) return Collections.emptyList();

        return securityAdvisories.stream()
                .filter(a -> a.getAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS) != null)
                .filter(a -> a.getAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS).equalsIgnoreCase(status))
                .collect(Collectors.toList());
    }

    /* COMPONENTS / ARTIFACTS */

    public List<AeaaVulnerability> getVulnerabilitiesForArtifact(Artifact artifact) {
        if (artifact == null) return Collections.emptyList();
        return this.getEffectiveVulnerabilitiesAll().stream()
                .filter(v -> v.getAffectedArtifactsByDefaultKey().contains(artifact))
                .collect(Collectors.toList());
    }

    public List<AeaaVulnerability> getVulnerabilitiesForComponent(String component) {
        if (component == null) return Collections.emptyList();
        return this.getArtifactsForComponent(component).stream()
                .flatMap(a -> getVulnerabilitiesForArtifact(a).stream())
                .distinct()
                .collect(Collectors.toList());
    }

    /* OTHER ADAPTERS */

    public VulnerabilitySummaryData getVulnerabilitySummaryData() {
        return new VulnerabilitySummaryData(this.vInventory, this.securityPolicy);
    }

    /* OTHER UTILITIES */

    public static String naIfNull(String string) {
        if (string == null) {
            return "n.a.";
        }
        return string;
    }

    public boolean notNull(Object input) {
        return input != null;
    }

    public boolean fileExists(String path) {
        if (path == null) return false;
        return new File(path).exists();
    }
}
