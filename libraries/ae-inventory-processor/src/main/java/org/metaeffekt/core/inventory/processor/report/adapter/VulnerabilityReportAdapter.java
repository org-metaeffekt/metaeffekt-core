/*
 * Copyright 2009-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.adapter;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.*;
import org.metaeffekt.core.inventory.processor.report.StatisticsOverviewTable;
import org.metaeffekt.core.inventory.processor.report.VulnerabilitySummaryData;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;
import org.metaeffekt.core.inventory.processor.report.model.AdvisoryData;
import org.metaeffekt.core.inventory.processor.report.model.KeywordsInstance;
import org.metaeffekt.core.inventory.processor.report.model.LabelColor;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.*;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.AeaaAdvisoryEntry;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.AeaaMsrcAdvisorEntry;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.msrc.AeaaMsrcRemediation;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatus;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusHistoryEntry;
import org.metaeffekt.core.security.cvss.CvssSeverityRanges;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.metaeffekt.core.security.cvss.KnownCvssEntities;
import org.metaeffekt.core.security.cvss.MultiScoreCvssVector;
import org.metaeffekt.core.util.ParsingUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Dedicated adapter for producing the detailed vulnerability content.
 */
public class VulnerabilityReportAdapter {

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityReportAdapter.class);

    @Deprecated
    public final static String CVSS_SCORING_PREFERENCE_LATEST_FIRST = "v3 v2";
    @Deprecated
    public final static String CVSS_SCORING_PREFERENCE_MAX = "max v3 v2";

    @Deprecated
    protected final String scoringPreference;
    @Deprecated
    private final List<String> includeAdvisoryTypes;

    @Deprecated
    protected final float insignificantThreshold;

    /**
     * Caches a map for quick vulnerability lookup
     *
     * @deprecated Use vInventory instead
     */
    @Deprecated
    private final Map<String, VulnerabilityMetaData> nameToVulnerabilityMetaDataMap;

    protected final Inventory inventory;
    private final AeaaVulnerabilityContextInventory vInventory;

    private final CentralSecurityPolicyConfiguration securityPolicy;

    public VulnerabilityReportAdapter(Inventory inventory, CentralSecurityPolicyConfiguration securityPolicy, List<String> includeAdvisoryTypes) {
        this.inventory = inventory;
        this.securityPolicy = securityPolicy;
        this.includeAdvisoryTypes = includeAdvisoryTypes == null ? Arrays.asList("all") : includeAdvisoryTypes;

        this.vInventory = AeaaVulnerabilityContextInventory.fromInventory(inventory);
        this.vInventory.calculateEffectiveCvssVectorsForVulnerabilities(securityPolicy);
        this.vInventory.applyEffectiveVulnerabilityStatus(securityPolicy);

        // deprecated
        this.nameToVulnerabilityMetaDataMap = initializeVulnerabilityLookupMap(inventory);
        this.scoringPreference = CVSS_SCORING_PREFERENCE_LATEST_FIRST;
        this.insignificantThreshold = (float) securityPolicy.getInsignificantThreshold();
    }

    public VulnerabilityReportAdapter(Inventory inventory) {
        this.inventory = inventory;
        this.securityPolicy = new CentralSecurityPolicyConfiguration();
        this.includeAdvisoryTypes = Arrays.asList("all");

        this.vInventory = AeaaVulnerabilityContextInventory.fromInventory(inventory);
        this.vInventory.calculateEffectiveCvssVectorsForVulnerabilities(securityPolicy);
        this.vInventory.applyEffectiveVulnerabilityStatus(securityPolicy);


        // deprecated
        this.nameToVulnerabilityMetaDataMap = initializeVulnerabilityLookupMap(inventory);
        this.scoringPreference = CVSS_SCORING_PREFERENCE_LATEST_FIRST;
        this.insignificantThreshold = (float) securityPolicy.getInsignificantThreshold();
    }

    public Inventory getInventory() {
        return inventory;
    }

    public AeaaVulnerabilityContextInventory getVInventory() {
        return vInventory;
    }

    public List<AeaaVulnerability> getAllVulnerabilities() {
        return vInventory.getSortedVulnerabilities();
    }

    /* VULNERABILITY / ADVISORY FILTERING */

    public List<AeaaVulnerability> getEffectiveVulnerabilitiesAll() {
        final List<AeaaVulnerability> vulnerabilities = vInventory.getSortedVulnerabilities();
        return vulnerabilities.stream()
                .filter(securityPolicy::isVulnerabilityIncludedRegardingAdvisoryProviders)
                .filter(securityPolicy::isVulnerabilityAboveIncludeScoreThreshold)
                .collect(Collectors.toList());
    }

    public List<AeaaVulnerability> getEffectiveVulnerabilitiesForDetails() {
        final List<AeaaVulnerability> vulnerabilities = getEffectiveVulnerabilitiesAll();
        return vulnerabilities.stream()
                .filter(this::shouldVulnerabilityBeDisplayedInDetails)
                .collect(Collectors.toList());
    }

    public boolean shouldVulnerabilityBeDisplayedInDetails(AeaaVulnerability vulnerability) {
        if (!vulnerability.getOrCreateNewVulnerabilityStatus().getStatusHistory().isEmpty()) {
            return true;
        } else if (!vulnerability.getSecurityAdvisories().isEmpty()) {
            return true;
        }
        return false;
    }

    public List<AeaaAdvisoryEntry> getEffectiveSecurityAdvisoriesForVulnerability(AeaaVulnerability vulnerability) {
        final Set<AeaaAdvisoryEntry> advisories = vulnerability.getSecurityAdvisories();
        return advisories.stream()
                .filter(securityPolicy::isSecurityAdvisoryIncludedRegardingEntrySourceType)
                .collect(Collectors.toList());
    }

    public Set<AeaaAdvisoryEntry> getRelatedAdvisoriesExcluding(Collection<AeaaAdvisoryEntry> baseEntries, Collection<AeaaAdvisoryEntry>... advisories) {
        if (advisories == null || advisories.length == 0) {
            return Collections.emptySet();
        }
        if (baseEntries.isEmpty()) {
            return Collections.emptySet();
        }

        final Set<AeaaAdvisoryEntry> advisoryEntries = new HashSet<>(baseEntries);
        for (Collection<AeaaAdvisoryEntry> advisory : advisories) {
            if (advisory == null) continue;
            advisoryEntries.removeAll(advisory);
        }

        return advisoryEntries;
    }

    public List<AeaaAdvisoryEntry> getSecurityAdvisories() {
        return vInventory.getSoredSecurityAdvisories();
    }

    /* OVERVIEW TABLE GENERATION */

    public StatisticsOverviewTable generateOverviewTable(List<AeaaVulnerability> vulnerabilities, boolean useEffectiveSeverityScores, String filterAdvisory) {
        return StatisticsOverviewTable.buildTableStrFilterAdvisor(this.securityPolicy, vulnerabilities, filterAdvisory, useEffectiveSeverityScores);
    }

    /* CVSS */

    public CvssSeverityRanges.SeverityRange getSeverityForVectorScore(double score) {
        return securityPolicy.getCvssSeverityRanges().getRange(score);
    }

    /**
     * Performs several operations on a source string from the CVSS vector:
     * <ul>
     *     <li>Transforms <code>Assessment-all</code>, <code>Assessment-higher</code> and <code>Assessment-lower</code> into <code>Assessment</code></li>
     *     <li>Removes any trailing duplicate <code>+ Assessment</code> from the string</li>
     * </ul>
     * Example:
     * <pre>
     *     NVD-CNA-NVD --&gt; NVD-CNA-NVD
     *     NVD-CNA-NVD + Assessment + Assessment --&gt; NVD-CNA-NVD + Assessment
     *     NVD-CNA-NVD + Assessment-all + Assessment-lower --&gt; NVD-CNA-NVD + Assessment
     * </pre>
     *
     * @param combinedSourceString The combined source string obtained via {@link org.metaeffekt.core.security.cvss.CvssSource#toCombinedColumnHeaderString(Collection)}
     * @return The post-processed source string
     */
    public String postProcessCvssSource(String combinedSourceString) {
        if (StringUtils.isBlank(combinedSourceString)) return "unknown";

        if (combinedSourceString.contains(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_ALL.getName())) {
            combinedSourceString = combinedSourceString.replace(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_ALL.getName(), KnownCvssEntities.ASSESSMENT.getName());
        }
        if (combinedSourceString.contains(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_HIGHER.getName())) {
            combinedSourceString = combinedSourceString.replace(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_HIGHER.getName(), KnownCvssEntities.ASSESSMENT.getName());
        }
        if (combinedSourceString.contains(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_LOWER.getName())) {
            combinedSourceString = combinedSourceString.replace(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_LOWER.getName(), KnownCvssEntities.ASSESSMENT.getName());
        }

        while (combinedSourceString.endsWith(" + " + KnownCvssEntities.ASSESSMENT.getName() + " + " + KnownCvssEntities.ASSESSMENT.getName())) {
            combinedSourceString = combinedSourceString.substring(0, combinedSourceString.length() - (" + " + KnownCvssEntities.ASSESSMENT.getName()).length());
        }

        return combinedSourceString;
    }

    public boolean hasTemporalScore(CvssVector<?>... vectors) {
        for (CvssVector<?> vector : vectors) {
            if (vector instanceof MultiScoreCvssVector<?> && !Double.isNaN(((MultiScoreCvssVector<?>) vector).getBakedScores().getTemporalScore())) {
                return true;
            }
        }
        return false;
    }

    public boolean hasEnvironmentalScore(CvssVector<?>... vectors) {
        for (CvssVector<?> vector : vectors) {
            if (vector instanceof MultiScoreCvssVector<?> && !Double.isNaN(((MultiScoreCvssVector<?>) vector).getBakedScores().getEnvironmentalScore())) {
                return true;
            }
        }
        return false;
    }

    public boolean hasAdjustedImpactScore(CvssVector<?>... vectors) {
        for (CvssVector<?> vector : vectors) {
            if (vector instanceof MultiScoreCvssVector<?> && !Double.isNaN(((MultiScoreCvssVector<?>) vector).getBakedScores().getAdjustedImpactScore())) {
                return true;
            }
        }
        return false;
    }

    /* MICROSOFT UTILITIES */

    protected Map<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> getMsrcAdvisorEntriesWithRemediationInformation(AeaaVulnerability vulnerability, Collection<Artifact> artifacts) {
        if (vulnerability == null) return Collections.emptyMap();

        final Map<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> result = new LinkedHashMap<>();

        for (AeaaMsrcAdvisorEntry securityAdvisory : vulnerability.getRelatedAdvisorsOfSource(AeaaContentIdentifiers.MSRC, AeaaMsrcAdvisorEntry.class)) {
            for (AeaaMsrcRemediation msRemediation : securityAdvisory.getMsRemediations()) {
                final Set<String> affectedProductIds = msRemediation.getAffectedProductIds();
                boolean found = false;
                for (Artifact artifact : artifacts) {
                    final Set<String> productIds = getMsrcProductIdsForArtifact(artifact);
                    for (String productId : productIds) {
                        if (affectedProductIds.contains(productId)) {
                            result.computeIfAbsent(securityAdvisory, k -> new ArrayList<>()).add(msRemediation);
                            found = true;
                            break;
                        }
                    }
                }
                if (found) break;
            }
        }

        return result;
    }

    public boolean hasVulnerabilityMicrosoftRemediationInformationOnArtifact(AeaaVulnerability vulnerability, Collection<Artifact> artifacts) {
        return !getMsrcAdvisorEntriesWithRemediationInformation(vulnerability, artifacts).isEmpty();
    }

    public Map<String, String> getMicrosoftRemediationUrlAndDescriptionForVulnerabilityOnArtifact(AeaaVulnerability vulnerability, Artifact artifact) {
        final Map<String, String> result = new LinkedHashMap<>();
        final Set<String> knownKbIds = new HashSet<>();

        final Map<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> remediationEntriesMap = getMsrcAdvisorEntriesWithRemediationInformation(vulnerability, Collections.singletonList(artifact));

        for (Map.Entry<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> entry : remediationEntriesMap.entrySet()) {
            final List<AeaaMsrcRemediation> remediations = entry.getValue();
            for (AeaaMsrcRemediation remediation : remediations) {
                final AeaaReference url = remediation.getUrl();
                final String description = remediation.getDescription();
                result.put(url.getUrl(), description);
                knownKbIds.add(description);
            }
        }

        final List<String> kbRemediations = getMicrosoftRemediationKBsForVulnerabilityOnArtifact(vulnerability, artifact);
        for (String kb : kbRemediations) {
            if (!knownKbIds.contains(kb)) {
                result.put("https://support.microsoft.com/en-us/help/" + kb, kb);
            }
        }

        return result;
    }

    public List<String> getMicrosoftRemediationKBsForVulnerabilityOnArtifact(AeaaVulnerability vulnerability, Artifact artifact) {
        final String msFixingKbIdentifiers = vulnerability.getAdditionalAttribute(AeaaInventoryAttribute.MS_FIXING_KB_IDENTIFIER);
        final JSONObject fixingKbIds = StringUtils.isNotBlank(msFixingKbIdentifiers) ? new JSONObject(msFixingKbIdentifiers) : new JSONObject();
        final Set<String> artifactProductIds = getMsrcProductIdsForArtifact(artifact);

        final List<String> result = new ArrayList<>();
        for (String productId : artifactProductIds) {
            final JSONArray kbIds = fixingKbIds.optJSONArray(productId);
            if (kbIds != null) {
                for (int i = 0; i < kbIds.length(); i++) {
                    final String kbId = kbIds.optString(i);
                    if (StringUtils.isNotBlank(kbId)) {
                        result.add(kbId);
                    }
                }
            }
        }

        return result.stream().sorted().distinct().collect(Collectors.toList());
    }

    public Set<String> getMsrcProductIdsForArtifact(Artifact artifact) {
        if (artifact == null) return Collections.emptySet();
        if (artifact.get(AeaaInventoryAttribute.MS_PRODUCT_ID) == null) return Collections.emptySet();
        return Arrays.stream(artifact.get(AeaaInventoryAttribute.MS_PRODUCT_ID).split(", ")).collect(Collectors.toSet());
    }

    /* VULNERABILITY STATUS */

    public String getBaseVulnerabilityStatus(AeaaVulnerability vulnerability) {
        final AeaaVulnerabilityStatus status = vulnerability.getOrCreateNewVulnerabilityStatus();
        final AeaaVulnerabilityStatusHistoryEntry latest = status.getLatestActiveStatusHistoryEntry();

        return latest == null || StringUtils.isBlank(latest.getStatus()) ? "in review" : latest.getStatus();
    }

    public String getEffectiveVulnerabilityStatus(AeaaVulnerability vulnerability) {
        final AeaaVulnerabilityStatus status = vulnerability.getOrCreateNewVulnerabilityStatus();

        final AeaaVulnerabilityStatusHistoryEntry latest = status.getLatestActiveStatusHistoryEntry();
        final String latestStatus = latest == null || StringUtils.isBlank(latest.getStatus()) ? null : latest.getStatus();

        return securityPolicy.getVulnerabilityStatusDisplayMapper().getMapper().apply(latestStatus);
    }

    public List<String> getEffectiveVulnerabilityStatusLabels(AeaaVulnerability vulnerability) {
        final String effectiveStatus = getEffectiveVulnerabilityStatus(vulnerability);
        final String baseStatus = getBaseVulnerabilityStatus(vulnerability);

        final List<String> labels = new ArrayList<>();

        if (effectiveStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW)) {
            labels.add("In Review");
        } else if (effectiveStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE)) {
            labels.add("Applicable");
        } else if (effectiveStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE)) {
            labels.add("Not Applicable");
        } else if (effectiveStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT)) {
            labels.add("Insignificant");
        } else if (effectiveStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_VOID) || effectiveStatus.equalsIgnoreCase("unset")) { // when would the value be "unset"?
            labels.add("Void Vulnerability");
        } else if (effectiveStatus.equalsIgnoreCase("potentially affected")) {
            labels.add("Potentially Affected");
        } else if (effectiveStatus.equalsIgnoreCase("affected")) {
            labels.add("Affected");
        } else if (effectiveStatus.equalsIgnoreCase("not affected")) {
            labels.add("Not Affected");
        } else {
            labels.add("In Review");
        }

        if (!effectiveStatus.equalsIgnoreCase(baseStatus)) {
            if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW)) {
                labels.add("In Review");
            } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE)) {
                labels.add("Applicable");
            } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE)) {
                labels.add("Not Applicable");
            } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT)) {
                labels.add("Insignificant");
            } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_VOID) || baseStatus.equalsIgnoreCase("unset")) { // when would the value be "unset"?
                labels.add("Void Vulnerability");
            } else {
                labels.add("In Review");
            }
        }

        if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW) || baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE)) {
            labels.add("Potential Risk");
        }

        return labels;
    }

    public boolean shouldDisplayEffectiveVulnerabilityStatusCvssSeverity(AeaaVulnerability vulnerability) {
        final String status = getEffectiveVulnerabilityStatus(vulnerability);

        // if the status is not (not applicable, void), then display the severity
        return !status.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE) && !status.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_VOID);
    }

    public Map<DisplayStatusData, List<AeaaVulnerability>> getVulnerabilitiesByEffectiveStatus(List<AeaaVulnerability> vulnerabilities) {
        final Map<DisplayStatusData, List<AeaaVulnerability>> result = new LinkedHashMap<>();

        // add all categories no matter what from the security policy
        final List<String> allStatuses = securityPolicy.getVulnerabilityStatusDisplayMapper().getStatusNames();
        for (String status : allStatuses) {
            result.put(new DisplayStatusData(status), new ArrayList<>());
        }

        for (AeaaVulnerability vulnerability : vulnerabilities) {
            final String status = getEffectiveVulnerabilityStatus(vulnerability);
            result.computeIfAbsent(new DisplayStatusData(status), k -> new ArrayList<>()).add(vulnerability);
        }

        final List<String> baseStatusNames = CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_UNMODIFIED.getStatusNames();
        result.values().forEach(vulns -> vulns.sort((o1, o2) -> {
            final String status1 = getBaseVulnerabilityStatus(o1);
            final String status2 = getBaseVulnerabilityStatus(o2);
            final int index1 = baseStatusNames.indexOf(status1);
            final int index2 = baseStatusNames.indexOf(status2);
            final int status = Integer.compare(index1, index2);

            if (status != 0) {
                return status;
            }

            final CvssVector<?> cvssVector1 = o1.getCvssSelectionResult().getSelectedEffectiveIfAvailableOtherwiseBase();
            final CvssVector<?> cvssVector2 = o2.getCvssSelectionResult().getSelectedEffectiveIfAvailableOtherwiseBase();

            if (cvssVector1 == null && cvssVector2 == null) {
                return 0;
            } else if (cvssVector1 == null) {
                return 1;
            } else if (cvssVector2 == null) {
                return -1;
            } else {
                return Double.compare(cvssVector2.getOverallScore(), cvssVector1.getOverallScore());
            }
        }));

        return result;
    }

    public static class DisplayStatusData {
        private final String normalized;
        private final String capitalized;
        private final String asXmlId;

        public DisplayStatusData(String input) {
            this.normalized = input.toLowerCase();
            this.capitalized = StatisticsOverviewTable.capitalizeWords(normalized);
            this.asXmlId = normalized.replaceAll(" ", "_");
        }

        public String getNormalized() {
            return normalized;
        }

        public String getCapitalized() {
            return capitalized;
        }

        public String getAsXmlId() {
            return asXmlId;
        }

        private final static Set<String> STATUS_VALUES_WITHOUT_CVSS = new HashSet<>(Arrays.asList(
                VulnerabilityMetaData.STATUS_VALUE_VOID,
                VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE,
                "not affected"
        ));

        public boolean shouldModifiedCvssBeDisplayed() {
            return !STATUS_VALUES_WITHOUT_CVSS.contains(normalized);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            DisplayStatusData that = (DisplayStatusData) o;
            return Objects.equals(normalized, that.normalized) && Objects.equals(capitalized, that.capitalized) && Objects.equals(asXmlId, that.asXmlId);
        }

        @Override
        public int hashCode() {
            return Objects.hash(normalized, capitalized, asXmlId);
        }
    }

    /* COMPONENTS */

    public List<String> getComponentsFromInventory() {
        return inventory.getArtifacts().stream().map(Artifact::getComponent).distinct().collect(Collectors.toList());
    }

    public List<Artifact> getArtifactsForComponent(String component) {
        if (component == null) return Collections.emptyList();
        return inventory.getArtifacts().stream()
                .filter(a -> a.getComponent() != null && a.getComponent().equals(component))
                .collect(Collectors.toList());
    }

    /* MATCHING SOURCES */

    public List<String> vulnerabilityMatchingSourceLabelsForOverview(AeaaVulnerability vulnerability) {
        final List<String> result = new ArrayList<>();

        for (AeaaDataSourceIndicator matchingSource : vulnerability.getMatchingSources()) {
            final AeaaDataSourceIndicator.Reason matchReason = matchingSource.getMatchReason();
            final AeaaContentIdentifiers provider = matchingSource.getDataSource();

            if (matchReason instanceof AeaaDataSourceIndicator.ArtifactCpeReason) {
                final AeaaDataSourceIndicator.ArtifactCpeReason artifactCpeReason = ((AeaaDataSourceIndicator.ArtifactCpeReason) matchReason);
                final String cpe = artifactCpeReason.getCpe();
                if (cpe != null) {
                    result.add(cpe);
                } else {
                    result.add("CPE not available");
                }

            } else if (matchReason instanceof AeaaDataSourceIndicator.MsrcProductReason) {
                final AeaaDataSourceIndicator.MsrcProductReason msrcProductReason = ((AeaaDataSourceIndicator.MsrcProductReason) matchReason);
                result.add("MS " + msrcProductReason.getMsrcProductId());

            } else if (matchReason instanceof AeaaDataSourceIndicator.AssessmentStatusReason) {
                final AeaaDataSourceIndicator.AssessmentStatusReason assessmentStatusReason = ((AeaaDataSourceIndicator.AssessmentStatusReason) matchReason);
                result.add("Assessment " + assessmentStatusReason.getOriginFileName());

            } else if (matchReason instanceof AeaaDataSourceIndicator.AnyArtifactReason) {
                final AeaaDataSourceIndicator.AnyArtifactReason anyArtifactReason = ((AeaaDataSourceIndicator.AnyArtifactReason) matchReason);
                if (provider == AeaaContentIdentifiers.GHSA) {
                    result.add("GHSA " + anyArtifactReason.getArtifactId());
                } else {
                    result.add(anyArtifactReason.getArtifactId());
                }

            } else if (matchReason instanceof AeaaDataSourceIndicator.AnyReason) {
                final AeaaDataSourceIndicator.AnyReason anyReason = ((AeaaDataSourceIndicator.AnyReason) matchReason);
                result.add(anyReason.getDescription());

            } else {

                if (provider == AeaaContentIdentifiers.GHSA) {
                    result.add("GHSA " + vulnerability.getId());
                } else {
                    result.add(matchReason.toString());
                }
            }

        }

        return result;
    }

    /* ADVISORIES */

    public String getAdvisoryHeader() {
        final List<String> includeAdvisoryTypes = securityPolicy.getIncludeAdvisoryTypes();

        if (includeAdvisoryTypes == null || includeAdvisoryTypes.isEmpty() || includeAdvisoryTypes.contains("all")) {
            return "Alerts / Notices / Updates";
        }

        final StringBuilder sb = new StringBuilder();

        if (includeAdvisoryTypes.contains("alert")) {
            sb.append("Alerts");
        }
        if (includeAdvisoryTypes.contains("notice")) {
            if (sb.length() > 0) sb.append(" / ");
            sb.append("Notices");
        }
        if (includeAdvisoryTypes.contains("news")) {
            if (sb.length() > 0) sb.append(" / ");
            sb.append("Updates");
        }

        return sb.toString();
    }

    public String getAdvisorPeriodicQueryPeriod() {
        // cert-periodic-query
        // Range End	Range Start
        // 2023-11-29	2023-06-01
        final InventoryInfo periodInfo = this.inventory.findInventoryInfo("cert-periodic-query");
        if (periodInfo == null) return null;

        final String rangeEnd = periodInfo.get("Range End");
        final String rangeStart = periodInfo.get("Range Start");
        if (rangeEnd == null || rangeStart == null) return null;

        return rangeStart + " - " + rangeEnd;
    }

    public List<AeaaAdvisoryEntry> filterSecurityAdvisoriesForReviewStatus(List<AeaaAdvisoryEntry> securityAdvisories, String status) {
        if (securityAdvisories == null) return Collections.emptyList();

        return securityAdvisories.stream()
                .filter(a -> a.getAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS) != null)
                .filter(a -> a.getAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS).equalsIgnoreCase(status))
                .collect(Collectors.toList());
    }

    /* COMPONENTS / ARTIFACTS */

    public List<AeaaVulnerability> getVulnerabilitiesForArtifact(Artifact artifact) {
        if (artifact == null) return Collections.emptyList();
        return this.getEffectiveVulnerabilitiesAll().stream()
                .filter(v -> v.getAffectedArtifactsByDefaultKey().contains(artifact))
                .collect(Collectors.toList());
    }

    public List<AeaaVulnerability> getVulnerabilitiesForComponent(String component) {
        if (component == null) return Collections.emptyList();
        return this.getArtifactsForComponent(component).stream()
                .flatMap(a -> getVulnerabilitiesForArtifact(a).stream())
                .distinct()
                .collect(Collectors.toList());
    }

    /* OTHER ADAPTERS */

    public VulnerabilitySummaryData getVulnerabilitySummaryData() {
        return new VulnerabilitySummaryData(this.vInventory, this.securityPolicy);
    }

    /* OTHER UTILITIES */

    public static String naIfNull(String string) {
        if (string == null) {
            return "n.a.";
        }
        return string;
    }

    /* DEPRECATED STUFF */

    @Deprecated
    public void filterVulnerabilityMetadataByAdvisoryFilter(List<String> vulnerabilityAdvisoryFilter, List<VulnerabilityMetaData> vulnerabilityMetaData) {
        if (!vulnerabilityAdvisoryFilter.isEmpty()) {
            vulnerabilityMetaData.removeIf(vmd ->
                    this.getAdvisories(vmd).stream()
                            .noneMatch(advisory -> vulnerabilityAdvisoryFilter.contains(advisory.getSource())));
        }
    }

    @Deprecated
    private Map<String, VulnerabilityMetaData> initializeVulnerabilityLookupMap(Inventory inventory) {
        final List<VulnerabilityMetaData> vulnerabilityMetaData = inventory.getVulnerabilityMetaData();
        if (vulnerabilityMetaData != null) {
            final Map<String, VulnerabilityMetaData> nameMetaDataMap = new HashMap<>(vulnerabilityMetaData.size());
            for (VulnerabilityMetaData vmd : inventory.getVulnerabilityMetaData()) {
                nameMetaDataMap.put(vmd.get(VulnerabilityMetaData.Attribute.NAME), vmd);
            }
            return nameMetaDataMap;
        } else {
            return new HashMap<>();
        }
    }

    @Deprecated
    public List<VulnerabilityMetaData> getVulnerabilityMetaDataForDetailReport() {
        final List<VulnerabilityMetaData> vulnerabilityMetaDataList = VulnerabilityMetaData.
                filterVulnerabilitiesForDetails(inventory.getVulnerabilityMetaData(), insignificantThreshold);
        return vulnerabilityMetaDataList.stream()
                .sorted(VulnerabilityMetaData.VULNERABILITY_COMPARATOR_NAME_DESC)
                .collect(Collectors.toList());
    }

    @Deprecated
    public boolean hasDetails(VulnerabilityMetaData vulnerabilityMetaData) {
        return VulnerabilityMetaData.hasDetails(vulnerabilityMetaData, insignificantThreshold);
    }

    // FIXME: as the methods does not require any information from the local class it should be rather a
    //        method on VulnerabilityMetaData or on Advisory data not to mix model with supporting classes.
    //        Revise usages in core and artifact analysis.
    @Deprecated
    public List<AdvisoryData> getAdvisories(VulnerabilityMetaData vulnerabilityMetaData) {
        final String advisories = vulnerabilityMetaData.get("Advisories");

        final List<AdvisoryData> advisoryDataList = (advisories != null) ?
                AdvisoryData.fromJson(new JSONArray(advisories)) : new ArrayList<>();

        if (advisories != null && includeAdvisoryTypes != null) {
            return filterIncludeAdvisoryTypes(advisoryDataList);
        } else {
            return advisoryDataList;
        }
    }

    @Deprecated
    public String hyperlinkedAdvisory(AdvisoryData advisoryData) {
        final StringBuilder sb = new StringBuilder();
        appendHyperlink(sb, advisoryData);
        return sb.toString();
    }

    @Deprecated
    public String hyperlinkedAdvisories(List<AdvisoryData> advisoryDataList) {
        if (advisoryDataList == null) {
            return "no advisory data available";
        }

        Map<String, AdvisoryData> map = new HashMap<>();

        for (AdvisoryData advisoryData : advisoryDataList) {
            map.put(advisoryData.getId(), advisoryData);
        }

        List<String> orderedIds = new ArrayList<>(map.keySet());
        Collections.sort(orderedIds);

        final StringBuilder sb = new StringBuilder();
        for (String id : orderedIds) {
            AdvisoryData advisoryData = map.get(id);
            if (sb.length() > 0) sb.append(", ");
            appendHyperlink(sb, advisoryData);
        }

        return sb.toString();
    }

    @Deprecated
    private void appendHyperlink(StringBuilder sb, AdvisoryData advisoryData) {
        sb.append("<xref href=\"").
                append(advisoryData.getUrl()).append("\" type=\"html\" scope=\"external\">").
                append(advisoryData.getId()).append("</xref>");
    }

    @Deprecated
    public List<AdvisoryData> filterType(List<AdvisoryData> advisoryDataList, String type) {
        if (type == null) return advisoryDataList;
        if (advisoryDataList == null) {
            LOG.warn("No advisory data available for filtering on type [{}]", type);
            return new ArrayList<>();
        }
        return advisoryDataList.stream()
                .filter(a -> type.equalsIgnoreCase(a.getType()))
                .collect(Collectors.toList());
    }

    @Deprecated
    private boolean isAdvisoryTypeIncluded(String advisoryType) {
        if (includeAdvisoryTypes == null) {
            return true;
        } else if (includeAdvisoryTypes.size() == 0) {
            return false;
        }

        // includeAdvisoryTypes might contain 'all', which means all advisory types should be included
        if (includeAdvisoryTypes.stream().anyMatch(e -> e.equalsIgnoreCase("all"))) {
            return true;
        }

        for (String includeAdvisoryType : includeAdvisoryTypes) {
            if (includeAdvisoryType.equalsIgnoreCase(advisoryType)) {
                return true;
            }
        }

        return false;
    }

    @Deprecated
    public List<AdvisoryData> filterIncludeAdvisoryTypes(List<AdvisoryData> advisoryDataList) {
        final List<AdvisoryData> list = new ArrayList<>();

        for (AdvisoryData advisor : advisoryDataList) {
            if (advisor == null) {
                continue;
            }
            if (isAdvisoryTypeIncluded(advisor.getType())) {
                list.add(advisor);
            }
        }

        return list;
    }

    @Deprecated
    public List<AdvisoryMetaData> getAdvisoryMetaData() {
        return inventory.getAdvisoryMetaData();
    }

    @Deprecated
    public List<AdvisoryMetaData> getNewAdvisoryMetaData() {
        return getAdvisoryMetaDataByStatus(AdvisoryMetaData.STATUS_VALUE_NEW);
    }

    @Deprecated
    public List<AdvisoryMetaData> getInReviewAdvisoryMetaData() {
        return getAdvisoryMetaDataByStatus(AdvisoryMetaData.STATUS_VALUE_IN_REVIEW);
    }

    @Deprecated
    public List<AdvisoryMetaData> getReviewedAdvisoryMetaData() {
        return getAdvisoryMetaDataByStatus(AdvisoryMetaData.STATUS_VALUE_REVIEWED);
    }

    @Deprecated
    public List<AdvisoryMetaData> getUnaffectedAdvisoryMetaData() {
        return getAdvisoryMetaDataByStatus(AdvisoryMetaData.STATUS_VALUE_UNAFFECTED);
    }

    @Deprecated
    public List<AdvisoryMetaData> getUnclassifiedAdvisoryMetaData() {
        return getAdvisoryMetaDataByStatus(null);
    }

    @Deprecated
    public List<AdvisoryMetaData> getAdvisoryMetaDataByStatus(String status) {
        return inventory.getAdvisoryMetaData().stream()
                .filter(e -> Objects.equals(status, e.get(AdvisoryMetaData.Attribute.REVIEW_STATUS)))
                .sorted(AdvisoryMetaData.CERT_COMPARATOR_LAST_UPDATED_DESC)
                .collect(Collectors.toList());
    }

    @Deprecated
    public List<Artifact> getAffectedComponents(VulnerabilityMetaData vmd) {
        String name = vmd.get(VulnerabilityMetaData.Attribute.NAME);

        return inventory.getArtifacts().stream().filter(
                a -> getCveForArtifact(a).stream().anyMatch(
                        cve -> cve.get(VulnerabilityMetaData.Attribute.NAME).equals(name))
        ).collect(Collectors.toList());
    }

    private static java.util.regex.Pattern PRECOMPILED_PATTERN_P = Pattern.compile(" .+");
    private static java.util.regex.Pattern PRECOMPILED_PATTERN_Q = Pattern.compile(", ?");

    @Deprecated
    public List<VulnerabilityMetaData> getCveForArtifact(Artifact artifact) {
        final List<VulnerabilityMetaData> vulnerabilities = new ArrayList<>();
        final String vulnerabilitiesString = artifact.get(Artifact.Attribute.VULNERABILITY);

        if (vulnerabilitiesString != null) {
            for (String vulnerability : PRECOMPILED_PATTERN_Q.split(vulnerabilitiesString)) {
                final String name = PRECOMPILED_PATTERN_P.matcher(vulnerability.trim()).replaceAll("");
                final VulnerabilityMetaData vmd = nameToVulnerabilityMetaDataMap.get(name);
                if (vmd != null) {
                    vulnerabilities.add(vmd);
                }
            }
        }

        return vulnerabilities;
    }

    @Deprecated
    public List<KeywordsInstance> parseKeywordsFromInputJsonArrayString(String input) {
        if (org.apache.commons.lang3.StringUtils.isEmpty(input) || "[]".equals(input)) {
            return new ArrayList<>();

        } else if (!input.startsWith("[")) {
            LOG.warn("Invalid input for keywords: {}", input);
            return new ArrayList<>();
        }

        final List<KeywordsInstance> keywords = new ArrayList<>();
        final JSONArray jsonArray = new JSONArray(input);
        for (int i = 0; i < jsonArray.length(); i++) {
            keywords.add(new KeywordsInstance(jsonArray.getJSONObject(i)));
        }

        return keywords;
    }

    @Deprecated
    public boolean notNull(Object input) {
        return input != null;
    }

    /* cvss score determination by method start */

    @Deprecated
    public String getUnmodifiedCvssScoreByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Unmodified Overall");
    }

    @Deprecated
    public String getModifiedCvssScoreByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Modified Overall");
    }

    @Deprecated
    public String getUnmodifiedCvssSeverityByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Unmodified Severity");
    }

    @Deprecated
    public String getModifiedCvssSeverityByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Modified Severity");
    }

    @Deprecated
    private String getCvssScoreByScoringPreference(VulnerabilityMetaData vmd, String preference, String type) {
        if (preference == null) {
            return "pref not set";
        }

        final String[] parts = preference.replace(", ", ",").split(" ");

        for (String part : parts) {
            if (part.startsWith("v3")) {
                if (vmd.has("CVSS " + type + " (v3)")) {
                    return vmd.get("CVSS " + type + " (v3)");
                }

            } else if (part.startsWith("v2")) {
                if (vmd.has("CVSS " + type + " (v2)")) {
                    return vmd.get("CVSS " + type + " (v2)");
                }

            } else if (part.startsWith("max")) {
                if (vmd.has("CVSS " + type + " (v3)") && vmd.has("CVSS " + type + " (v2)") && type.contains("Overall")) {
                    return (int) (Math.max(ParsingUtils.parseCvssScore(vmd.get("CVSS " + type + " (v3)")), ParsingUtils.parseCvssScore(vmd.get("CVSS " + type + " (v2)"))) * 100) / 100.0 + "";
                } else if (vmd.has("CVSS " + type + " (max)")) {
                    return vmd.get("CVSS " + type + " (max)");
                }
            }
        }

        return "N/A";
    }

    /* components end, ms start */

    @Deprecated
    public Map<String, String> getMicrosoftRemediationUrlAndDescriptionForVulnerabilityOnArtifactOld(VulnerabilityMetaData vmd, Artifact artifact) {
        final Map<String, String> kbIdentifiers = new HashMap<>();

        if (artifact.has("MS Remediations")) {
            String vulnerabilityName = vmd.get(VulnerabilityMetaData.Attribute.NAME);
            JSONObject remediationForVulnerability = new JSONObject(artifact.get("MS Remediations"));

            JSONArray remediationArray = remediationForVulnerability.optJSONArray(vulnerabilityName);
            if (remediationArray != null) {
                for (int i = 0; i < remediationArray.length(); i++) {
                    JSONObject remediation = remediationArray.optJSONObject(i);
                    if (remediation.has("url")) {
                        String url = remediation.optString("url", "N/A");
                        String description = remediation.optString("description", url);
                        kbIdentifiers.put(url, description);
                    }
                }
            }
        }

        return kbIdentifiers;
    }

    @Deprecated
    public List<String> getMicrosoftRemediationKBsForVulnerabilityOnArtifactOld(VulnerabilityMetaData vmd, Artifact artifact) {
        // the set ensures, we do not collect duplicates
        final Set<String> kbIdentifiers = new HashSet<>();
        if (artifact.has("MS Remediations")) {
            final String vulnerabilityName = vmd.get(VulnerabilityMetaData.Attribute.NAME);
            final JSONObject remediationForVulnerability = new JSONObject(artifact.get("MS Remediations"));
            final JSONArray remediationArray = remediationForVulnerability.optJSONArray(vulnerabilityName);
            if (remediationArray != null) {
                for (int i = 0; i < remediationArray.length(); i++) {
                    final JSONObject remediation = remediationArray.optJSONObject(i);
                    String kb = remediation.optString("kb", "").trim();
                    if (StringUtils.isNotBlank(kb)) {
                        if (kb.startsWith("KB")) {
                            kbIdentifiers.add(kb);
                        } else {
                            kbIdentifiers.add("KB" + kb);
                        }
                    }
                }
            }
        }

        // return as sorted list
        return kbIdentifiers.stream().sorted().collect(Collectors.toList());
    }

    /* ms end, statistics table start */

    @Deprecated
    public String getFurtherAbstractedVulnerabilityCategory(final String category) {
        throw new UnsupportedOperationException("No longer supported.");
    }

    @Deprecated
    public StatisticsOverviewTable createUnmodifiedStatisticsOverviewTable(String filterCert, Function<String, String> statusMapperFunction) {
        throw new UnsupportedOperationException("No longer supported.");
    }

    @Deprecated
    public StatisticsOverviewTable createModifiedStatisticsOverviewTable(String filterCert, Function<String, String> statusMapperFunction) {
        throw new UnsupportedOperationException("No longer supported.");
    }

    /* statistics table end, utilities start */

    public boolean fileExists(String path) {
        if (path == null) return false;
        return new File(path).exists();
    }

    public static String modulateSeverityText(String severity) {
        if (severity == null) {
            return "n.a.";
        }
        return severity;
    }

    /**
     * Converts a HEX color into a label color by evaluating the background brightness and setting the foreground to
     * either black or white based on that.
     *
     * @param color The background color to use.
     * @return A LabelColor containing background and foreground colors.
     */
    public static LabelColor getLabelColor(String color) {
        if (color != null) {
            int rgb = Integer.parseInt(color.substring(1), 16);
            int r = (rgb >> 16) & 0xff;
            int g = (rgb >> 8) & 0xff;
            int b = (rgb) & 0xff;
            double luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            String backgroundColor = luma < 120 ? "white" : "black";
            return new LabelColor(color, backgroundColor);
        }
        return new LabelColor("#cfcfc4", "black");
    }

    @Deprecated
    public String getStatusText(final VulnerabilityMetaData vulnerabilityMetaData) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);

        // evaluate implicit status based on threshold
        if (StringUtils.isBlank(status) || vulnerabilityMetaData.isStatus(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW)) {
            if (isBelowThreshold(vulnerabilityMetaData)) {
                status = "insignificant";
            } else {
                status = "in review";
            }
        }
        return status.toLowerCase();
    }

    /**
     * Implements to CVSSv3 over CVSSv2 strategy to check whether the vulnerability is below the threshold.
     *
     * @param vulnerabilityMetaData
     * @return Returns <code>true</code> is the {@link VulnerabilityMetaData} relevant score is below the
     * insignificant threshold.
     */
    @Deprecated
    private boolean isBelowThreshold(VulnerabilityMetaData vulnerabilityMetaData) {
        final Float score = getFloat(getUnmodifiedCvssScoreByScoringPreference(vulnerabilityMetaData, scoringPreference));
        return score != null && score < insignificantThreshold;
    }

    private static Float getFloat(String maxScoreString) {
        try {
            return StringUtils.isNotBlank(maxScoreString) ? Float.valueOf(maxScoreString) : null;
        } catch (NumberFormatException e) {
            // ignore the exception; the score may be N/A
        }
        return null;
    }

    @Deprecated
    public String getPlainStatusText(final VulnerabilityMetaData vulnerabilityMetaData) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);
        if (status == null) {
            if (isBelowThreshold(vulnerabilityMetaData)) {
                status = "insignificant";
            } else {
                status = "in review";
            }
        }
        return status.toLowerCase();
    }

    public LabelColor getStatusLabelColor(String statusText) {
        switch (statusText) {
            case "in review":
                return new LabelColor("#84bfff", "black"); // pastel-blue
            case "not applicable":
                return new LabelColor("#77dd77", "black"); // pastel-green
            case "insignificant":
                return new LabelColor("#84bfff", "#black"); // pastel-blue
            case "potential vulnerability": // deprecated; kept due to compatibility concerns
                return new LabelColor("#e3b2f2", "black"); // pastel-purple
            case "potential risk":
                return new LabelColor("#e3b2f2", "black"); // pastel-purple
            case "void":
                return new LabelColor("#636363", "white"); // strong-gray

            default:
                return new LabelColor("#ffcc00", "black"); // strong-yellow
        }
    }

    // FIXME: the whole status and label handling needs to be revised. Currently implemented very inefficiently
    //   Perhaps the inventory can be enhanced based on the given threshold. Such that we have an inventory
    //   reflecting the final status with threshold applied. Then this logic here is simplified.

    @Deprecated
    public boolean isApplicableVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "applicable":
                return true;
        }
        return false;
    }

    @Deprecated
    public boolean isPotentialVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "applicable":
                return true;
            case "in review":
                return true;
        }
        return false;
    }

    @Deprecated
    public boolean isVoidVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "unset": // this needs investigation; should not be required.
            case "void":
                return true;
        }
        return false;
    }

    @Deprecated
    public boolean isNotApplicableVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "not applicable":
                return true;
        }
        return false;
    }

    @Deprecated
    public boolean isInsignificantVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "insignificant":
                return true;
        }
        return false;
    }

    @Deprecated
    public boolean isInReviewVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "in review":
                return true;
        }
        return false;
    }

    @Deprecated
    public boolean isReviewedVulnerability(VulnerabilityMetaData vmd) {
        // a vulnerability is reviewed, when the status attribute is provided
        if (vmd == null) return false;
        return vmd.get(VulnerabilityMetaData.Attribute.STATUS) != null;
    }

    @Deprecated
    public List<VulnerabilityMetaData> collectAffectedCategory() {
        return inventory.getVulnerabilityMetaData().stream().filter(vmd -> {
            boolean hasStatus = vmd.has(VulnerabilityMetaData.Attribute.STATUS.getKey()) && !vmd.get(VulnerabilityMetaData.Attribute.STATUS).isEmpty();
            boolean isCategoryAffected = vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE) || vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT);
            return hasStatus && isCategoryAffected;
        }).collect(Collectors.toList());
    }

    @Deprecated
    public List<VulnerabilityMetaData> collectPotentiallyAffectedCategory() {
        return inventory.getVulnerabilityMetaData().stream().filter(vmd -> {
            final boolean hasStatus = vmd.has(VulnerabilityMetaData.Attribute.STATUS.getKey()) && !vmd.get(VulnerabilityMetaData.Attribute.STATUS).isEmpty();
            final boolean isCategoryPotentiallyAffected = !hasStatus || vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW);

            // NOTE: in review used to be an implicit status, but now can be explicitly set. The above implementation
            //   anticipates this.

            return isCategoryPotentiallyAffected;
        }).collect(Collectors.toList());
    }

    @Deprecated
    public List<VulnerabilityMetaData> collectNotAffectedCategory() {
        return inventory.getVulnerabilityMetaData().stream().filter(vmd -> {
            boolean hasStatus = vmd.has(VulnerabilityMetaData.Attribute.STATUS.getKey()) && !vmd.get(VulnerabilityMetaData.Attribute.STATUS).isEmpty();
            boolean isCategoryNotAffected = vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE) || vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_VOID);
            return hasStatus && isCategoryNotAffected;
        }).collect(Collectors.toList());
    }
}
