/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.adapter;

import lombok.Data;
import lombok.Getter;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.InventoryUtils;
import org.metaeffekt.core.inventory.processor.model.*;
import org.metaeffekt.core.inventory.processor.report.InventoryReport;
import org.metaeffekt.core.inventory.processor.report.StatisticsOverviewTable;
import org.metaeffekt.core.inventory.processor.report.VulnerabilitySummaryData;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.*;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.AeaaAdvisoryEntry;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.AeaaMsrcAdvisorEntry;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.advisory.msrc.AeaaMsrcRemediation;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.AeaaEolCycle;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaCycleStateExtendedSupportInformationNotPresent;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaCycleStateExtendedSupportInformationPresent;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaCycleStateScenario;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaExportedCycleState;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.score.AeaaVulnerabilityPriorityCalculator;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.store.AeaaAdvisoryTypeIdentifier;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.store.AeaaAdvisoryTypeStore;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.store.AeaaContentIdentifierStore;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatus;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusHistoryEntry;
import org.metaeffekt.core.security.cvss.CvssSeverityRanges;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.metaeffekt.core.security.cvss.KnownCvssEntities;
import org.metaeffekt.core.security.cvss.MultiScoreCvssVector;
import org.metaeffekt.core.security.cvss.processor.CvssSelectionResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Dedicated adapter for producing the detailed vulnerability content.
 */
public class VulnerabilityReportAdapter {

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityReportAdapter.class);


    protected final Inventory inventory;
    private final AeaaVulnerabilityContextInventory vInventory;
    private final AeaaVulnerabilityContextInventory vInitialInventory;

    @Getter
    private final CentralSecurityPolicyConfiguration securityPolicy;

    public VulnerabilityReportAdapter(Inventory inventory, CentralSecurityPolicyConfiguration securityPolicy) {
        this.inventory = inventory;
        this.securityPolicy = securityPolicy;

        this.vInventory = AeaaVulnerabilityContextInventory.fromInventory(inventory);
        this.vInventory.bakeEffectiveSecurityAdvisoriesOnVulnerabilities();
        this.vInventory.calculateEffectiveCvssVectorsForVulnerabilities(securityPolicy);
        this.vInventory.applyEffectiveVulnerabilityStatus(securityPolicy);

        this.vInitialInventory = AeaaVulnerabilityContextInventory.fromInventory(inventory);
        this.vInitialInventory.bakeEffectiveSecurityAdvisoriesOnVulnerabilities();
        this.vInitialInventory.calculateEffectiveCvssVectorsForVulnerabilities(securityPolicy);
        this.vInitialInventory.getVulnerabilities()
                .forEach(v -> v.mapCvssSelectionResult(CvssSelectionResult::deriveInitialOnlySelectionResult));
        this.vInitialInventory.applyEffectiveVulnerabilityStatus(securityPolicy);
    }

    public static String naIfNull(String string) {
        if (string == null) {
            return "n.a.";
        }
        return string;
    }

    public Inventory getInventory() {
        return inventory;
    }

    public AeaaVulnerabilityContextInventory getVInventory() {
        return vInventory;
    }

    /* VULNERABILITY / ADVISORY FILTERING */

    public List<AeaaVulnerability> getAllVulnerabilities() {
        return vInventory.getSortedVulnerabilities();
    }

    public List<AeaaVulnerability> getEffectiveVulnerabilitiesAll() {
        final List<AeaaVulnerability> vulnerabilities = vInventory.getSortedVulnerabilities();
        return vulnerabilities.stream()
                .filter(securityPolicy::isVulnerabilityIncludedRegardingAdvisoryProviders)
                .filter(securityPolicy::isVulnerabilityIncludedRegardingAdvisoryReviewStatus)
                .filter(securityPolicy::isVulnerabilityAboveIncludeScoreThreshold)
                .collect(Collectors.toList());
    }

    public List<AeaaVulnerability> getEffectiveVulnerabilitiesInitialInventoryAll() {
        final List<AeaaVulnerability> vulnerabilities = vInitialInventory.getSortedVulnerabilities();
        return vulnerabilities.stream()
                .filter(securityPolicy::isVulnerabilityIncludedRegardingAdvisoryProviders)
                .filter(securityPolicy::isVulnerabilityIncludedRegardingAdvisoryReviewStatus)
                .filter(securityPolicy::isVulnerabilityAboveIncludeScoreThreshold)
                .collect(Collectors.toList());
    }

    public List<AeaaVulnerability> getEffectiveVulnerabilitiesForDetails() {
        final List<AeaaVulnerability> vulnerabilities = getEffectiveVulnerabilitiesAll();
        return vulnerabilities.stream()
                .filter(this::shouldVulnerabilityBeDisplayedInDetails)
                .collect(Collectors.toList());
    }

    // FIXME-KKL: check whether the current condition is sufficient
    public boolean shouldVulnerabilityBeDisplayedInDetails(AeaaVulnerability vulnerability) {

        // check whether there are security advisories
        // DISCUSS: this should also affect the priority
        if (!vulnerability.getSecurityAdvisories().isEmpty()) {
            return true;
        }

        // check whether we have a status change
        final Optional<AeaaVulnerabilityStatus> vulnerabilityStatus = vulnerability.optVulnerabilityStatus();
        if (vulnerabilityStatus.isPresent() && !vulnerabilityStatus.get().getStatusHistory().isEmpty()) {
            return true;
        }

        // TODO: check whether priority is equal or beyond either elevated, due or escalate; what is expected?

        return false;
    }

    public List<AeaaAdvisoryEntry> getEffectiveSecurityAdvisoriesForVulnerability(AeaaVulnerability vulnerability) {
        final Set<AeaaAdvisoryEntry> advisories = vulnerability.getSecurityAdvisories();
        return advisories.stream()
                .filter(securityPolicy::isSecurityAdvisoryIncludedRegardingEntrySourceType)
                .filter(securityPolicy::isSecurityAdvisoryIncludedRegardingEntryProvider)
                .collect(Collectors.toList());
    }

    public List<List<AeaaAdvisoryEntry>> groupSecurityAdvisoriesBySourceAndType(List<AeaaAdvisoryEntry> sourceSecurityAdvisoryEntries) {
        return sourceSecurityAdvisoryEntries.stream()
                .collect(Collectors.groupingBy(a -> a.getSourceIdentifier() + " " + a.getType()))
                .entrySet().stream().sorted(Map.Entry.comparingByKey())
                .map(Map.Entry::getValue)
                .map(l -> l.stream().sorted(Comparator.comparing(e -> e.getSourceIdentifier().name())).collect(Collectors.toList()))
                .collect(Collectors.toList());
    }

    public Set<AeaaAdvisoryEntry> getRelatedAdvisoriesExcluding(Collection<AeaaAdvisoryEntry> baseEntries, Collection<AeaaAdvisoryEntry>... advisories) {
        if (advisories == null || advisories.length == 0) {
            return Collections.emptySet();
        }
        if (baseEntries.isEmpty()) {
            return Collections.emptySet();
        }

        final Set<AeaaAdvisoryEntry> advisoryEntries = new HashSet<>(baseEntries);
        for (Collection<AeaaAdvisoryEntry> advisory : advisories) {
            if (advisory == null) {
                continue;
            }
            advisoryEntries.removeAll(advisory);
        }

        return advisoryEntries;
    }

    /* OVERVIEW TABLE GENERATION */

    public List<AeaaAdvisoryEntry> getSecurityAdvisories() {
        return vInventory.getSoredSecurityAdvisories();
    }

    public StatisticsOverviewTable generateOverviewTable(List<AeaaVulnerability> vulnerabilities, boolean useEffectiveSeverityScores, AeaaAdvisoryTypeIdentifier<?> filterAdvisory) {
        return StatisticsOverviewTable.buildTable(this.securityPolicy, vulnerabilities, filterAdvisory, useEffectiveSeverityScores);
    }

    public StatisticsOverviewTable generateOverviewTable(List<AeaaVulnerability> vulnerabilities, boolean useEffectiveSeverityScores, String filterAdvisory) {
        return StatisticsOverviewTable.buildTableStrFilterAdvisor(this.securityPolicy, vulnerabilities, filterAdvisory, useEffectiveSeverityScores);
    }

    /* CVSS */

    public StatisticsOverviewTable generateOverviewTable(List<AeaaVulnerability> vulnerabilities, boolean useEffectiveSeverityScores, String filterAdvisory, String vulnerabilityStatusMapper) {
        final JSONObject securityPolicyJson = new JSONObject(this.securityPolicy.getProperties());
        final CentralSecurityPolicyConfiguration clonedSecurityPolicy = new CentralSecurityPolicyConfiguration();
        clonedSecurityPolicy.setProperties(new LinkedHashMap<>(securityPolicyJson.toMap()));
        clonedSecurityPolicy.setVulnerabilityStatusDisplayMapper(vulnerabilityStatusMapper);

        return StatisticsOverviewTable.buildTableStrFilterAdvisor(clonedSecurityPolicy, vulnerabilities, filterAdvisory, useEffectiveSeverityScores);
    }

    public CvssSeverityRanges.SeverityRange getSeverityForVectorScore(double score) {
        return securityPolicy.getCvssSeverityRanges().getRange(score);
    }

    /**
     * Performs several operations on a source string from the CVSS vector:
     * <ul>
     *     <li>Transforms <code>Assessment-all</code>, <code>Assessment-higher</code> and <code>Assessment-lower</code> into <code>Assessment</code></li>
     *     <li>Removes any trailing duplicate <code>+ Assessment</code> from the string</li>
     * </ul>
     * Example:
     * <pre>
     *     NVD-CNA-NVD --&gt; NVD-CNA-NVD
     *     NVD-CNA-NVD + Assessment + Assessment --&gt; NVD-CNA-NVD + Assessment
     *     NVD-CNA-NVD + Assessment-all + Assessment-lower --&gt; NVD-CNA-NVD + Assessment
     * </pre>
     *
     * @param combinedSourceString The combined source string obtained via {@link org.metaeffekt.core.security.cvss.CvssSource#toCombinedColumnHeaderString(Collection)}
     * @return The post-processed source string
     */
    public String postProcessCvssSource(String combinedSourceString) {
        if (StringUtils.isBlank(combinedSourceString)) {
            return "unknown";
        }

        if (combinedSourceString.contains(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_ALL.getName())) {
            combinedSourceString = combinedSourceString.replace(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_ALL.getName(), KnownCvssEntities.ASSESSMENT.getName());
        }
        if (combinedSourceString.contains(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_HIGHER.getName())) {
            combinedSourceString = combinedSourceString.replace(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_HIGHER.getName(), KnownCvssEntities.ASSESSMENT.getName());
        }
        if (combinedSourceString.contains(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_LOWER.getName())) {
            combinedSourceString = combinedSourceString.replace(KnownCvssEntities.ASSESSMENT.getName() + "-" + KnownCvssEntities.ASSESSMENT_LOWER.getName(), KnownCvssEntities.ASSESSMENT.getName());
        }

        while (combinedSourceString.endsWith(" + " + KnownCvssEntities.ASSESSMENT.getName() + " + " + KnownCvssEntities.ASSESSMENT.getName())) {
            combinedSourceString = combinedSourceString.substring(0, combinedSourceString.length() - (" + " + KnownCvssEntities.ASSESSMENT.getName()).length());
        }

        return combinedSourceString;
    }

    public boolean hasTemporalScore(CvssVector... vectors) {
        for (CvssVector vector : vectors) {
            if (vector instanceof MultiScoreCvssVector && !Double.isNaN(vector.getBakedScores().getTemporalScore())) {
                return true;
            }
        }
        return false;
    }

    public boolean hasEnvironmentalScore(CvssVector... vectors) {
        for (CvssVector vector : vectors) {
            if (vector instanceof MultiScoreCvssVector && !Double.isNaN(vector.getBakedScores().getEnvironmentalScore())) {
                return true;
            }
        }
        return false;
    }

    /* MICROSOFT UTILITIES */

    public boolean hasAdjustedImpactScore(CvssVector... vectors) {
        for (CvssVector vector : vectors) {
            if (vector instanceof MultiScoreCvssVector && !Double.isNaN(vector.getBakedScores().getAdjustedImpactScore())) {
                return true;
            }
        }
        return false;
    }

    protected Map<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> getMsrcAdvisorEntriesWithRemediationInformation(AeaaVulnerability vulnerability, Collection<Artifact> artifacts) {
        if (vulnerability == null) {
            return Collections.emptyMap();
        }

        final Map<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> result = new LinkedHashMap<>();

        for (AeaaMsrcAdvisorEntry securityAdvisory : vulnerability.getRelatedAdvisorsOfSource(AeaaAdvisoryTypeStore.MSRC, AeaaMsrcAdvisorEntry.class)) {
            for (AeaaMsrcRemediation msRemediation : securityAdvisory.getMsRemediations()) {
                final Set<String> affectedProductIds = msRemediation.getAffectedProductIds();
                boolean found = false;
                for (Artifact artifact : artifacts) {
                    final Set<String> productIds = getMsrcProductIdsForArtifact(artifact);
                    for (String productId : productIds) {
                        if (affectedProductIds.contains(productId)) {
                            result.computeIfAbsent(securityAdvisory, k -> new ArrayList<>()).add(msRemediation);
                            found = true;
                            break;
                        }
                    }
                }
                if (found) {
                    break;
                }
            }
        }

        return result;
    }

    public boolean hasVulnerabilityMicrosoftRemediationInformationOnArtifact(AeaaVulnerability vulnerability, Collection<Artifact> artifacts) {
        return !getMsrcAdvisorEntriesWithRemediationInformation(vulnerability, artifacts).isEmpty();
    }

    public Map<String, String> getMicrosoftRemediationUrlAndDescriptionForVulnerabilityOnArtifact(AeaaVulnerability vulnerability, Artifact artifact) {
        final Map<String, String> result = new LinkedHashMap<>();
        final Set<String> knownKbIds = new HashSet<>();

        final Map<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> remediationEntriesMap = getMsrcAdvisorEntriesWithRemediationInformation(vulnerability, Collections.singletonList(artifact));

        for (Map.Entry<AeaaMsrcAdvisorEntry, List<AeaaMsrcRemediation>> entry : remediationEntriesMap.entrySet()) {
            final List<AeaaMsrcRemediation> remediations = entry.getValue();
            for (AeaaMsrcRemediation remediation : remediations) {
                final AeaaReference url = remediation.getUrl();
                final String description = remediation.getDescription();
                result.put(url.getUrl(), description);
                knownKbIds.add(description);
            }
        }

        final List<String> kbRemediations = getMicrosoftRemediationKBsForVulnerabilityOnArtifact(vulnerability, artifact);
        for (String kb : kbRemediations) {
            if (!knownKbIds.contains(kb)) {
                result.put("https://support.microsoft.com/en-us/help/" + kb, kb);
            }
        }

        return result;
    }

    public List<String> getMicrosoftRemediationKBsForVulnerabilityOnArtifact(AeaaVulnerability vulnerability, Artifact artifact) {
        final String msFixingKbIdentifiers = vulnerability.getAdditionalAttribute(AeaaInventoryAttribute.MS_FIXING_KB_IDENTIFIER);
        final JSONObject fixingKbIds = StringUtils.isNotBlank(msFixingKbIdentifiers) ? new JSONObject(msFixingKbIdentifiers) : new JSONObject();
        final Set<String> artifactProductIds = getMsrcProductIdsForArtifact(artifact);

        final List<String> result = new ArrayList<>();
        for (String productId : artifactProductIds) {
            final JSONArray kbIds = fixingKbIds.optJSONArray(productId);
            if (kbIds != null) {
                for (int i = 0; i < kbIds.length(); i++) {
                    final String kbId = kbIds.optString(i);
                    if (StringUtils.isNotBlank(kbId)) {
                        result.add(kbId);
                    }
                }
            }
        }

        return result.stream().sorted().distinct().collect(Collectors.toList());
    }

    /* VULNERABILITY STATUS */

    public Set<String> getMsrcProductIdsForArtifact(Artifact artifact) {
        if (artifact == null) {
            return Collections.emptySet();
        }
        if (artifact.get(AeaaInventoryAttribute.MS_PRODUCT_ID) == null) {
            return Collections.emptySet();
        }
        return Arrays.stream(artifact.get(AeaaInventoryAttribute.MS_PRODUCT_ID).split(", ")).collect(Collectors.toSet());
    }

    public String getBaseVulnerabilityStatus(AeaaVulnerability vulnerability) {
        final AeaaVulnerabilityStatus status = vulnerability.getOrCreateNewVulnerabilityStatus();
        final AeaaVulnerabilityStatusHistoryEntry latest = status.getLatestActiveStatusHistoryEntry();

        return latest == null || StringUtils.isBlank(latest.getStatus()) ? "in review" : latest.getStatus();
    }

    protected String getMappedVulnerabilityStatus(AeaaVulnerability vulnerability) {
        final AeaaVulnerabilityStatus status = vulnerability.getOrCreateNewVulnerabilityStatus();

        final AeaaVulnerabilityStatusHistoryEntry latest = status.getLatestActiveStatusHistoryEntry();
        final String latestStatus = latest == null || StringUtils.isBlank(latest.getStatus()) ? null : latest.getStatus();

        return securityPolicy.getVulnerabilityStatusDisplayMapper().getMapper().apply(latestStatus);
    }

    public List<String> getVulnerabilityStatusLabels(AeaaVulnerability vulnerability) {
        final String baseStatus = getBaseVulnerabilityStatus(vulnerability);
        final String mappedStatus = getMappedVulnerabilityStatus(vulnerability);

        final List<String> labels = new ArrayList<>();

        if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW)) {
            labels.add("In Review");
        } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE)) {
            labels.add("Applicable");
        } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE)) {
            labels.add("Not Applicable");
        } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT)) {
            labels.add("Insignificant");
        } else if (baseStatus.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_VOID) || baseStatus.equalsIgnoreCase("unset")) { // when would the value be "unset"?
            labels.add("Void Vulnerability");
        } else {
            labels.add("In Review");
        }

        // priority score
        final AeaaVulnerabilityPriorityCalculator.AeaaPriorityScoreResult priorityScore = vulnerability.calculatePriorityScore(this.securityPolicy);
        if (priorityScore.isElevated()) {
            labels.add("priority-severity-" + priorityScore.getResultingSeverityRange().getName());
        } else {
            labels.add("priority-severity-standard");
        }

        return labels;
    }

    public Map<String, String> getVulnerabilityStatusByCategory(AeaaVulnerability vulnerability) {
        Map<String, String> vulnerabilityMap = new HashMap<>();
        List<String> vulnerabilityStatusList = getVulnerabilityStatusLabels(vulnerability);

        for (String label : vulnerabilityStatusList) {
            if (label.contains("priority-severity")) {
                vulnerabilityMap.put("priority-score", label);
            } else {
                vulnerabilityMap.put("status", label);
            }
        }

        if (shouldDisplayEffectiveVulnerabilityStatusCvssSeverity(vulnerability)) {
            CvssVector cvssVector = vulnerability.getCvssSelectionResult().getSelectedContextIfAvailableOtherwiseInitial();
            if (cvssVector != null) {
                vulnerabilityMap.put("priority-score-context", getSeverityForVectorScore(cvssVector.getOverallScore()).getName());
            }
        }
        return vulnerabilityMap;
    }

    /**
     * Sorts a list of vulnerabilities from highest to lowest by their severity score.
     * @param vulnerabilities The list of vulnerabilities.
     * @return The sorted list.
     */
    public List<AeaaVulnerability> sortVulnerabilitesBySeverity(List<AeaaVulnerability> vulnerabilities) {
        return vulnerabilities.stream()
                .sorted(Comparator.comparing(
                        v -> Optional.ofNullable(v)
                                .map(AeaaVulnerability::getCvssSelectionResult)
                                .map(CvssSelectionResult::getSelectedInitialCvss)
                                .map(CvssVector::getOverallScore)
                                .orElse(0.0),
                        Comparator.reverseOrder()))
                .collect(Collectors.toList());
    }

    public boolean shouldDisplayEffectiveVulnerabilityStatusCvssSeverity(AeaaVulnerability vulnerability) {
        final String status = getMappedVulnerabilityStatus(vulnerability);

        // if the status is not (not applicable, void), then display the severity
        return !status.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE) && !status.equalsIgnoreCase(VulnerabilityMetaData.STATUS_VALUE_VOID);
    }

    public Map<DisplayStatusData, List<AeaaVulnerability>> getVulnerabilitiesByEffectiveStatus(List<AeaaVulnerability> vulnerabilities) {
        final Map<DisplayStatusData, List<AeaaVulnerability>> result = new LinkedHashMap<>();

        // add all categories no matter what from the security policy
        final List<String> allStatuses = securityPolicy.getVulnerabilityStatusDisplayMapper().getStatusNames();
        for (String status : allStatuses) {
            result.put(new DisplayStatusData(status), new ArrayList<>());
        }

        for (AeaaVulnerability vulnerability : vulnerabilities) {
            final String status = getMappedVulnerabilityStatus(vulnerability);
            result.computeIfAbsent(new DisplayStatusData(status), k -> new ArrayList<>()).add(vulnerability);
        }

        final List<String> baseStatusNames = CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_UNMODIFIED.getStatusNames();
        result.values().forEach(vulns -> vulns.sort((o1, o2) -> {
            final String status1 = getBaseVulnerabilityStatus(o1);
            final String status2 = getBaseVulnerabilityStatus(o2);
            final int index1 = baseStatusNames.indexOf(status1);
            final int index2 = baseStatusNames.indexOf(status2);
            final int status = Integer.compare(index1, index2);

            if (status != 0) {
                return status;
            }

            final CvssVector cvssVector1 = o1.getCvssSelectionResult().getSelectedContextIfAvailableOtherwiseInitial();
            final CvssVector cvssVector2 = o2.getCvssSelectionResult().getSelectedContextIfAvailableOtherwiseInitial();

            if (cvssVector1 == null && cvssVector2 == null) {
                return 0;
            } else if (cvssVector1 == null) {
                return 1;
            } else if (cvssVector2 == null) {
                return -1;
            } else {
                return Double.compare(cvssVector2.getOverallScore(), cvssVector1.getOverallScore());
            }
        }));

        return result;
    }

    /* COMPONENTS */

    public List<String> getComponentsFromInventory() {
        return inventory.getArtifacts().stream().map(Artifact::getComponent).distinct().collect(Collectors.toList());
    }

    public List<Artifact> getArtifactsForComponent(String component) {
        if (component == null) {
            return Collections.emptyList();
        }
        return inventory.getArtifacts().stream()
                .filter(a -> a.getComponent() != null && a.getComponent().equals(component))
                .collect(Collectors.toList());
    }

    /* ASSETS */

    public List<String> getAssetsFromInventory() {
        return inventory.getAssetMetaData().stream().map(a -> a.get(Constants.KEY_ASSET_ID))
                .collect(Collectors.toList());
    }

    public List<AssetMetaData> getAssetsForComponent(String component) {
        if (StringUtils.isBlank(component)) {
            return Collections.emptyList();
        }
        return inventory.getAssetMetaData().stream().filter(a -> a.get(Constants.KEY_ASSET_ID).equals(component))
                .collect(Collectors.toList());
    }

    /**
     * Returns a list of assets for which the give artifacts are contained in. If there is a primary asset in the list,
     * only the primary is returned. If there is no primary, all related assets are returned.
     * @param artifacts the artifacts for which to find the related assets
     * @return the list of related assets
     */
    public Set<AssetMetaData> getAffectedAssets(Set<Artifact> artifacts) {
        Set<AssetMetaData> assets = InventoryUtils.getAssetsForArtifacts(inventory, artifacts);
        if (!assets.isEmpty()) {
            Set<AssetMetaData> primaries = assets.stream().filter(a -> a != null
                    && a.get(Constants.KEY_PRIMARY) != null
                    && Constants.MARKER_CROSS.equals(a.get(Constants.KEY_PRIMARY))).collect(Collectors.toSet());
            if (!primaries.isEmpty()) {
                return primaries;
            } else {
                return assets;
            }
        }
        return Collections.emptySet();
    }



    /* MATCHING SOURCES */

    public List<String> vulnerabilityMatchingSourceLabelsForOverview(AeaaVulnerability vulnerability) {
        final List<String> result = new ArrayList<>();

        for (AeaaDataSourceIndicator matchingSource : vulnerability.getMatchingSources()) {
            final AeaaDataSourceIndicator.Reason matchReason = matchingSource.getMatchReason();
            final AeaaContentIdentifierStore.AeaaContentIdentifier provider = matchingSource.getDataSource();

            if (matchReason instanceof AeaaDataSourceIndicator.ArtifactCpeReason) {
                final AeaaDataSourceIndicator.ArtifactCpeReason artifactCpeReason = ((AeaaDataSourceIndicator.ArtifactCpeReason) matchReason);
                final String matchedConfiguration = artifactCpeReason.getConfiguration();
                final String cpe = artifactCpeReason.getCpe();

                if (StringUtils.isNotBlank(matchedConfiguration)) {
                    result.add(matchedConfiguration);
                } else if (StringUtils.isNotBlank(cpe)) {
                    result.add(cpe);
                } else {
                    result.add("CPE not available");
                }

            } else if (matchReason instanceof AeaaDataSourceIndicator.MsrcProductReason) {
                final AeaaDataSourceIndicator.MsrcProductReason msrcProductReason = ((AeaaDataSourceIndicator.MsrcProductReason) matchReason);
                result.add("MS " + msrcProductReason.getMsrcProductId());

            } else if (matchReason instanceof AeaaDataSourceIndicator.AssessmentStatusReason) {
                final AeaaDataSourceIndicator.AssessmentStatusReason assessmentStatusReason = ((AeaaDataSourceIndicator.AssessmentStatusReason) matchReason);
                // result.add("Assessment " + assessmentStatusReason.getOriginFileName());
                result.add("Assessment " + vulnerability.getId());

            } else if (matchReason instanceof AeaaDataSourceIndicator.ArtifactGhsaReason) {
                final AeaaDataSourceIndicator.ArtifactGhsaReason artifactGhsaReason = ((AeaaDataSourceIndicator.ArtifactGhsaReason) matchReason);
                final String coordinates = artifactGhsaReason.getCoordinates();
                if (coordinates != null) {
                    result.add("GHSA " + coordinates);
                } else {
                    result.add("GHSA");
                }

            } else if (matchReason instanceof AeaaDataSourceIndicator.ArtifactOsvReason) {
                final AeaaDataSourceIndicator.ArtifactOsvReason artifactOsvReason = ((AeaaDataSourceIndicator.ArtifactOsvReason) matchReason);
                final String coordinates = artifactOsvReason.getCoordinates();
                if (coordinates != null) {
                    result.add("OSV " + coordinates);
                } else {
                    result.add("OSV");
                }

            } else if (matchReason instanceof AeaaDataSourceIndicator.AnyArtifactOverwriteSourceReason) {
                final AeaaDataSourceIndicator.AnyArtifactOverwriteSourceReason reason = ((AeaaDataSourceIndicator.AnyArtifactOverwriteSourceReason) matchReason);
                if (reason.overwriteSource() != null) {
                    result.add(reason.overwriteSource() + " (" + reason.getArtifactId() + ")");
                } else {
                    result.add(reason.getArtifactId());
                }

            } else if (matchReason instanceof AeaaDataSourceIndicator.AnyArtifactReason) {
                final AeaaDataSourceIndicator.AnyArtifactReason anyArtifactReason = ((AeaaDataSourceIndicator.AnyArtifactReason) matchReason);
                result.add(anyArtifactReason.getArtifactId());

            } else if (matchReason instanceof AeaaDataSourceIndicator.AnyReason) {
                final AeaaDataSourceIndicator.AnyReason anyReason = ((AeaaDataSourceIndicator.AnyReason) matchReason);
                result.add(anyReason.getDescription());

            } else {

                if (provider == AeaaAdvisoryTypeStore.GHSA) {
                    result.add("GHSA " + vulnerability.getId());
                } else if (AeaaAdvisoryTypeStore.get().osvValues().contains(provider)) {
                    result.add("OSV " + vulnerability.getId());
                } else {
                    result.add(matchReason.toString());
                }
            }
        }

        return result.stream().distinct().collect(Collectors.toList());
    }

    public List<String> splitVulnerabilityMatchingSourcesIntoMultipleLines(List<String> inputLines, int lineLengthStart, int lineLengthEnd) {
        final List<List<String>> outputLines = new ArrayList<>();

        for (Iterator<String> iterator = inputLines.iterator(); iterator.hasNext(); ) {
            final String line = iterator.next();
            final List<String> splitLines = new ArrayList<>();

            if (line.length() <= lineLengthEnd) {
                splitLines.add(line);
            } else {
                splitLines.addAll(splitLine(line, lineLengthStart, lineLengthEnd));
            }
            outputLines.add(splitLines);

            if (iterator.hasNext()) {
                outputLines.add(Collections.singletonList(""));
            }
        }

        return outputLines.stream().flatMap(Collection::stream).collect(Collectors.toList());
    }

    private List<String> splitLine(String line, int minLength, int maxLength) {
        final List<String> result = new ArrayList<>();
        while (line.length() > maxLength) {
            int splitIndex = findSplitIndex(line, minLength, maxLength);
            result.add(line.substring(0, splitIndex).trim());
            line = line.substring(splitIndex).trim();
        }
        result.add(line);
        return result;
    }

    private int findSplitIndex(String line, int minLength, int maxLength) {
        // try to split at natural breakpoints first
        int splitIndex = -1;

        // try to split at space
        for (int i = maxLength; i >= minLength; i--) {
            char c = line.charAt(i);
            if (c == ' ') {
                splitIndex = i;
                break;
            }
        }
        if (splitIndex != -1) {
            return splitIndex;
        }

        // then try to split at punctuation
        for (int i = maxLength; i >= minLength; i--) {
            char c = line.charAt(i);
            if (c == '.' || c == ',' || c == '-' || c == '_' || c == '/' || c == '\\' || c == ':') {
                // include punctuation
                splitIndex = i + 1;
                break;
            }
        }
        if (splitIndex != -1) {
            return splitIndex;
        }


        // if no natural breakpoint found, force split at maxLength
        return maxLength;
    }

    /* KEV */
    public int totalOfKevEntries() {
        return (int) getEffectiveVulnerabilitiesAll().stream().filter(e -> e.getKevData() != null).count();
    }

    public int totalOfNotKevEntries() {
        return (int) getEffectiveVulnerabilitiesAll().stream().filter(e -> e.getKevData() == null).count();
    }

    public float percentageOfKev() {
        int totalKev = totalOfKevEntries() + totalOfNotKevEntries();
        return Math.round(((float) totalOfKevEntries() / totalKev) * 100);
    }

    public float percentageOfNotKev() {
        return 100F - percentageOfKev();
    }

    /* ADVISORIES */

    public String getAdvisoryHeader() {
        final List<String> includeAdvisoryTypes = securityPolicy.getIncludeAdvisoryTypes();

        if (includeAdvisoryTypes == null || includeAdvisoryTypes.isEmpty() || CentralSecurityPolicyConfiguration.containsAny(includeAdvisoryTypes)) {
            return "Alerts / Notices / Updates";
        }

        final StringBuilder sb = new StringBuilder();

        if (includeAdvisoryTypes.contains("alert")) {
            sb.append("Alerts");
        }
        if (includeAdvisoryTypes.contains("notice")) {
            if (sb.length() > 0) {
                sb.append(" / ");
            }
            sb.append("Notices");
        }
        if (includeAdvisoryTypes.contains("news")) {
            if (sb.length() > 0) {
                sb.append(" / ");
            }
            sb.append("Updates");
        }

        return sb.toString();
    }

    public String getAdvisorPeriodicQueryPeriod() {
        // cert-periodic-query
        // Range End	Range Start
        // 2023-11-29	2023-06-01
        final InventoryInfo periodInfo = this.inventory.findInventoryInfo("cert-periodic-query");
        if (periodInfo == null) {
            return null;
        }

        final String rangeEnd = periodInfo.get("Range End");
        final String rangeStart = periodInfo.get("Range Start");
        if (rangeEnd == null || rangeStart == null) {
            return null;
        }

        return rangeStart + " - " + rangeEnd;
    }

    public List<AeaaAdvisoryEntry> filterSecurityAdvisoriesForReviewStatus(List<AeaaAdvisoryEntry> securityAdvisories, String status) {
        if (securityAdvisories == null) {
            return Collections.emptyList();
        }

        return securityAdvisories.stream()
                .filter(a -> a.getAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS) != null)
                .filter(a -> a.getAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS).equalsIgnoreCase(status))
                .collect(Collectors.toList());
    }

    /* COMPONENTS / ARTIFACTS */

    public List<AeaaVulnerability> getVulnerabilitiesForArtifact(Artifact artifact) {
        if (artifact == null) {
            return Collections.emptyList();
        }
        return this.getEffectiveVulnerabilitiesAll().stream()
                .filter(v -> v.getAffectedArtifactsByDefaultKey().contains(artifact))
                .collect(Collectors.toList());
    }

    public List<AeaaVulnerability> getVulnerabilitiesForComponent(String component) {
        if (component == null) {
            return Collections.emptyList();
        }
        return this.getArtifactsForComponent(component).stream()
                .flatMap(a -> getVulnerabilitiesForArtifact(a).stream())
                .distinct()
                .collect(Collectors.toList());
    }

    /* ASSETS */
    public List<AeaaVulnerability> getVulnerabilitiesForAsset(AssetMetaData assetMetaData) {
        if (assetMetaData == null) {
            return Collections.emptyList();
        }
        List<AeaaVulnerability> assetVulnerabilities = new ArrayList<>();
        for (Artifact artifact : InventoryUtils.getArtifactsForAsset(inventory,assetMetaData)) {
            assetVulnerabilities.addAll(getVulnerabilitiesForArtifact(artifact));
        }
        return assetVulnerabilities;
    }

    /* PRIORITY SCORE */

    public String getPriorityVulnerabilityStatusReasoning(AeaaVulnerabilityPriorityCalculator.AeaaPriorityScoreResult priorityScoreResult) {
        if (priorityScoreResult.getCalculator().getVulnerabilityStatus() == null || StringUtils.isEmpty(priorityScoreResult.getCalculator().getVulnerabilityStatus().getStatus())) {
            return "No vulnerability status available.";
        }

        final String status = priorityScoreResult.getCalculator().getVulnerabilityStatus().getStatus();

        return "The vulnerability status is <b>" + status + "</b>.";
    }

    public VrEolDisplayInformation getEolReasoning(AeaaVulnerabilityPriorityCalculator.AeaaPriorityScoreResult priorityScoreResult) {
        if (priorityScoreResult.getCalculator().getEolData() == null || priorityScoreResult.getCalculator().getEolData().isEmpty() || priorityScoreResult.getSelectedEolData() == null) {
            return null;
        }

        final AeaaExportedCycleState cycleState = priorityScoreResult.getSelectedEolData();
        final String product = cycleState.getCycle().getProduct();
        final String version = cycleState.getCycle().getCycle();
        final String supportStatus;
        final String regularSupportEndDate = AeaaEolCycle.formatTimeUntilOrAgo(cycleState.getSupportMillis());
        final String extendedSupportEndDate = AeaaEolCycle.formatTimeUntilOrAgo(cycleState.getExtendedSupportMillis());

        if (cycleState.getCycleStateScenario() == AeaaCycleStateScenario.EXTENDED_SUPPORT_NOT_PRESENT) {
            final AeaaCycleStateExtendedSupportInformationNotPresent info = cycleState.getCycleStateExtendedSupportInformationNotPresent();
            switch (info) {
                case SUPPORT_VALID:
                    supportStatus = "is still supported by it's vendor";
                    break;
                case SUPPORT_ENDING_SOON:
                    supportStatus = "is still supported by it's vendor, but <b>support will be ending soon</b>";
                    break;
                case SUPPORT_EXPIRED:
                    supportStatus = "<b>is no longer supported by it's vendor</b>";
                    break;
                default:
                    supportStatus = "<i>unknown</i>";
            }
        } else {
            final AeaaCycleStateExtendedSupportInformationPresent info = cycleState.getCycleStateExtendedSupportInformationPresent();
            switch (info) {
                case SUPPORT_VALID:
                    supportStatus = "is still supported by it's vendor";
                    break;
                case SUPPORT_ENDING_SOON:
                    supportStatus = "is still supported by it's vendor, but <b>regular support will be ending soon</b> and extended support will be starting";
                    break;
                case EXTENDED_SUPPORT_VALID:
                    supportStatus = "is still supported by it's vendor with extended support";
                    break;
                case EXTENDED_SUPPORT_ENDING_SOON:
                    supportStatus = "is still supported by it's vendor with extended support, but <b>extended support will be ending soon</b>";
                    break;
                case EXTENDED_SUPPORT_EXPIRED:
                    supportStatus = "<b>is no longer supported by it's vendor</b>";
                    break;
                default:
                    supportStatus = "<i>unknown</i>";
            }
        }

        return new VrEolDisplayInformation(
                product, version, InventoryReport.xmlEscapeContentString("https://endoflife.date/" + product),
                supportStatus,
                "Support End Date: " + regularSupportEndDate,
                cycleState.getCycleStateScenario() == AeaaCycleStateScenario.EXTENDED_SUPPORT_INFORMATION_PRESENT ? "Extended Support End Date: " + extendedSupportEndDate : "Vendor does not provide extended support for this product."
        );
    }

    public FormattedTime getInventoryEnrichmentFirstStepTime() {
        return getInventoryEnrichmentStepTime(x -> 0, JSONArray::length);
    }

    /* PROPERTIES FILE */

    public FormattedTime getInventoryEnrichmentLatestStepTime() {
        return getInventoryEnrichmentStepTime(x -> x.length() - 1, x -> -1);
    }

    private FormattedTime getInventoryEnrichmentStepTime(Function<JSONArray, Integer> startIndex, Function<JSONArray, Integer> endIndex) {
        final InventoryInfo enrichmentInfo = this.inventory.findInventoryInfo("inventory-enrichment");
        if (enrichmentInfo == null) {
            return FormattedTime.EMPTY;
        }

        final String rawSteps = enrichmentInfo.get("Steps");
        if (StringUtils.isEmpty(rawSteps) || !rawSteps.startsWith("[")) {
            return FormattedTime.EMPTY;
        }

        final JSONArray steps = new JSONArray(rawSteps);
        if (steps.isEmpty()) {
            return FormattedTime.EMPTY;
        }

        // first may not contain the "time" key for whatever reason
        final int start = startIndex.apply(steps);
        final int end = endIndex.apply(steps);
        final boolean ascending = start < end;
        if (ascending) {
            for (int i = start; i < end; i++) {
                final JSONObject step = steps.getJSONObject(i);
                if (step.has("time")) {
                    return new FormattedTime(step.getLong("time"));
                }
            }
        } else {
            for (int i = start; i > end; i--) {
                final JSONObject step = steps.getJSONObject(i);
                if (step.has("time")) {
                    return new FormattedTime(step.getLong("time"));
                }
            }
        }

        return FormattedTime.EMPTY;
    }

    public String formatDate(Date date) {
        return AeaaTimeUtils.formatNormalizedDate(date);
    }

    public String formatDate(long date) {
        return AeaaTimeUtils.formatNormalizedDate(new Date(date));
    }

    /* GENERAL TIME */

    public VulnerabilitySummaryData getVulnerabilitySummaryData() {
        return new VulnerabilitySummaryData(this.vInventory, this.getEffectiveVulnerabilitiesAll(), this.securityPolicy);
    }

    public boolean notNull(Object input) {
        return input != null;
    }

    /* OTHER ADAPTERS */

    public boolean notEmpty(String string) {
        return StringUtils.isNotBlank(string);
    }

    /* OTHER UTILITIES */

    public boolean fileExists(String path) {
        if (path == null) {
            return false;
        }
        return new File(path).exists();
    }

    public static class DisplayStatusData {
        private final static Set<String> STATUS_VALUES_WITHOUT_CVSS = new HashSet<>(Arrays.asList(
                VulnerabilityMetaData.STATUS_VALUE_VOID,
                VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE,
                "not affected"
        ));
        private final String normalized;
        private final String capitalized;
        private final String asXmlId;

        public DisplayStatusData(String input) {
            this.normalized = input.toLowerCase();
            this.capitalized = StatisticsOverviewTable.capitalizeWords(normalized);
            this.asXmlId = InventoryReport.xmlEscapeStringAttribute(normalized);
        }

        public String getNormalized() {
            return normalized;
        }

        public String getCapitalized() {
            return capitalized;
        }

        public String getAsXmlId() {
            return asXmlId;
        }

        public boolean shouldModifiedCvssBeDisplayed() {
            return !STATUS_VALUES_WITHOUT_CVSS.contains(normalized);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            DisplayStatusData that = (DisplayStatusData) o;
            return Objects.equals(normalized, that.normalized) && Objects.equals(capitalized, that.capitalized) && Objects.equals(asXmlId, that.asXmlId);
        }

        @Override
        public int hashCode() {
            return Objects.hash(normalized, capitalized, asXmlId);
        }
    }

    @Data
    public static class VrEolDisplayInformation {
        private final String product;
        private final String version;
        private final String escapedLink;
        private final String supportStatus;
        private final String regularSupportEndInfo;
        private final String extendedSupportEndInfo;
    }

    @Getter
    public static class FormattedTime {
        private final static SimpleDateFormat EN_FORMAT = new SimpleDateFormat("dd/MM/yyyy HH:mm");
        private final static SimpleDateFormat DE_FORMAT = new SimpleDateFormat("dd.MM.yyyy HH:mm");
        private final static FormattedTime EMPTY = new FormattedTime(0);
        private final long time;
        private final String en; // 31/12/2024 hh:mm
        private final String de; // 31.12.2024 hh:mm

        public FormattedTime(long time) {
            this.time = time;
            this.en = EN_FORMAT.format(new Date(time));
            this.de = DE_FORMAT.format(new Date(time));
        }
    }
}
