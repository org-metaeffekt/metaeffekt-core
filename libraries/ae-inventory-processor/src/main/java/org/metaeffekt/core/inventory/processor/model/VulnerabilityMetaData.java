/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.model;

import org.apache.commons.lang3.StringUtils;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Objects;

public class VulnerabilityMetaData extends AbstractModelBase {

    // Maximize compatibility with serialized inventories
    private static final long serialVersionUID = 1L;

    public static final String STATUS_VALUE_IN_REVIEW = "in review";
    public static final String STATUS_VALUE_APPLICABLE = "applicable";
    public static final String STATUS_VALUE_NOTAPPLICABLE = "not applicable";
    public static final String STATUS_VALUE_INSIGNIFICANT = "insignificant";
    public static final String STATUS_VALUE_VOID = "void";

    public static final String VULNERABILITY_ASSESSMENT_CONTEXT_DEFAULT = "default";

    public final static Comparator<VulnerabilityMetaData> VULNERABILITY_COMPARATOR_OVERALL_SCORE =
            (o1, o2) -> Float.compare(o2.getFloat("CVSS Unmodified Overall (max)", 0),
                    o1.getFloat("CVSS Unmodified Overall (max)", 0));

    public static Comparator<VulnerabilityMetaData> VULNERABILITY_COMPARATOR_DESC = (vmdLeft, vmdRight) -> {
        float scoreLeft = vmdLeft.getFloat(Attribute.SCORE_CONTEXT_OVERALL, 0f);
        float scoreRight = vmdRight.getFloat(Attribute.SCORE_CONTEXT_OVERALL, 0f);

        // we need to be careful with comparator contract violations
        return (int) -(100 * scoreLeft - 100 * scoreRight);
    };

    public static Comparator<VulnerabilityMetaData> VULNERABILITY_COMPARATOR_NAME_DESC =
            (vmdLeft, vmdRight) -> -Objects.compare(
                    vmdLeft.get(Attribute.NAME),
                    vmdRight.get(Attribute.NAME),
                    String.CASE_INSENSITIVE_ORDER);

    public VulnerabilityMetaData(VulnerabilityMetaData vmd) {
        super(vmd);
    }

    public VulnerabilityMetaData() {
    }

    /**
     * Core attributes to support vulnerabilities.
     */
    public enum Attribute implements AbstractModelBase.Attribute {
        NAME("Name"),
        URL("Url"),

        SCORE_INITIAL_OVERALL("CVSS Initial Overall"),
        SCORE_CONTEXT_OVERALL("CVSS Context Overall"),
        SCORE_INITIAL_OVERALL_SEVERITY("CVSS Initial Overall Severity"),
        SCORE_CONTEXT_OVERALL_SEVERITY("CVSS Context Overall Severity"),
        SCORE_BASE("CVSS Initial Base"),
        SCORE_EXPLOITABILITY("CVSS Initial Exploitability"),
        SCORE_IMPACT("CVSS Initial Impact"),
        // toJson variants of the selected cvss vectors
        SCORE_INITIAL_SELECTION("CVSS Initial Selection"),
        SCORE_CONTEXT_SELECTION("CVSS Context Selection"),

        CVSS_VECTORS("CVSS Vectors"),

        @Deprecated
        WEAKNESS("Weakness"),
        WEAKNESS_DATA("Weakness Data"),
        CAPEC_DATA("CAPEC Data"),
        PRODUCT_URIS("Product URIs"),
        STATUS("Status"),
        RATIONALE("Rationale"),
        RISK("Risk"),
        SOURCE("Source"),
        SOURCE_IMPLEMENTATION("Source-Implementation"),
        REFERENCED_VULNERABILITIES("Referenced Vulnerabilities"),
        REFERENCED_SECURITY_ADVISORIES("Referenced Advisories"),
        REFERENCED_OTHER("Other Referenced Ids"),
        REFERENCES("References");

        private String key;

        Attribute(String key) {
            this.key = key;
        }

        public static Attribute match(String key) {
            for (Attribute a : values()) {
                if (a.getKey().equalsIgnoreCase(key)) {
                    return a;
                }
            }
            return null;
        }

        public String getKey() {
            return key;
        }
    }

    /**
     * Defines the attributes that must be always present.
     */
    public static ArrayList<String> CORE_ATTRIBUTES = new ArrayList<>();
    static {
        // fix selection and order
        CORE_ATTRIBUTES.add(Attribute.NAME.getKey());
        CORE_ATTRIBUTES.add(Attribute.URL.getKey());
        CORE_ATTRIBUTES.add(Attribute.SCORE_INITIAL_OVERALL.getKey());
        CORE_ATTRIBUTES.add(Attribute.SCORE_CONTEXT_OVERALL.getKey());
        CORE_ATTRIBUTES.add(Attribute.SCORE_INITIAL_OVERALL_SEVERITY.getKey());
        CORE_ATTRIBUTES.add(Attribute.SCORE_CONTEXT_OVERALL_SEVERITY.getKey());
        CORE_ATTRIBUTES.add(Attribute.WEAKNESS.getKey());
        CORE_ATTRIBUTES.add(Attribute.PRODUCT_URIS.getKey());
        CORE_ATTRIBUTES.add(Attribute.STATUS.getKey());
        CORE_ATTRIBUTES.add(Attribute.RATIONALE.getKey());
        CORE_ATTRIBUTES.add(Attribute.RISK.getKey());
    }

    /**
     * Defines the attribute order for the standard attributes.
     */
    public static ArrayList<String> ORDER_ATTRIBUTES = new ArrayList<>();
    static {
        // fix selection and order
        ORDER_ATTRIBUTES.add(Attribute.NAME.getKey());
        ORDER_ATTRIBUTES.add(Attribute.URL.getKey());
        ORDER_ATTRIBUTES.add(Attribute.SCORE_INITIAL_OVERALL.getKey());
        ORDER_ATTRIBUTES.add(Attribute.SCORE_CONTEXT_OVERALL.getKey());
        ORDER_ATTRIBUTES.add(Attribute.SCORE_INITIAL_OVERALL_SEVERITY.getKey());
        ORDER_ATTRIBUTES.add(Attribute.SCORE_CONTEXT_OVERALL_SEVERITY.getKey());
        ORDER_ATTRIBUTES.add(Attribute.SCORE_BASE.getKey());
        ORDER_ATTRIBUTES.add(Attribute.SCORE_EXPLOITABILITY.getKey());
        ORDER_ATTRIBUTES.add(Attribute.SCORE_IMPACT.getKey());
        ORDER_ATTRIBUTES.add(Attribute.WEAKNESS.getKey());
        ORDER_ATTRIBUTES.add(Attribute.PRODUCT_URIS.getKey());
        ORDER_ATTRIBUTES.add(Attribute.STATUS.getKey());
        ORDER_ATTRIBUTES.add(Attribute.RATIONALE.getKey());
        ORDER_ATTRIBUTES.add(Attribute.RISK.getKey());
    }

    /**
     * Validates that the mandatory attributes of a component are set.
     *
     * @return Boolean indicating whether the instance is valid.
     */
    public boolean isValid() {
        if (StringUtils.isEmpty(get(Attribute.NAME))) return false;
        return true;
    }

    /**
     * @return The derived string qualifier for this instance.
     */
    public String deriveQualifier() {
        StringBuilder sb = new StringBuilder();
        sb.append(get(Attribute.NAME));
        return sb.toString();
    }

    /**
     * The compare string representations is built from the core attributes.
     *
     * @return String to compare component patterns.
     */
    public String createCompareStringRepresentation() {
        StringBuilder sb = new StringBuilder();
        for (String attributeKey : CORE_ATTRIBUTES) {
            if (sb.length() > 0) {
                sb.append(":");
            }
            sb.append(get(attributeKey));
        }
        return sb.toString();
    }

    public String get(Attribute attribute, String defaultValue) {
        return get(attribute.getKey(), defaultValue);
    }

    public float getFloat(Attribute attribute, float defaultValue) {
        return getFloat(attribute.getKey(), defaultValue);
    }

    public String get(Attribute attribute) {
        return get(attribute.getKey());
    }

    public void set(Attribute attribute, String value) {
        set(attribute.getKey(), value);
    }

    public void append(Attribute attribute, String value, String delimiter) {
        append(attribute.getKey(), value, delimiter);
    }

    @Deprecated
    public boolean isStatus(String queryStatus) {
        final String status = get(Attribute.STATUS);

        if (!StringUtils.isNotBlank(queryStatus) && !StringUtils.isNotBlank(status)) {
            return true;
        }

        if (!StringUtils.isNotBlank(queryStatus) || !StringUtils.isNotBlank(status)) {
            return false;
        }

        return queryStatus.equalsIgnoreCase(status);
    }

    public String deriveRemark() {
        String weakness = get(Attribute.WEAKNESS, "");
        String rationale = get(Attribute.RATIONALE, "");

        if (StringUtils.isNotBlank(rationale)) {
            return rationale;
        }
        if (StringUtils.isNotBlank(weakness)) {
            return weakness.replaceAll("([a-zA-z0-9]+)\\(", "$1 (");
        }
        return "&lt;no information available&gt;";
    }
}
