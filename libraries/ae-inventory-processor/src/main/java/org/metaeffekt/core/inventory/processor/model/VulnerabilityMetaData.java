/*
 * Copyright 2009-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.model;

import org.apache.commons.lang3.StringUtils;

import java.util.*;
import java.util.stream.Collectors;

public class VulnerabilityMetaData extends AbstractModelBase {

    // Maximize compatibility with serialized inventories
    private static final long serialVersionUID = 1L;

    public static final String STATUS_VALUE_IN_REVIEW = "in review";
    public static final String STATUS_VALUE_APPLICABLE = "applicable";
    public static final String STATUS_VALUE_NOTAPPLICABLE = "not applicable";
    public static final String STATUS_VALUE_INSIGNIFICANT = "insignificant";
    public static final String STATUS_VALUE_VOID = "void";

    public static final String VULNERABILITY_ASSESSMENT_CONTEXT_DEFAULT = "default";

    public final static Comparator<VulnerabilityMetaData> VULNERABILITY_COMPARATOR_OVERALL_SCORE =
            (o1, o2) -> Float.compare(o2.getFloat("CVSS Unmodified Overall (max)", 0),
                    o1.getFloat("CVSS Unmodified Overall (max)", 0));

    public static Comparator<VulnerabilityMetaData> VULNERABILITY_COMPARATOR_DESC = (vmdLeft, vmdRight) -> {
        float scoreLeft = vmdLeft.getFloat(Attribute.MAX_SCORE, 0f);
        float scoreRight = vmdRight.getFloat(Attribute.MAX_SCORE, 0f);

        // we need to be careful with comparator contract violations
        return (int) -(100 * scoreLeft - 100 * scoreRight);
    };

    public static Comparator<VulnerabilityMetaData> VULNERABILITY_COMPARATOR_NAME_DESC =
            (vmdLeft, vmdRight) -> -Objects.compare(
                    vmdLeft.get(Attribute.NAME),
                    vmdRight.get(Attribute.NAME),
                    String.CASE_INSENSITIVE_ORDER);

    public VulnerabilityMetaData(VulnerabilityMetaData vmd) {
        super(vmd);
    }

    public VulnerabilityMetaData() {
    }

    /**
     * Core attributes to support vulnerabilities.
     */
    public enum Attribute implements AbstractModelBase.Attribute {
        NAME("Name"),
        URL("Url"),

        // NOTE: these where recently renamed; the attributed are nevertheless preserved, but implicitly mapped.
        V2_SCORE("CVSS Unmodified Overall (v2)"),
        V3_SCORE("CVSS Unmodified Overall (v3)"),
        MAX_SCORE("CVSS Unmodified Overall (max)"),

        WEAKNESS("Weakness"),
        PRODUCT_URIS("Product URIs"),
        STATUS("Status"),
        RATIONALE("Rationale"),
        RISK("Risk"),
        REFERENCES("References");

        private String key;

        Attribute(String key) {
            this.key = key;
        }

        public static Attribute match(String key) {
            for (Attribute a : values()) {
                if (a.getKey().equalsIgnoreCase(key)) {
                    return a;
                }
            }
            return null;
        }

        public String getKey() {
            return key;
        }
    }

    public static ArrayList<String> CORE_ATTRIBUTES = new ArrayList<>();

    static {
        // fix selection and order
        CORE_ATTRIBUTES.add(Attribute.NAME.getKey());
        CORE_ATTRIBUTES.add(Attribute.URL.getKey());
        CORE_ATTRIBUTES.add(Attribute.V2_SCORE.getKey());
        CORE_ATTRIBUTES.add(Attribute.V3_SCORE.getKey());
        CORE_ATTRIBUTES.add(Attribute.MAX_SCORE.getKey());
        CORE_ATTRIBUTES.add(Attribute.WEAKNESS.getKey());
        CORE_ATTRIBUTES.add(Attribute.PRODUCT_URIS.getKey());
        CORE_ATTRIBUTES.add(Attribute.STATUS.getKey());
        CORE_ATTRIBUTES.add(Attribute.RATIONALE.getKey());
        CORE_ATTRIBUTES.add(Attribute.RISK.getKey());
    }

    /**
     * Validates that the mandatory attributes of a component are set.
     *
     * @return Boolean indicating whether the instance is valid.
     */
    public boolean isValid() {
        if (StringUtils.isEmpty(get(Attribute.NAME))) return false;
        return true;
    }

    /**
     * @return The derived string qualifier for this instance.
     */
    public String deriveQualifier() {
        StringBuilder sb = new StringBuilder();
        sb.append(get(Attribute.NAME));
        return sb.toString();
    }

    /**
     * The compare string representations is built from the core attributes.
     *
     * @return String to compare component patterns.
     */
    public String createCompareStringRepresentation() {
        StringBuilder sb = new StringBuilder();
        for (String attributeKey : CORE_ATTRIBUTES) {
            if (sb.length() > 0) {
                sb.append(":");
            }
            sb.append(get(attributeKey));
        }
        return sb.toString();
    }

    public String get(Attribute attribute, String defaultValue) {
        return get(attribute.getKey(), defaultValue);
    }

    public float getFloat(Attribute attribute, float defaultValue) {
        return getFloat(attribute.getKey(), defaultValue);
    }

    public String get(Attribute attribute) {
        return get(attribute.getKey());
    }

    public void set(Attribute attribute, String value) {
        set(attribute.getKey(), value);
    }

    public void append(Attribute attribute, String value, String delimiter) {
        append(attribute.getKey(), value, delimiter);
    }

    public boolean isStatus(String queryStatus) {
        final String status = get(Attribute.STATUS);

        if (!StringUtils.isNotBlank(queryStatus) && !StringUtils.isNotBlank(status)) {
            return true;
        }

        if (!StringUtils.isNotBlank(queryStatus) || !StringUtils.isNotBlank(status)) {
            return false;
        }

        return queryStatus.equalsIgnoreCase(status);
    }

    /**
     * Filters the given collection of {@link VulnerabilityMetaData} objects to a list of applicable vulnerabilities.
     * Applicable vulnerabilities are those
     * <ul>
     *     <li>with status <code>applicable</code> (not matter which score)</li>
     *     <li>with status none/empty and score &gt;= Threshold (excluding all which have status 'not applicable')</li>
     * </ul>
     *
     * @param vmds      The list to filter.
     * @param threshold The threshold to use for filtering.
     * @return List of remaining {@link VulnerabilityMetaData} instances.
     */
    public static List<VulnerabilityMetaData> filterApplicableVulnerabilities(Collection<VulnerabilityMetaData> vmds, float threshold) {
        return vmds.stream().filter(vmd -> {
            boolean hasStatus = !vmd.isStatus(null);
            boolean isStatusApplicable = vmd.isStatus(STATUS_VALUE_APPLICABLE);
            return isStatusApplicable || (!hasStatus && vmd.getFloat(Attribute.MAX_SCORE, Float.NaN) >= threshold);
        }).sorted(VULNERABILITY_COMPARATOR_DESC).collect(Collectors.toList());
    }

    /**
     * Filters the given collection of {@link VulnerabilityMetaData} objects to a list of not applicable vulnerabilities.
     * Not applicable vulnerabilities are those
     * <ul>
     *     <li>with status <code>not applicable</code> (not matter which score)</li>
     *     <li>with score &gt;= Threshold (excluding all which have status 'applicable')</li>
     * </ul>
     *
     * @param vmds      The list to filter.
     * @param threshold The threshold for filtering.
     * @return List of remaining {@link VulnerabilityMetaData} instances.
     */
    public static List<VulnerabilityMetaData> filterNotApplicableVulnerabilities(Collection<VulnerabilityMetaData> vmds, float threshold) {
        List<VulnerabilityMetaData> resultList = new ArrayList<>();
        for (VulnerabilityMetaData vmd : vmds) {
            boolean notApplicable = false;
            String status = vmd.get(Attribute.STATUS);
            if (StringUtils.isEmpty(status)) {
                continue;
            }
            if (STATUS_VALUE_INSIGNIFICANT.equalsIgnoreCase(status)) {
                continue;
            }
            if (STATUS_VALUE_APPLICABLE.equalsIgnoreCase(status)) {
                continue;
            }
            if (STATUS_VALUE_VOID.equalsIgnoreCase(status)) {
                continue;
            }
            if (STATUS_VALUE_NOTAPPLICABLE.equalsIgnoreCase(status)) {
                notApplicable = true;
            } else {
                float accumulatedMaxScore = vmd.getFloat(Attribute.MAX_SCORE, Float.NaN);
                if (accumulatedMaxScore >= threshold) {
                    notApplicable = true;
                }
            }
            if (notApplicable) {
                resultList.add(vmd);
            }
        }

        resultList.sort(VULNERABILITY_COMPARATOR_DESC);

        return resultList;
    }

    public static List<VulnerabilityMetaData> filterVoidVulnerabilities(Collection<VulnerabilityMetaData> vmds) {
        return vmds.stream().filter(vmd -> vmd.isStatus(STATUS_VALUE_VOID))
                .sorted(VULNERABILITY_COMPARATOR_DESC)
                .collect(Collectors.toList());
    }

    public static List<VulnerabilityMetaData> filterInsignificantVulnerabilities(Collection<VulnerabilityMetaData> vmds, float threshold) {
        List<VulnerabilityMetaData> resultList = new ArrayList<>(vmds);
        resultList.removeAll(filterApplicableVulnerabilities(vmds, threshold));
        resultList.removeAll(filterNotApplicableVulnerabilities(vmds, threshold));
        resultList.removeAll(filterVoidVulnerabilities(vmds));

        resultList.sort(VULNERABILITY_COMPARATOR_DESC);
        return resultList;
    }

    public static List<VulnerabilityMetaData> filterVulnerabilitiesForDetails(Collection<VulnerabilityMetaData> vmds, float threshold) {
        final List<VulnerabilityMetaData> resultList = new ArrayList<>(vmds);

        for (VulnerabilityMetaData vmd : vmds) {
            if (!hasDetails(vmd, threshold)) {
                resultList.remove(vmd);
            }
        }

        // order by name/id
        resultList.sort(VULNERABILITY_COMPARATOR_NAME_DESC);

        return resultList;
    }

    public String deriveRemark() {
        String weakness = get(Attribute.WEAKNESS, "");
        String rationale = get(Attribute.RATIONALE, "");

        if (StringUtils.isNotBlank(rationale)) {
            return rationale;
        }
        if (StringUtils.isNotBlank(weakness)) {
            return weakness.replaceAll("([a-zA-z0-9]+)\\(", "$1 (");
        }
        return "&lt;no information available&gt;";
    }

    // FIXME-VUL: ms must be provided as cert; discuss
    private static String[] attributeKeys = new String[]
            {"CertSei", "CertFr", "MS Vulnerability Information", "MSRC", "Msrc"};

    public static boolean hasDetails(VulnerabilityMetaData vmd, float threshold) {

        // include applicable vulnerabilities with a defined status
        if (StringUtils.isNotBlank(vmd.get(Attribute.STATUS))) {
            return true;
        }

        // include applicable vulnerabilities with score equal or greater threshold
        if (vmd.get(Attribute.MAX_SCORE) != null && Float.parseFloat(vmd.get(Attribute.MAX_SCORE)) >= threshold) {
            return true;
        }

        // include vulnerabilities with a rational (e.g. why a vulnerability is degraded to insignificant or not applicable)
        if (StringUtils.isNotBlank(vmd.get(Attribute.RATIONALE))) {
            return true;
        }

        // include vulnerabilities with a risk description (convey known information)
        if (StringUtils.isNotBlank(vmd.get(Attribute.RISK))) {
            return true;
        }

        // FIXME: make Measures a core attribute; check assessment covers measures
        // include vulnerabilities with a risk measures (convey known information)
        if (StringUtils.isNotBlank(vmd.get("Measures"))) {
            return true;
        }

        // additional check availability of cert information; as soon as there are details available the vulnerability
        // is included. TODO: we may need to filter updates/advisories and only keep alerts.
        for (String key : attributeKeys) {
            if (StringUtils.isNotBlank(vmd.get(key))) {
                return true;
            }
        }

        return false;
    }

}
