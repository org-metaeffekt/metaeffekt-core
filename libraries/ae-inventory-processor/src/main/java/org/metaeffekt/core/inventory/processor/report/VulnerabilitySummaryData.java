/*
 * Copyright 2009-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report;

import org.metaeffekt.core.inventory.processor.model.InventoryInfo;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;
import org.metaeffekt.core.inventory.processor.report.model.LabelColor;
import org.metaeffekt.core.inventory.processor.report.model.LabelData;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaVulnerability;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaVulnerabilityContextInventory;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus.AeaaVulnerabilityStatusHistoryEntry;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.metaeffekt.core.security.cvss.processor.CvssSelectionResult;
import org.metaeffekt.core.util.ColorScheme;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.*;
import java.util.Set;

import static org.metaeffekt.core.security.cvss.CvssSeverityRanges.SeverityRange;

public class VulnerabilitySummaryData {

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilitySummaryData.class);

    private final String periodFrom;
    private final String periodTo;

    private final LabelData severityAffectedLabel;
    private final LabelData severityPotentiallyAffectedLabel;
    private final LabelData severityNotAffectedLabel;

    public VulnerabilitySummaryData(AeaaVulnerabilityContextInventory vInventory, CentralSecurityPolicyConfiguration securityPolicy) {
        final InventoryInfo inventoryInfo = vInventory.getInventory().findInventoryInfo("cert-periodic-query");
        if (inventoryInfo != null) {
            this.periodFrom = inventoryInfo.get("Range Start");
            this.periodTo = inventoryInfo.get("Range End");
        } else {
            this.periodFrom = null;
            this.periodTo = null;
        }

        final Set<AeaaVulnerability> vulnerabilities = vInventory.getShallowCopyVulnerabilities();

        double maxAffectedScore = -1;
        double maxPotentiallyAffectedScore = -1;
        double maxNotAffectedScore = -1;

        for (AeaaVulnerability vulnerability : vulnerabilities) {
            final CvssSelectionResult selectedCvssVectors = vulnerability.getCvssSelectionResult();
            final CvssVector<?> selectedVector = selectedCvssVectors.getSelectedEffectiveIfAvailableOtherwiseBase();

            if (selectedVector != null) {
                final double overallScore = selectedVector.getBakedScores().getOverallScore();

                final AeaaVulnerabilityStatusHistoryEntry latestStatusEntry = vulnerability.getOrCreateNewVulnerabilityStatus().getLatestActiveStatusHistoryEntry();
                final String status = latestStatusEntry != null ? latestStatusEntry.getStatus() : null;

                final String mappedStatus = CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_ABSTRACTED.getMapper().apply(status);

                switch (mappedStatus) {
                    case "affected":
                        if (Double.compare(overallScore, maxAffectedScore) >= 0) {
                            maxAffectedScore = overallScore;
                        }
                        break;

                    case "potentially affected":
                        if (Double.compare(overallScore, maxPotentiallyAffectedScore) >= 0) {
                            maxPotentiallyAffectedScore = overallScore;
                        }
                        break;

                    case "not affected":
                        if (Double.compare(overallScore, maxNotAffectedScore) >= 0) {
                            maxNotAffectedScore = overallScore;
                        }
                        break;
                }
            }
        }

        this.severityAffectedLabel = createLabel(maxAffectedScore, securityPolicy);
        this.severityPotentiallyAffectedLabel = createLabel(maxPotentiallyAffectedScore, securityPolicy);
        this.severityNotAffectedLabel = createLabel(maxNotAffectedScore, securityPolicy);
    }

    private LabelData createLabel(double score, CentralSecurityPolicyConfiguration securityPolicy) {
        if (score == -1) {
            return new LabelData("None", LabelColor.getLabelColorForBackgroundColor(ColorScheme.PASTEL_GRAY.toHex()));
        }

        final SeverityRange severityRange = securityPolicy.getCvssSeverityRanges().getRange(score);
        final String severity = severityRange.getName();
        final Color color = severityRange.getColor().getColor();

        return new LabelData(severity, LabelColor.getLabelColorForBackgroundColor(color));
    }

    public LabelData getSeverityAffectedLabel() {
        return severityAffectedLabel;
    }

    public LabelData getSeverityPotentiallyAffectedLabel() {
        return severityPotentiallyAffectedLabel;
    }

    public LabelData getSeverityNotAffectedLabel() {
        return severityNotAffectedLabel;
    }

    public String getPeriodFrom() {
        return periodFrom == null ? "n/a" : periodFrom;
    }

    public String getPeriodTo() {
        return periodTo == null ? "n/a" : periodTo;
    }
}
