/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus;

import org.apache.commons.lang3.ObjectUtils;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaContentIdentifiers;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaInventoryAttribute;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaVulnerability;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.lang.NonNull;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Mirrors structure of <code>com.metaeffekt.artifact.analysis.vulnerability.enrichment.vulnerabilitystatus.VulnerabilityStatusReviewedEntry</code>
 * until separation of inventory report generation from ae core inventory processor.
 */
public class AeaaVulnerabilityStatusReviewedEntry implements Cloneable {

    private static final Logger LOG = LoggerFactory.getLogger(AeaaVulnerabilityStatusReviewedEntry.class);

    private final String id;
    private String comment;
    private final AeaaContentIdentifiers advisor;

    public AeaaVulnerabilityStatusReviewedEntry(String id, String comment, AeaaContentIdentifiers type) {
        this.id = id;
        this.comment = comment;

        if (type == null || type == AeaaContentIdentifiers.UNKNOWN) {
            this.advisor = AeaaContentIdentifiers.fromEntryIdentifier(id);
        } else {
            this.advisor = type;
        }

        if (id == null) {
            LOG.warn("VulnerabilityStatusReviewedEntry: Id is null (comment: {}; type: {})", comment, type);
        }
    }

    public AeaaVulnerabilityStatusReviewedEntry(String id, String comment) {
        this(id, comment, AeaaContentIdentifiers.fromEntryIdentifier(id));
    }

    public AeaaContentIdentifiers getAdvisor() {
        return advisor;
    }

    public String getId() {
        return id;
    }

    public String getNormalizedId() {
        return advisor == null ? null : advisor.normalizeEntryIdentifier(id);
    }

    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    public JSONObject toJson() {
        JSONObject json = new JSONObject();
        json.put("id", getNormalizedId());
        json.put("advisor", advisor);
        if (comment != null) {
            json.put("comment", comment);
        }
        return json;
    }

    @Override
    public String toString() {
        return id + (comment != null && !comment.isEmpty() ? " (" + comment + ")" : "");
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AeaaVulnerabilityStatusReviewedEntry that = (AeaaVulnerabilityStatusReviewedEntry) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public AeaaVulnerabilityStatusReviewedEntry clone() {
        return new AeaaVulnerabilityStatusReviewedEntry(id, comment, advisor);
    }

    /**
     * Parses a list of entries that are either a Map or a String.<br>
     * <code>[{<br>
     * "advisor": "MSRC", // or 'cert' as legacy key<br>
     * "comment": "This MSRC alert has been reviewed.",<br>
     * "id": "MSRC-CVE-2021-44228"<br>
     * },<br>
     * "MSRC-CVE-2021-44228 (comment)",<br>
     * "MSRC-CVE-2021-44228"]</code>
     *
     * @param entries The entries to parse.
     * @return The parsed entries.
     */
    public static List<AeaaVulnerabilityStatusReviewedEntry> fromMultipleFormattedStringOrMapEntries(List<?> entries) {
        try {
            final List<AeaaVulnerabilityStatusReviewedEntry> parsed = new ArrayList<>();

            for (final Object entry : entries) {
                if (entry instanceof String) {
                    parsed.add(fromFormattedString(entry.toString()));
                } else if (entry instanceof Map) {
                    parsed.add(fromMap((Map<String, Object>) entry));
                }
            }

            return parsed;
        } catch (Exception e) {
            throw new RuntimeException("Unable to parse Vulnerability Status Reviewed Advisory Entries from List of Objects: " + entries, e);
        }
    }

    public static AeaaVulnerabilityStatusReviewedEntry fromFormattedString(String entry) {
        final String id;
        final String comment;

        final Pattern valueWithOptionalParenthesisPattern = Pattern.compile("^([^(]+)(?: \\(([^)]+)\\))?$");

        final Matcher matcher = valueWithOptionalParenthesisPattern.matcher(entry);
        if (matcher.matches()) {
            id = matcher.group(1);
            comment = matcher.groupCount() == 2 ? matcher.group(2) : null;
        } else {
            id = null;
            comment = null;
        }

        return new AeaaVulnerabilityStatusReviewedEntry(id, comment);
    }

    public static AeaaVulnerabilityStatusReviewedEntry fromMap(Map<String, Object> entry) {
        final String id = entry.containsKey("id") ? String.valueOf(entry.get("id")) : null;
        final String comment = entry.containsKey("comment") ? String.valueOf(entry.get("comment")) : null;
        final Object advisor = ObjectUtils.firstNonNull(
                entry.get("advisor"),
                entry.get("cert")
        );
        final AeaaContentIdentifiers parsedAdvisor = AeaaContentIdentifiers.fromName(advisor == null ? "" : String.valueOf(advisor));

        return new AeaaVulnerabilityStatusReviewedEntry(id, comment, parsedAdvisor);
    }

    public static List<AeaaVulnerabilityStatusReviewedEntry> fromJsonArray(JSONArray jsonArray) {
        List<AeaaVulnerabilityStatusReviewedEntry> entries = new ArrayList<>();

        for (int i = 0; i < jsonArray.length(); i++) {
            JSONObject jsonObject = jsonArray.getJSONObject(i);
            entries.add(fromMap(jsonObject.toMap()));
        }

        return entries;
    }

    public static List<AeaaVulnerabilityStatusReviewedEntry> fromVulnerabilityMetaData(VulnerabilityMetaData vmd) {
        if (vmd.has(AeaaInventoryAttribute.REVIEWED_ADVISORIES.getKey())) {
            return fromJsonArray(new JSONArray(vmd.get(AeaaInventoryAttribute.REVIEWED_ADVISORIES.getKey())));
        } else {
            return new ArrayList<>();
        }
    }

    public static List<AeaaVulnerabilityStatusReviewedEntry> fromVulnerability(AeaaVulnerability vulnerability) {
        if (vulnerability.getAdditionalAttributes().containsKey(AeaaInventoryAttribute.REVIEWED_ADVISORIES.getKey())) {
            return fromJsonArray(new JSONArray(vulnerability.getAdditionalAttribute(AeaaInventoryAttribute.REVIEWED_ADVISORIES.getKey())));
        } else {
            return new ArrayList<>();
        }
    }

    public static JSONArray toJsonArray(List<AeaaVulnerabilityStatusReviewedEntry> entries) {
        return new JSONArray(entries.stream()
                .map(AeaaVulnerabilityStatusReviewedEntry::toJson)
                .collect(Collectors.toList()));
    }

    public static JSONArray toJsonArray(AeaaVulnerabilityStatusReviewedEntry... entries) {
        return toJsonArray(Arrays.asList(entries));
    }

    public static void appendToVulnerabilityMetaData(VulnerabilityMetaData vmd, List<AeaaVulnerabilityStatusReviewedEntry> entries) {
        final List<AeaaVulnerabilityStatusReviewedEntry> parsed = fromVulnerabilityMetaData(vmd);
        parsed.addAll(entries);
        vmd.set(AeaaInventoryAttribute.REVIEWED_ADVISORIES.getKey(), toJsonArray(parsed).toString());
    }

    public static void appendToVulnerability(AeaaVulnerability vulnerability, List<AeaaVulnerabilityStatusReviewedEntry> entries) {
        final List<AeaaVulnerabilityStatusReviewedEntry> parsed = fromVulnerability(vulnerability);
        parsed.addAll(entries);
        vulnerability.setAdditionalAttribute(AeaaInventoryAttribute.REVIEWED_ADVISORIES, toJsonArray(parsed).toString());
    }

    public static boolean isReviewedEntry(@NonNull String id, List<AeaaVulnerabilityStatusReviewedEntry> advisories) {
        return advisories.stream().anyMatch(a -> id.equals(a.getId()));
    }

    public static AeaaVulnerabilityStatusReviewedEntry findReviewedEntry(@NonNull String id, List<AeaaVulnerabilityStatusReviewedEntry> advisories) {
        return advisories.stream().filter(a -> id.equals(a.getId())).findFirst().orElse(null);
    }
}
