/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa.store;

import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.logging.Log;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.AdvisoryMetaData;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaVulnerability;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.regex.Pattern;

public class AeaaVulnerabilityTypeStore extends AeaaContentIdentifierStore<AeaaVulnerabilityTypeIdentifier<?>> {
    private static final Logger LOG = LoggerFactory.getLogger(AeaaVulnerabilityTypeStore.class);

    public final static AeaaVulnerabilityTypeIdentifier<AeaaVulnerability> CVE = new AeaaVulnerabilityTypeIdentifier<>("CVE", "CVE", "",
            Pattern.compile("((?:CVE|CAN)-([0-9]{4})-([0-9]{4,}))", Pattern.CASE_INSENSITIVE),
            AeaaVulnerability.class, AeaaVulnerability::new);

    public final static AeaaVulnerabilityTypeIdentifier<? extends AeaaVulnerability> ANY_VULNERABILITY_FILTER_WILDCARD = new AeaaVulnerabilityTypeIdentifier<>(
            "any", "any", "any",
            Pattern.compile("(any|all)", Pattern.CASE_INSENSITIVE),
            AeaaVulnerability.class, AeaaVulnerability::new);

    private final static AeaaVulnerabilityTypeStore INSTANCE = new AeaaVulnerabilityTypeStore();

    public static AeaaVulnerabilityTypeStore get() {
        return INSTANCE;
    }

    protected AeaaVulnerabilityTypeStore() {
        super(AeaaVulnerabilityTypeIdentifier.class);
    }

    @Override
    protected AeaaVulnerabilityTypeIdentifier<?> createIdentifier( String name, String implementation) {
        return new AeaaVulnerabilityTypeIdentifier<>(name, AeaaContentIdentifierStore.AeaaContentIdentifier.deriveWellFormedName(name),
                implementation,
                Pattern.compile("UNKNOWN", Pattern.CASE_INSENSITIVE),
                AeaaVulnerability.class, AeaaVulnerability::new);
    }

    @Override
    public AeaaSingleContentIdentifierParseResult<AeaaVulnerabilityTypeIdentifier<?>> fromJsonNameAndImplementation(JSONObject json) {
        final AeaaSingleContentIdentifierParseResult<?> superResult = super.fromJsonNameAndImplementation(json);

        if (superResult.getIdentifier() instanceof AeaaVulnerabilityTypeIdentifier) {
            return (AeaaSingleContentIdentifierParseResult<AeaaVulnerabilityTypeIdentifier<?>>) superResult;
        } else {
            throw new IllegalArgumentException("The provided JSON object does not represent a vulnerability type identifier, which is an impossible scenario since this class can by definition only support advisory type identifiers.");
        }
    }

    @Override
    public AeaaSingleContentIdentifierParseResult<AeaaVulnerabilityTypeIdentifier<?>> fromMap(Map<String, Object> map) {
        final AeaaSingleContentIdentifierParseResult<?> superResult = super.fromMap(map);

        if (superResult.getIdentifier() instanceof AeaaVulnerabilityTypeIdentifier) {
            return (AeaaSingleContentIdentifierParseResult<AeaaVulnerabilityTypeIdentifier<?>>) superResult;
        } else {
            throw new IllegalArgumentException("The provided map does not represent a vulnerability type identifier, which is an impossible scenario since this class can by definition only support advisory type identifiers.");
        }
    }

    public AeaaSingleContentIdentifierParseResult<AeaaVulnerabilityTypeIdentifier<?>> fromAdvisoryMetaData(AdvisoryMetaData amd) {
        final String source = ObjectUtils.firstNonNull(amd.get(AdvisoryMetaData.Attribute.SOURCE));
        final String implementation = ObjectUtils.firstNonNull(amd.get(AdvisoryMetaData.Attribute.SOURCE_IMPLEMENTATION));
        final String entryId = ObjectUtils.firstNonNull(amd.get(AdvisoryMetaData.Attribute.NAME));

        if (StringUtils.isEmpty(source)) {
            // this should never happen, but let's catch it anyway.
            // the only other option is to check if the name is somehow recognized by any of the patterns.
            if (StringUtils.isEmpty(entryId)) {
                throw new IllegalArgumentException("The vulnerability meta data does not contain a source or name attribute, which is required to determine the advisory type.");
            }

            for (AeaaVulnerabilityTypeIdentifier<?> typeIdentifier : this.values()) {
                if (typeIdentifier.patternMatchesId(entryId)) {
                    return new AeaaSingleContentIdentifierParseResult<>(typeIdentifier, entryId);
                }
            }

            throw new IllegalArgumentException("The vulnerability meta data does not contain a source attribute, which is required to determine the advisory type.");
        }

        final AeaaVulnerabilityTypeIdentifier<?> advisoryTypeIdentifier = this.fromNameAndImplementation(source, implementation);
        return new AeaaSingleContentIdentifierParseResult<>(advisoryTypeIdentifier, entryId);
    }

    public void inferSourceIdentifierFromIdIfAbsent(AeaaVulnerability vulnerability) {
        if (vulnerability.getSourceIdentifier() == null) {
            this.fromId(vulnerability.getId()).ifPresent(inferred -> {
                if (LOG.isDebugEnabled()) {
                    LOG.debug("Inferred source identifier [{}] for vulnerability [{}]", inferred.toExtendedString(), vulnerability.getId());
                }
                vulnerability.setSourceIdentifier(inferred);
            });
        }
    }
}
