/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa.score;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.Inventory;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;
import org.metaeffekt.core.inventory.processor.report.configuration.VulnerabilityPriorityScoreConfiguration;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaEpssData;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaKevData;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaVulnerability;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.AeaaEolCycle;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaCycleStateExtendedSupportInformationNotPresent;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaCycleStateExtendedSupportInformationPresent;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaCycleStateScenario;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaExportedCycleState;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.keywords.AeaaKeywordSet;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.keywords.AeaaVulnerabilityKeywords;
import org.metaeffekt.core.security.cvss.CvssSeverityRanges;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.metaeffekt.core.security.cvss.processor.CvssSelectionResult;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

@Slf4j
@Getter
public class AeaaVulnerabilityPriorityCalculator {
    private CvssVector baseCvssVector;
    private AeaaEpssData epssData;
    private AeaaKevData kevData;
    private List<AeaaExportedCycleState> eolData;
    private AeaaVulnerabilityKeywords keywords;

    public void contribute(CvssVector initialCvss, CvssVector contextCvss) {
        this.baseCvssVector = ObjectUtils.firstNonNull(contextCvss, initialCvss);
    }

    public void contribute(CvssVector fixedCvss) {
        this.baseCvssVector = fixedCvss;
    }

    public void contribute(AeaaEpssData epssData) {
        this.epssData = epssData;
    }

    public void contribute(AeaaKevData kevData) {
        this.kevData = kevData;
    }

    public void contribute(List<AeaaExportedCycleState> eolData) {
        this.eolData = eolData;
    }

    public void contribute(AeaaExportedCycleState eolData) {
        this.eolData = new ArrayList<>();
        this.eolData.add(eolData);
    }

    public void contribute(AeaaVulnerabilityKeywords keywords) {
        this.keywords = keywords;
    }

    public AeaaVulnerabilityPriorityCalculator contribute(AeaaVulnerability vulnerability) {
        final CvssSelectionResult cvssSelectionResult = vulnerability.getCvssSelectionResult();
        if (cvssSelectionResult != null) {
            this.contribute(cvssSelectionResult.getSelectedInitialCvss(), cvssSelectionResult.getSelectedContextCvss());
        } else {
            log.warn("No CVSS selection result found for vulnerability [{}] when contributing to priority score", vulnerability.getId());
        }

        this.epssData = vulnerability.getEpssData();
        this.kevData = vulnerability.getKevData();

        this.eolData = vulnerability.getAffectedArtifactsByDefaultKey().stream()
                .map(AeaaExportedCycleState::fromArtifact)
                .filter(Optional::isPresent).map(Optional::get)
                .flatMap(Collection::stream).collect(Collectors.toList());

        final List<AeaaKeywordSet> keywordSets = AeaaKeywordSet.fromVulnerability(vulnerability);
        this.keywords = new AeaaVulnerabilityKeywords();
        this.keywords.addKeywords(keywordSets);

        return this;
    }

    public AeaaPriorityScoreResult calculatePriorityScore(CentralSecurityPolicyConfiguration securityPolicy) {
        return new AeaaPriorityScoreResult(this, securityPolicy);
    }

    @Getter
    public static class AeaaPriorityScoreResult {
        private final AeaaVulnerabilityPriorityCalculator calculator;

        private final double resultingScore;
        private final CvssSeverityRanges.SeverityRange resultingSeverityRange;

        private final double cvssScore;
        private final double keywordScore;
        private final double epssScore;
        private final double kevScore;
        private final double eolScore;

        private String keywordReasoning;
        private String epssReasoning;
        private String kevReasoning;
        private String eolReasoning;

        private AeaaExportedCycleState selectedEolData;

        public AeaaPriorityScoreResult(AeaaVulnerabilityPriorityCalculator calculator, CentralSecurityPolicyConfiguration securityPolicy) {
            this.calculator = calculator;

            this.cvssScore = this.round(this.calculateCvssScore(securityPolicy));
            this.keywordScore = this.round(this.calculateKeywordScore(securityPolicy));
            this.epssScore = this.round(this.calculateEpssScore(securityPolicy));
            this.kevScore = this.round(this.calculateKevScore(securityPolicy));
            this.eolScore = this.round(this.calculateEolScore(securityPolicy));

            this.resultingScore = this.round(this.sumIfNotNan(this.cvssScore, this.keywordScore, this.epssScore, this.kevScore, this.eolScore));
            this.resultingSeverityRange = securityPolicy.getPriorityScoreSeverityRanges().getRange(this.resultingScore);
        }

        public boolean isElevated() {
            return Double.isNaN(cvssScore) || cvssScore < resultingScore;
        }

        public JSONObject toJson() {
            return new JSONObject()
                    .put("cvssScore", toJsonNum(this.cvssScore))
                    .put("keywordScore", toJsonNum(this.keywordScore))
                    .put("epssScore", toJsonNum(this.epssScore))
                    .put("kevScore", toJsonNum(this.kevScore))
                    .put("eolScore", toJsonNum(this.eolScore))
                    .put("resultingScore", toJsonNum(this.resultingScore))
                    .put("eolReasoning", this.eolReasoning)
                    .put("epssReasoning", this.epssReasoning)
                    .put("kevReasoning", this.kevReasoning)
                    .put("keywordReasoning", this.keywordReasoning);
        }

        public List<String> toPrintTable() {
            final List<Map<String, String>> rows = new ArrayList<>();
            rows.add(constructMap("Type", "CVSS", "Score", String.valueOf(this.cvssScore)));
            rows.add(constructMap("Type", "Keyword", "Score", String.valueOf(this.keywordScore), "Reasoning", this.keywordReasoning));
            rows.add(constructMap("Type", "EPSS", "Score", String.valueOf(this.epssScore), "Reasoning", this.epssReasoning));
            rows.add(constructMap("Type", "KEV", "Score", String.valueOf(this.kevScore), "Reasoning", this.kevReasoning));
            rows.add(constructMap("Type", "EOL", "Score", String.valueOf(this.eolScore), "Reasoning", this.eolReasoning));
            rows.add(constructMap("Type", "Sum", "Score", String.valueOf(this.resultingScore)));
            return Inventory.mapAttributesToHorizontalTable(rows);
        }

        private Map<String, String> constructMap(String... keyValues) {
            if (keyValues.length % 2 != 0) {
                throw new IllegalArgumentException("The keyValues array must have an even number of elements.");
            }

            final Map<String, String> map = new LinkedHashMap<>();
            for (int i = 0; i < keyValues.length; i += 2) {
                map.put(keyValues[i], keyValues[i + 1]);
            }
            return map;
        }

        private double calculateCvssScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrNan(this.calculator.getBaseCvssVector(), CvssVector::getOverallScore);
        }

        private double calculateKeywordScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrNan(this.calculator.getKeywords(), keywords -> {
                this.keywordReasoning = keywords.getKeywordSets().stream().filter(set -> set.getScore() != null).map(set -> {
                    final String title = ObjectUtils.firstNonNull(set.getName(), set.getCategory(), "untitled");
                    return set.getScore() + " (" + title + ")";
                }).collect(Collectors.joining(" + "));
                return keywords.getKeywordSets().stream().filter(set -> set.getScore() != null).mapToDouble(AeaaKeywordSet::getScore).sum();
            });
        }

        private double calculateEpssScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrNan(this.calculator.getEpssData(), epss -> {
                final double p = epss.getEpssScore();
                final VulnerabilityPriorityScoreConfiguration.EpssConfiguration epssConfig = securityPolicy.getPriorityScoreConfiguration().getEpss();

                if (p < epssConfig.getMin()) {
                    this.epssReasoning = "The EPSS score is below the minimum threshold (" + epssConfig.getMin() + ")";
                    return 0.0;
                }

                final double min = epssConfig.getMin();
                final double f = epssConfig.getf();
                final double F = epssConfig.getF();

                this.epssReasoning = "The EPSS score " + p + " (with min: " + min + ", f: " + f + ", F: " + F + ")" + " is used in [" + f + " + ((" + p + " - " + min + ") / (1.0 - " + min + ")) * (" + F + " - " + f + ")]";

                return f + ((p - min) / (1.0 - min)) * (F - f);
            });
        }

        public static String getEpssFormula() {
            return "f + ((p - min) / (1.0 - min)) * (F - f)";
        }

        private double calculateKevScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrNan(this.calculator.getKevData(), kev -> {
                final VulnerabilityPriorityScoreConfiguration.KevConfiguration kevConfig = securityPolicy.getPriorityScoreConfiguration().getKev();
                this.kevReasoning = "An exploit is known (" + kevConfig.getExploit() + ")" + (kev.getRansomwareState() == AeaaKevData.RansomwareState.KNOWN ? " + a ransomware campaign is known (" + kevConfig.getRansomware() + ")" : "");
                return kevConfig.getExploit() + (kev.getRansomwareState() == AeaaKevData.RansomwareState.KNOWN ? kevConfig.getRansomware() : 0.0);
            });
        }

        private double calculateEolScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrNan(this.calculator.getEolData(), eolData -> {
                final VulnerabilityPriorityScoreConfiguration.EolConfiguration eolConfig = securityPolicy.getPriorityScoreConfiguration().getEol();

                final VulnerabilityPriorityScoreConfiguration.EolConfiguration.NoExtendedSupportConfiguration noExtendedSupportConfig = eolConfig.getNoExtendedSupport();
                final VulnerabilityPriorityScoreConfiguration.EolConfiguration.ExtendedSupportConfiguration extendedSupportConfig = eolConfig.getExtendedSupport();

                double worseCaseState = -Double.MAX_VALUE;

                for (AeaaExportedCycleState eol : eolData) {
                    double stateValue = 0.0;
                    String reasoning = "";

                    if (eol.getCycleStateScenario() == AeaaCycleStateScenario.EXTENDED_SUPPORT_NOT_PRESENT) {
                        final AeaaCycleStateExtendedSupportInformationNotPresent info = eol.getCycleStateExtendedSupportInformationNotPresent();
                        reasoning += "Extended support is not available for " + eol.getCycle().getProduct() + " (ver. " + eol.getCycle().getCycle() + "), ";
                        switch (info) {
                            case SUPPORT_VALID:
                                stateValue = noExtendedSupportConfig.getSupportValid();
                                reasoning += "currently support is still valid";
                                break;
                            case SUPPORT_ENDING_SOON:
                                stateValue = noExtendedSupportConfig.getSupportEndingSoon();
                                reasoning += "support is ending soon";
                                break;
                            case SUPPORT_EXPIRED:
                                stateValue = noExtendedSupportConfig.getSupportExpired();
                                reasoning += "support has expired";
                                break;
                        }
                        reasoning += " (rating " + info.getRating().getRating() + ")";
                        if (eol.getSupportMillis() > 0) {
                            reasoning += ", which ends " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getSupportMillis());
                        } else {
                            reasoning += ", which ended " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getSupportMillis());
                        }

                    } else {
                        final AeaaCycleStateExtendedSupportInformationPresent info = eol.getCycleStateExtendedSupportInformationPresent();
                        reasoning += "Extended support is available for " + eol.getCycle().getProduct() + " (ver. " + eol.getCycle().getCycle() + "), ";
                        switch (info) {
                            case SUPPORT_VALID:
                                stateValue = extendedSupportConfig.getSupportValid();
                                reasoning += "currently in regular support (rating " + info.getRating().getRating() + ")";
                                reasoning += ", which ends " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getSupportMillis());
                                break;
                            case SUPPORT_ENDING_SOON:
                                stateValue = extendedSupportConfig.getSupportEndingSoon();
                                reasoning += "regular support is ending soon (rating " + info.getRating().getRating() + ")";
                                reasoning += ", which ends " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getSupportMillis());
                                break;
                            case EXTENDED_SUPPORT_VALID:
                                stateValue = extendedSupportConfig.getExtendedSupportValid();
                                reasoning += "currently in extended support (rating " + info.getRating().getRating() + ")";
                                reasoning += ", which ends " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getExtendedSupportMillis());
                                break;
                            case EXTENDED_SUPPORT_ENDING_SOON:
                                stateValue = extendedSupportConfig.getExtendedSupportEndingSoon();
                                reasoning += "extended support is ending soon (rating " + info.getRating().getRating() + ")";
                                reasoning += ", which ends " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getExtendedSupportMillis());
                                break;
                            case EXTENDED_SUPPORT_EXPIRED:
                                stateValue = extendedSupportConfig.getExtendedSupportExpired();
                                reasoning += "extended support has expired (rating " + info.getRating().getRating() + ")";
                                reasoning += ", which ended " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getExtendedSupportMillis());
                                break;
                        }
                    }

                    if (stateValue > worseCaseState) {
                        worseCaseState = stateValue;
                        this.eolReasoning = reasoning;
                        this.selectedEolData = eol;
                    }
                }

                if (worseCaseState < 0) {
                    this.eolReasoning = "No EOL data available";
                    return 0.0;
                }
                return worseCaseState;
            });
        }

        private <T> double applyOrNan(T value, Function<T, Double> function) {
            if (value == null) {
                return Double.NaN;
            }
            if (value instanceof Collection) {
                final Collection<?> collection = (Collection<?>) value;
                if (collection.isEmpty()) {
                    return Double.NaN;
                }
            }
            return function.apply(value);
        }

        private double round(double d) {
            return Math.round(d * 10.0) / 10.0;
        }

        private double toJsonNum(Double num) {
            if (Double.isNaN(num)) {
                return 0.0;
            }
            return num;
        }

        private double sumIfNotNan(Double... values) {
            double sum = 0.0;
            for (Double value : values) {
                if (!Double.isNaN(value)) {
                    sum += value;
                }
            }
            return sum;
        }
    }
}
