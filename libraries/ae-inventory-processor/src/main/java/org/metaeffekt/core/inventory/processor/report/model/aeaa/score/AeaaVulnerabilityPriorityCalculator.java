/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa.score;

import lombok.Data;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.Inventory;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;
import org.metaeffekt.core.inventory.processor.report.configuration.VulnerabilityPriorityScoreConfiguration;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaEpssData;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaKevData;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaVulnerability;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment.AeaaEffectiveVulnerabilityAssessment;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.AeaaEolCycle;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaCycleStateExtendedSupportInformationNotPresent;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaCycleStateExtendedSupportInformationPresent;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaCycleStateScenario;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.eol.export.AeaaExportedCycleState;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.keywords.AeaaKeywordSet;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.keywords.AeaaVulnerabilityKeywords;
import org.metaeffekt.core.security.cvss.CvssSeverityRanges;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.metaeffekt.core.security.cvss.processor.CvssSelectionResult;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

@Slf4j
@Getter
@RequiredArgsConstructor
public class AeaaVulnerabilityPriorityCalculator {
    private final CentralSecurityPolicyConfiguration securityPolicy;

    private CvssVector baseCvssVector;
    private AeaaEpssData epssData;
    private AeaaKevData kevData;
    private List<AeaaExportedCycleState> eolData;
    private AeaaVulnerabilityKeywords keywords;
    private AeaaEffectiveVulnerabilityAssessment assessment;

    public void contribute(CvssVector initialCvss, CvssVector contextCvss) {
        this.baseCvssVector = ObjectUtils.firstNonNull(contextCvss, initialCvss);
    }

    public void contribute(CvssVector fixedCvss) {
        this.baseCvssVector = fixedCvss;
    }

    public void contribute(AeaaEpssData epssData) {
        this.epssData = epssData;
    }

    public void contribute(AeaaKevData kevData) {
        this.kevData = kevData;
    }

    public void contribute(List<AeaaExportedCycleState> eolData) {
        this.eolData = eolData;
    }

    public void contribute(AeaaExportedCycleState eolData) {
        this.eolData = new ArrayList<>();
        this.eolData.add(eolData);
    }

    public void contribute(AeaaVulnerabilityKeywords keywords) {
        this.keywords = keywords;
    }

    public void contribute(AeaaEffectiveVulnerabilityAssessment assessment) {
        this.assessment = assessment;
    }

    public AeaaVulnerabilityPriorityCalculator contribute(AeaaVulnerability vulnerability) {
        final CvssSelectionResult cvssSelectionResult = vulnerability.getCvssSelectionResult();
        if (cvssSelectionResult != null) {
            this.contribute(cvssSelectionResult.getSelectedInitialCvss(), cvssSelectionResult.getSelectedContextCvss());
        } else {
            log.warn("No CVSS selection result found for vulnerability [{}] when contributing to priority score", vulnerability.getId());
        }

        this.epssData = vulnerability.getEpssData();
        this.kevData = vulnerability.getKevData();

        this.eolData = vulnerability.getAffectedArtifactsByDefaultKey().stream()
                .map(AeaaExportedCycleState::fromArtifact)
                .filter(Optional::isPresent).map(Optional::get)
                .flatMap(Collection::stream).collect(Collectors.toList());

        final List<AeaaKeywordSet> keywordSets = AeaaKeywordSet.fromVulnerability(vulnerability);
        this.keywords = new AeaaVulnerabilityKeywords();
        this.keywords.addKeywords(keywordSets);

        this.assessment = vulnerability.getEffectiveDisplayVulnerabilityAssessment(this.securityPolicy);

        return this;
    }

    public AeaaPriorityScoreResult calculatePriorityScore(CentralSecurityPolicyConfiguration securityPolicy) {
        return new AeaaPriorityScoreResult(this);
    }

    @Getter
    public static class AeaaPriorityScoreResult {
        private final AeaaVulnerabilityPriorityCalculator calculator;

        private final double resultingScore;
        private final CvssSeverityRanges.SeverityRange resultingSeverityRange;

        private final AeaaScoreContributor cvssScore;
        private final AeaaScoreContributor keywordScore;
        private final AeaaScoreContributor epssScore;
        private final AeaaScoreContributor kevScore;
        private final AeaaScoreContributor eolScore;
        private final AeaaScoreContributor vulnerabilityStatusScore;

        private String keywordReasoning;
        private String epssReasoning;
        private String kevReasoning;
        private String eolReasoning;
        private String vulnerabilityStatusReasoning;

        private AeaaExportedCycleState selectedEolData;

        public AeaaPriorityScoreResult(AeaaVulnerabilityPriorityCalculator calculator) {
            this.calculator = calculator;

            this.cvssScore = this.calculateCvssScore(calculator.securityPolicy);
            this.keywordScore = this.calculateKeywordScore(calculator.securityPolicy);
            this.epssScore = this.calculateEpssScore(calculator.securityPolicy);
            this.kevScore = this.calculateKevScore(calculator.securityPolicy);
            this.eolScore = this.calculateEolScore(calculator.securityPolicy);
            this.vulnerabilityStatusScore = this.calculateVulnerabilityStatusScore(calculator.securityPolicy);

            this.resultingScore = this.round(AeaaScoreContributor.apply(0.0,
                    this.cvssScore, this.keywordScore, this.epssScore,
                    this.kevScore, this.eolScore, this.vulnerabilityStatusScore
            ));

            this.resultingSeverityRange = calculator.securityPolicy.getPriorityScoreSeverityRanges().getRange(this.resultingScore);
        }

        public boolean isElevated() {
            final boolean resultingIsHigherThanBase = this.cvssScore.getScore() < this.resultingScore;
            final boolean resultingIsZero = this.resultingScore == 0.0;

            if (resultingIsZero) {
                return false;
            }

            if (resultingIsHigherThanBase) {
                return true;
            }

            return false;
        }

        public JSONObject toJson() {
            return new JSONObject()
                    .put("cvssScore", this.cvssScore.toJson())
                    .put("keywordScore", this.keywordScore.toJson())
                    .put("epssScore", this.epssScore.toJson())
                    .put("kevScore", this.kevScore.toJson())
                    .put("eolScore", this.eolScore.toJson())
                    .put("resultingScore", Double.isNaN(this.resultingScore) ? 0.0 : this.resultingScore)
                    .put("vulnerabilityStatusScore", this.vulnerabilityStatusScore.toJson())
                    .put("eolReasoning", this.eolReasoning)
                    .put("epssReasoning", this.epssReasoning)
                    .put("kevReasoning", this.kevReasoning)
                    .put("keywordReasoning", this.keywordReasoning)
                    .put("vulnerabilityStatusReasoning", this.vulnerabilityStatusReasoning);
        }

        public List<String> toPrintTable() {
            final List<Map<String, String>> rows = new ArrayList<>();
            rows.add(constructMap("Type", "CVSS", "Score", String.valueOf(this.cvssScore)));
            rows.add(constructMap("Type", "Keyword", "Score", String.valueOf(this.keywordScore), "Reasoning", this.keywordReasoning));
            rows.add(constructMap("Type", "EPSS", "Score", String.valueOf(this.epssScore), "Reasoning", this.epssReasoning));
            rows.add(constructMap("Type", "KEV", "Score", String.valueOf(this.kevScore), "Reasoning", this.kevReasoning));
            rows.add(constructMap("Type", "EOL", "Score", String.valueOf(this.eolScore), "Reasoning", this.eolReasoning));
            rows.add(constructMap("Type", "Vulnerability Status", "Score", String.valueOf(this.vulnerabilityStatusScore), "Reasoning", this.vulnerabilityStatusReasoning));
            rows.add(constructMap("Type", "Sum", "Score", String.valueOf(this.resultingScore)));
            return Inventory.mapAttributesToHorizontalTable(rows);
        }

        private Map<String, String> constructMap(String... keyValues) {
            if (keyValues.length % 2 != 0) {
                throw new IllegalArgumentException("The keyValues array must have an even number of elements.");
            }

            final Map<String, String> map = new LinkedHashMap<>();
            for (int i = 0; i < keyValues.length; i += 2) {
                map.put(keyValues[i], keyValues[i + 1]);
            }
            return map;
        }

        private AeaaScoreContributor calculateCvssScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrDefault(this.calculator.getBaseCvssVector(),
                    (CvssVector cvssVector) -> AeaaScoreContributor.AeaaContributionMode.ADD.create(cvssVector.getOverallScore()),
                    AeaaScoreContributor.AeaaContributionMode.empty()
            );
        }

        private AeaaScoreContributor calculateKeywordScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrDefault(this.calculator.getKeywords(), keywords -> {
                this.keywordReasoning = keywords.getKeywordSets().stream().filter(set -> set.getScore() != null).map(set -> {
                    final String title = ObjectUtils.firstNonNull(set.getName(), set.getCategory(), "untitled");
                    return set.getScore() + " (" + title + ")";
                }).collect(Collectors.joining(" + "));

                final double score = keywords.getKeywordSets().stream().filter(set -> set.getScore() != null).mapToDouble(AeaaKeywordSet::getScore).sum();

                return AeaaScoreContributor.AeaaContributionMode.ADD.create(score);
            }, AeaaScoreContributor.AeaaContributionMode.empty());
        }

        private AeaaScoreContributor calculateEpssScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrDefault(this.calculator.getEpssData(), epss -> {
                final double p = epss.getEpssScore();
                final VulnerabilityPriorityScoreConfiguration.EpssConfiguration epssConfig = securityPolicy.getPriorityScoreConfiguration().getEpss();

                if (p < epssConfig.getMin()) {
                    this.epssReasoning = "The EPSS score is below the minimum threshold (" + epssConfig.getMin() + ")";
                    return AeaaScoreContributor.AeaaContributionMode.ADD.create(0.0);
                }

                final double min = epssConfig.getMin();
                final double f = epssConfig.getf();
                final double F = epssConfig.getF();

                this.epssReasoning = "The EPSS score " + p + " (with min: " + min + ", f: " + f + ", F: " + F + ")" + " is used in [" + f + " + ((" + p + " - " + min + ") / (1.0 - " + min + ")) * (" + F + " - " + f + ")]";

                return AeaaScoreContributor.AeaaContributionMode.ADD.create(f + ((p - min) / (1.0 - min)) * (F - f));
            }, AeaaScoreContributor.AeaaContributionMode.empty());
        }

        public static String getEpssFormula() {
            return "f + ((p - min) / (1.0 - min)) * (F - f)";
        }

        private AeaaScoreContributor calculateKevScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrDefault(this.calculator.getKevData(), kev -> {
                final VulnerabilityPriorityScoreConfiguration.KevConfiguration kevConfig = securityPolicy.getPriorityScoreConfiguration().getKev();
                this.kevReasoning = "An exploit is known (" + kevConfig.getExploit() + ")" + (kev.getRansomwareState() == AeaaKevData.RansomwareState.KNOWN ? " + a ransomware campaign is known (" + kevConfig.getRansomware() + ")" : "");
                final double score = kevConfig.getExploit() + (kev.getRansomwareState() == AeaaKevData.RansomwareState.KNOWN ? kevConfig.getRansomware() : 0.0);
                return AeaaScoreContributor.AeaaContributionMode.ADD.create(score);
            }, AeaaScoreContributor.AeaaContributionMode.empty());
        }

        private AeaaScoreContributor calculateEolScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrDefault(this.calculator.getEolData(), eolData -> {
                final VulnerabilityPriorityScoreConfiguration.EolConfiguration eolConfig = securityPolicy.getPriorityScoreConfiguration().getEol();

                final VulnerabilityPriorityScoreConfiguration.EolConfiguration.NoExtendedSupportConfiguration noExtendedSupportConfig = eolConfig.getNoExtendedSupport();
                final VulnerabilityPriorityScoreConfiguration.EolConfiguration.ExtendedSupportConfiguration extendedSupportConfig = eolConfig.getExtendedSupport();

                double worseCaseState = -Double.MAX_VALUE;

                for (AeaaExportedCycleState eol : eolData) {
                    double stateValue = 0.0;
                    String reasoning = "";

                    if (eol.getCycleStateScenario() == AeaaCycleStateScenario.EXTENDED_SUPPORT_NOT_PRESENT) {
                        final AeaaCycleStateExtendedSupportInformationNotPresent info = eol.getCycleStateExtendedSupportInformationNotPresent();
                        reasoning += "Extended support is not available for " + eol.getCycle().getProduct() + " (ver. " + eol.getCycle().getCycle() + "), ";
                        switch (info) {
                            case SUPPORT_VALID:
                                stateValue = noExtendedSupportConfig.getSupportValid();
                                reasoning += "currently support is still valid";
                                break;
                            case SUPPORT_ENDING_SOON:
                                stateValue = noExtendedSupportConfig.getSupportEndingSoon();
                                reasoning += "support is ending soon";
                                break;
                            case SUPPORT_EXPIRED:
                                stateValue = noExtendedSupportConfig.getSupportExpired();
                                reasoning += "support has expired";
                                break;
                        }
                        reasoning += " (rating " + info.getRating().getRating() + ")";
                        if (eol.getSupportMillis() > 0) {
                            reasoning += ", which ends " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getSupportMillis());
                        } else {
                            reasoning += ", which ended " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getSupportMillis());
                        }

                    } else {
                        final AeaaCycleStateExtendedSupportInformationPresent info = eol.getCycleStateExtendedSupportInformationPresent();
                        reasoning += "Extended support is available for " + eol.getCycle().getProduct() + " (ver. " + eol.getCycle().getCycle() + "), ";
                        switch (info) {
                            case SUPPORT_VALID:
                                stateValue = extendedSupportConfig.getSupportValid();
                                reasoning += "currently in regular support (rating " + info.getRating().getRating() + ")";
                                reasoning += ", which ends " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getSupportMillis());
                                break;
                            case SUPPORT_ENDING_SOON:
                                stateValue = extendedSupportConfig.getSupportEndingSoon();
                                reasoning += "regular support is ending soon (rating " + info.getRating().getRating() + ")";
                                reasoning += ", which ends " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getSupportMillis());
                                break;
                            case EXTENDED_SUPPORT_VALID:
                                stateValue = extendedSupportConfig.getExtendedSupportValid();
                                reasoning += "currently in extended support (rating " + info.getRating().getRating() + ")";
                                reasoning += ", which ends " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getExtendedSupportMillis());
                                break;
                            case EXTENDED_SUPPORT_ENDING_SOON:
                                stateValue = extendedSupportConfig.getExtendedSupportEndingSoon();
                                reasoning += "extended support is ending soon (rating " + info.getRating().getRating() + ")";
                                reasoning += ", which ends " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getExtendedSupportMillis());
                                break;
                            case EXTENDED_SUPPORT_EXPIRED:
                                stateValue = extendedSupportConfig.getExtendedSupportExpired();
                                reasoning += "extended support has expired (rating " + info.getRating().getRating() + ")";
                                reasoning += ", which ended " + AeaaEolCycle.formatTimeUntilOrAgo(eol.getExtendedSupportMillis());
                                break;
                        }
                    }

                    if (stateValue > worseCaseState) {
                        worseCaseState = stateValue;
                        this.eolReasoning = reasoning;
                        this.selectedEolData = eol;
                    }
                }

                if (worseCaseState < 0) {
                    this.eolReasoning = "No EOL data available";
                    return AeaaScoreContributor.AeaaContributionMode.empty();
                }
                return AeaaScoreContributor.AeaaContributionMode.ADD.create(worseCaseState);
            }, AeaaScoreContributor.AeaaContributionMode.empty());
        }

        private AeaaScoreContributor calculateVulnerabilityStatusScore(CentralSecurityPolicyConfiguration securityPolicy) {
            return applyOrDefault(this.calculator.getAssessment(), status -> {
                final VulnerabilityPriorityScoreConfiguration.VulnerabilityStatusConfiguration statusConfig = securityPolicy.getPriorityScoreConfiguration().getVulnerabilityStatus();

                final String statusName = status.getStatus();
                final Double add = statusConfig.getAdd().getValue(statusName);
                final Double set = statusConfig.getSet().getValue(statusName);

                if (set != null) {
                    this.vulnerabilityStatusReasoning = "The status is set to " + statusName + " (" + set + ")";
                    return AeaaScoreContributor.AeaaContributionMode.SET.create(this.round(set));
                }

                if (add != null) {
                    this.vulnerabilityStatusReasoning = "The status is " + statusName + " (" + add + ")";
                    return AeaaScoreContributor.AeaaContributionMode.ADD.create(this.round(add));
                }

                this.vulnerabilityStatusReasoning = "The status is " + statusName + " (no score)";
                return AeaaScoreContributor.AeaaContributionMode.ADD.create(0.0);
            }, AeaaScoreContributor.AeaaContributionMode.ADD.create(Double.NaN));
        }

        private <T, R> R applyOrDefault(T value, Function<T, R> function, R defaultValue) {
            if (value == null) {
                return defaultValue;
            }
            if (value instanceof Collection) {
                final Collection<?> collection = (Collection<?>) value;
                if (collection.isEmpty()) {
                    return defaultValue;
                }
            }
            return function.apply(value);
        }

        private double round(double d) {
            return Math.round(d * 10.0) / 10.0;
        }

        private static double toJsonNum(AeaaScoreContributor num) {
            return num.isEmpty() ? 0.0 : num.getScore();
        }

        private static double toJsonNum(Double num) {
            return Double.isNaN(num) ? 0.0 : num;
        }

        private double sumIfNotNan(Double... values) {
            double sum = 0.0;
            for (Double value : values) {
                if (!Double.isNaN(value)) {
                    sum += value;
                }
            }
            return sum;
        }

        @Data
        public static class AeaaScoreContributor {
            private final Double score;
            private final AeaaContributionMode mode;

            public Double apply(Double score) {
                if (this.score != null && !Double.isNaN(this.score)) {
                    switch (this.mode) {
                        case ADD:
                            return score + this.score;
                        case SUBTRACT:
                            return score - this.score;
                        case SET:
                            return this.score;
                    }
                }

                return score;
            }

            public boolean isEmpty() {
                return Double.isNaN(this.score) || this.score == 0.0;
            }

            public boolean hasEffect() {
                return !isEmpty() || this.mode == AeaaContributionMode.SET;
            }

            public JSONObject toJson() {
                return new JSONObject()
                        .put("score", toJsonNum(this.score))
                        .put("mode", this.mode.name());
            }

            public static AeaaScoreContributor fromJson(JSONObject json) {
                return new AeaaScoreContributor(json.getDouble("score"), AeaaContributionMode.valueOf(json.getString("mode")));
            }

            public static Double apply(double score, AeaaScoreContributor... contributors) {
                double result = score;
                for (AeaaScoreContributor contributor : contributors) {
                    result = contributor.apply(result);
                }
                return result;
            }

            @Override
            public String toString() {
                switch (this.mode) {
                    case ADD:
                        return isEmpty() ? "0.0" : String.valueOf(this.score);
                    case SUBTRACT:
                        return "-" + this.score;
                    case SET:
                        return "= " + this.score;
                }

                return String.valueOf(this.score);
            }

            public enum AeaaContributionMode {
                ADD,
                SUBTRACT,
                SET;

                public AeaaScoreContributor create(double score) {
                    return new AeaaScoreContributor(score, this);
                }

                public static AeaaScoreContributor empty() {
                    return new AeaaScoreContributor(Double.NaN, ADD);
                }
            }
        }
    }
}
