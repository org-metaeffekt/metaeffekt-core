/*
 * Copyright 2009-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa.vulnerabilitystatus;

import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaTimeUtils;
import org.metaeffekt.core.security.cvss.v2.Cvss2;
import org.metaeffekt.core.security.cvss.v3.Cvss3P1;
import org.metaeffekt.core.security.cvss.v4P0.Cvss4P0;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.SimpleDateFormat;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Mirrors structure of <code>com.metaeffekt.artifact.analysis.vulnerability.enrichment.vulnerabilitystatus.VulnerabilityStatusConverter</code>
 * until separation of inventory report generation from ae core inventory processor.
 * <p>
 * Due to the large amount of conversion methods, this class has been separated from the
 * {@link AeaaVulnerabilityStatus} class.<br>
 * It contains methods to convert the status data from YAML files or {@link VulnerabilityMetaData} to
 * {@link AeaaVulnerabilityStatus} instances and vice versa.
 */
public class AeaaVulnerabilityStatusConverter {

    private final static Logger LOG = LoggerFactory.getLogger(AeaaVulnerabilityStatus.class);

    public final static SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    public static AeaaVulnerabilityStatus fromYaml(LinkedHashMap<String, Object> yamlRoot) {
        final AeaaVulnerabilityStatus parsedStatus = new AeaaVulnerabilityStatus();

        // create VulnerabilityStatusHistoryEntry objects from the history list
        if (validateEntryType(yamlRoot, "history", ArrayList.class)) {
            ArrayList<Object> steps = (ArrayList<Object>) yamlRoot.get("history");
            for (Object step : steps) {
                if (step instanceof LinkedHashMap) {
                    AeaaVulnerabilityStatusHistoryEntry entry = AeaaVulnerabilityStatusHistoryEntry.fromMap((LinkedHashMap<String, Object>) step);
                    parsedStatus.addHistoryEntry(entry);
                }
            }
        }

        // find what Advisor entries have already been reviewed
        if (validateEntryType(yamlRoot, "reviewed", ArrayList.class)) {
            final ArrayList<Object> steps = (ArrayList<Object>) yamlRoot.get("reviewed");
            final List<AeaaVulnerabilityStatusReviewedEntry> reviewedEntries = AeaaVulnerabilityStatusReviewedEntry.fromMultipleFormattedStringOrMapEntries(steps);
            parsedStatus.addReviewedAdvisoryEntries(reviewedEntries);
        }

        // get the accepted/reported by information
        if (validateEntryType(yamlRoot, "accepted", LinkedHashMap.class)) {
            LinkedHashMap<String, Object> accepted = (LinkedHashMap<String, Object>) yamlRoot.get("accepted");
            if (validateEntryType(accepted, "by", String.class)) {
                parsedStatus.setAcceptedBy(accepted.get("by").toString());
            }
            if (validateEntryType(accepted, "date", Date.class, String.class)) {
                if (accepted.get("date") instanceof String) {
                    final Date parsed = AeaaTimeUtils.tryParse(accepted.get("date").toString());
                    parsedStatus.setAcceptedDate(DATE_FORMAT.format(parsed));
                } else {
                    parsedStatus.setAcceptedDate(DATE_FORMAT.format(accepted.get("date")));
                }
            }
        }
        if (validateEntryType(yamlRoot, "reported", LinkedHashMap.class)) {
            LinkedHashMap<String, Object> reported = (LinkedHashMap<String, Object>) yamlRoot.get("reported");
            if (reported.containsKey("by")) {
                parsedStatus.setReportedBy(reported.get("by").toString());
            }
            if (validateEntryType(reported, "date", Date.class, String.class)) {
                if (reported.get("date") instanceof String) {
                    final Date parsed = AeaaTimeUtils.tryParse(reported.get("date").toString());
                    parsedStatus.setReportedDate(DATE_FORMAT.format(parsed));
                } else {
                    parsedStatus.setReportedDate(DATE_FORMAT.format(reported.get("date")));
                }
            }
        }

        if (validateEntryType(yamlRoot, "cvssV2", String.class, LinkedHashMap.class)) {
            if (yamlRoot.get("cvssV2") instanceof LinkedHashMap) {
                final Map<String, Object> cvssV2Map = (LinkedHashMap<String, Object>) yamlRoot.get("cvssV2");
                if (validateEntryType(cvssV2Map, "all", String.class)) {
                    parsedStatus.setCvss2(new Cvss2(cvssV2Map.get("all").toString()));
                }
                if (validateEntryType(cvssV2Map, "higher", String.class)) {
                    parsedStatus.setCvss2Higher(new Cvss2(cvssV2Map.get("higher").toString()));
                }
                if (validateEntryType(cvssV2Map, "lower", String.class)) {
                    parsedStatus.setCvss2Lower(new Cvss2(cvssV2Map.get("lower").toString()));
                }
            } else {
                parsedStatus.setCvss2(new Cvss2(yamlRoot.get("cvssV2").toString()));
            }
        }
        if (validateEntryType(yamlRoot, "cvssV3", String.class, LinkedHashMap.class)) {
            if (yamlRoot.get("cvssV3") instanceof LinkedHashMap) {
                final Map<String, Object> cvssV3Map = (LinkedHashMap<String, Object>) yamlRoot.get("cvssV3");
                if (validateEntryType(cvssV3Map, "all", String.class)) {
                    parsedStatus.setCvss3P1(new Cvss3P1(cvssV3Map.get("all").toString()));
                }
                if (validateEntryType(cvssV3Map, "higher", String.class)) {
                    parsedStatus.setCvss3P1Higher(new Cvss3P1(cvssV3Map.get("higher").toString()));
                }
                if (validateEntryType(cvssV3Map, "lower", String.class)) {
                    parsedStatus.setCvss3P1Lower(new Cvss3P1(cvssV3Map.get("lower").toString()));
                }
            } else {
                parsedStatus.setCvss3P1(new Cvss3P1(yamlRoot.get("cvssV3").toString()));
            }
        }
        if (validateEntryType(yamlRoot, "cvssV4", String.class, LinkedHashMap.class)) {
            if (yamlRoot.get("cvssV4") instanceof LinkedHashMap) {
                final Map<String, Object> cvssV4Map = (LinkedHashMap<String, Object>) yamlRoot.get("cvssV4");
                if (validateEntryType(cvssV4Map, "all", String.class)) {
                    parsedStatus.setCvss4(new Cvss4P0(cvssV4Map.get("all").toString()));
                }
                if (validateEntryType(cvssV4Map, "higher", String.class)) {
                    parsedStatus.setCvss4Higher(new Cvss4P0(cvssV4Map.get("higher").toString()));
                }
                if (validateEntryType(cvssV4Map, "lower", String.class)) {
                    parsedStatus.setCvss4Lower(new Cvss4P0(cvssV4Map.get("lower").toString()));
                }
            } else {
                parsedStatus.setCvss4(new Cvss4P0(yamlRoot.get("cvssV4").toString()));
            }
        }

        if (validateEntryType(yamlRoot, "title", String.class)) parsedStatus.setTitle(yamlRoot.get("title").toString());

        if (validateEntryType(yamlRoot, "scope", String.class)) {
            parsedStatus.setScope(AeaaVulnerabilityStatus.Scope.fromString(yamlRoot.get("scope").toString()));
            for (AeaaVulnerabilityStatusHistoryEntry entry : parsedStatus.getStatusHistory()) {
                entry.setScope(parsedStatus.getScope());
            }
        }

        return parsedStatus;
    }

    private static boolean validateEntryType(Map<String, ?> map, String key, Class<?>... anyOfType) {
        if (map == null || !map.containsKey(key)) {
            return false;
        }

        boolean noneMatches = Arrays.stream(anyOfType).noneMatch(allowedClass -> (map.get(key).getClass().equals(allowedClass)));

        if (noneMatches) {
            final List<String> expectedType = Arrays.stream(anyOfType).map(Class::getSimpleName).collect(Collectors.toList());
            final String effectiveType = map.get(key).getClass().getSimpleName();
            throw new IllegalArgumentException(String.format("Expected %s on element [%s] but got [%s]", expectedType, key, effectiveType));
        }

        return true;
    }

    public static List<AeaaVulnerabilityStatus> fromJson(final JSONArray json) {
        final List<AeaaVulnerabilityStatus> statusList = new ArrayList<>();

        for (int i = 0; i < json.length(); i++) {
            final JSONObject statusJson = json.getJSONObject(i);
            statusList.add(fromJson(statusJson));
        }

        return statusList;
    }

    public static AeaaVulnerabilityStatus fromJson(final JSONObject json) {
        final AeaaVulnerabilityStatus status = new AeaaVulnerabilityStatus();
        status.appendFromJson(json);
        return status;
    }
}
