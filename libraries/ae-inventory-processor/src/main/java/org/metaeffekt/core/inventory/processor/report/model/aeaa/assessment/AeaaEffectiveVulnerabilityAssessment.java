/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment;

import lombok.*;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaInventoryAttribute;
import org.metaeffekt.core.inventory.processor.report.model.aeaa.AeaaVulnerability;
import org.metaeffekt.core.security.cvss.CvssVector;
import org.metaeffekt.core.security.cvss.v2.Cvss2;
import org.metaeffekt.core.security.cvss.v3.Cvss3P0;
import org.metaeffekt.core.security.cvss.v3.Cvss3P1;
import org.metaeffekt.core.security.cvss.v4P0.Cvss4P0;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.function.Consumer;

import static org.metaeffekt.core.inventory.processor.report.model.aeaa.assessment.AeaaVulnerabilityAssessmentOperations.GSON;


@Slf4j
@Getter
@Setter(AccessLevel.PACKAGE)
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AeaaEffectiveVulnerabilityAssessment {

    private String status;
    private String rationale, risk, measures;
    private Double score;

    private AeaaVulnerabilityAssessmentEvent.CvssModificationGroup cvssV2;
    private AeaaVulnerabilityAssessmentEvent.CvssModificationGroup cvssV3P0;
    private AeaaVulnerabilityAssessmentEvent.CvssModificationGroup cvssV3P1;
    private AeaaVulnerabilityAssessmentEvent.CvssModificationGroup cvssV4P0;

    @Builder.Default
    private List<AeaaVulnerabilityAssessmentEvent.ReviewedAdvisory> reviewedAdvisories = new ArrayList<>();

    @Builder.Default
    private List<AeaaVulnerabilityAssessmentEvent> sourceEvents = new ArrayList<>();
    @Builder.Default
    private List<AeaaVulnerabilityAssessmentEvent> unusedSourceEvents = new ArrayList<>();

    // SECTION: serialize

    public String toJson() {
        return GSON.toJson(this);
    }

    public static String toJson(Collection<AeaaEffectiveVulnerabilityAssessment> events) {
        return GSON.toJson(events);
    }

    public JSONObject toJsonObject() {
        return new JSONObject(GSON.toJson(this));
    }

    public static JSONArray toJsonArray(Collection<AeaaEffectiveVulnerabilityAssessment> events) {
        return new JSONArray(GSON.toJson(events));
    }

    @Override
    public String toString() {
        return toJson();
    }

    // SECTION: effective

    /**
     * This method orders the input events by their natural order in place, meaning the collection passed to this method may be modified after the call.
     * A Collection of events <code>events</code> can be sorted by their natural order by calling
     * <code>events.sort(Comparator.naturalOrder())</code>.
     * The {@link AeaaVulnerabilityAssessment#orderEvents()} method can be used to sort the events in place.
     * <p>Finding the starting point:</p>
     * <ul>
     * <li>All <code>active = false</code> events are discarded.</li>
     * <li>The last event that has the <code>discard on subsequent events</code> flag set that is not the latest event discards itself and
     * all prior events.</li>
     * <li>The last event that has the <code>discard prior events</code> flag set discards all prior events.</li>
     * <li>The oldest event that is not discarded is the starting point.</li>
     * </ul>
     * <p>Finding the effective assessment:</p>
     * <ul>
     * <li>The effective assessment is initialized as an empty object.</li>
     * <li>Each event contributes to the effective assessment by adding or modifying properties:<ul>
     * <li>All regular properties such as text fields, status, priority, etc.,
     * simply set themselves in the effective assessment.</li>
     * <li>CVSS modifications are applied incrementally to the effective assessment&#39;s CVSS vector metric by metric.</li>
     * <li>Reviewed assessments are collected incrementally.</li>
     * </ul>
     * </li>
     * </ul>
     *
     * @param events the events to be used to incrementally build the effective assessment
     * @return the effective assessment
     */
    public static AeaaEffectiveVulnerabilityAssessment fromEvents(List<AeaaVulnerabilityAssessmentEvent> events) {
        final AeaaEffectiveVulnerabilityAssessment effective = new AeaaEffectiveVulnerabilityAssessment();
        if (events.isEmpty()) return effective;

        events.sort(Comparator.naturalOrder());

        final List<AeaaVulnerabilityAssessmentEvent> filteredEvents = filterDiscardedEvents(events);

        final List<AeaaVulnerabilityAssessmentEvent> unusedEvents = new ArrayList<>(events);
        unusedEvents.removeAll(filteredEvents);
        effective.unusedSourceEvents.addAll(unusedEvents);

        final List<AeaaVulnerabilityAssessmentEvent.CvssModificationGroup> cvssV2 = new ArrayList<>();
        final List<AeaaVulnerabilityAssessmentEvent.CvssModificationGroup> cvssV3P0 = new ArrayList<>();
        final List<AeaaVulnerabilityAssessmentEvent.CvssModificationGroup> cvssV3P1 = new ArrayList<>();
        final List<AeaaVulnerabilityAssessmentEvent.CvssModificationGroup> cvssV4P0 = new ArrayList<>();

        for (AeaaVulnerabilityAssessmentEvent event : filteredEvents) {
            effective.sourceEvents.add(event);

            setIfNotEmpty(event.getStatus(), effective::setStatus);

            setIfNotEmpty(event.getRationale(), effective::setRationale);
            setIfNotEmpty(event.getRisk(), effective::setRisk);
            setIfNotEmpty(event.getMeasures(), effective::setMeasures);

            setIfNotEmpty(event.getScore(), effective::setScore);

            if (event.getCvssV2() != null) cvssV2.add(event.getCvssV2());
            if (event.getCvssV3P0() != null) cvssV3P0.add(event.getCvssV3P0());
            if (event.getCvssV3P1() != null) cvssV3P1.add(event.getCvssV3P1());
            if (event.getCvssV4P0() != null) cvssV4P0.add(event.getCvssV4P0());

            effective.reviewedAdvisories.addAll(event.getReviewedAdvisories());
        }

        effective.setCvssV2(AeaaVulnerabilityAssessmentEvent.CvssModificationGroup.aggregateContributions(cvssV2, Cvss2::new));
        effective.setCvssV3P0(AeaaVulnerabilityAssessmentEvent.CvssModificationGroup.aggregateContributions(cvssV3P0, Cvss3P0::new));
        effective.setCvssV3P1(AeaaVulnerabilityAssessmentEvent.CvssModificationGroup.aggregateContributions(cvssV3P1, Cvss3P1::new));
        effective.setCvssV4P0(AeaaVulnerabilityAssessmentEvent.CvssModificationGroup.aggregateContributions(cvssV4P0, Cvss4P0::new));

        return effective;
    }

    public static AeaaEffectiveVulnerabilityAssessment fromEvents(List<AeaaVulnerabilityAssessmentEvent> events, AeaaVulnerability vulnerability, CentralSecurityPolicyConfiguration securityPolicy) {
        final AeaaEffectiveVulnerabilityAssessment effective = fromEvents(events);

        if (StringUtils.hasText(effective.getStatus()) || securityPolicy == null) {
            return effective;
        }

        // if no status is set, check for other indicators of what the status should be
        final AeaaVulnerabilityAssessmentEvent event;
        final boolean isInsignificant = securityPolicy.isVulnerabilityInsignificant(vulnerability);
        if (isInsignificant) {
            event = AeaaVulnerabilityAssessmentEvent.INSIGNIFICANT(securityPolicy.getInsignificantThreshold());
        } else {
            event = AeaaVulnerabilityAssessmentEvent.IN_REVIEW();
        }

        // apply the event to the effective assessment
        effective.getSourceEvents().add(event);
        if (StringUtils.hasText(event.getStatus())) effective.setStatus(event.getStatus());
        if (StringUtils.hasText(event.getRationale())) effective.setRationale(event.getRationale());
        if (StringUtils.hasText(event.getRisk())) effective.setRisk(event.getRisk());
        if (StringUtils.hasText(event.getMeasures())) effective.setMeasures(event.getMeasures());

        return effective;
    }

    private static <T> void setIfNotEmpty(T value, Consumer<T> setter) {
        if (value instanceof String && !StringUtils.isEmpty(((String) value))) {
            setter.accept(value);
        } else if (value != null) {
            setter.accept(value);
        }
    }

    private static List<AeaaVulnerabilityAssessmentEvent> filterDiscardedEvents(List<AeaaVulnerabilityAssessmentEvent> events) {
        if (events == null || events.isEmpty()) {
            return Collections.emptyList();
        }

        final boolean[] discarded = new boolean[events.size()];

        // discard all inactive events
        for (int i = 0; i < events.size(); i++) {
            if (!events.get(i).isActive()) {
                discarded[i] = true;
            }
        }

        // discardOnSubsequentEvents flag
        for (int i = 1; i < events.size(); i++) { // if it's the first event, it's not discarded
            if (events.get(i).isDiscardOnSubsequentEvents()) {
                // this event and all prior events
                for (int j = i; j < events.size(); j++) {
                    discarded[j] = true;
                }
            }
        }

        // discardPriorEvents flag
        for (int i = 0; i < events.size(); i++) {
            if (events.get(i).isDiscardPriorEvents()) {
                // all prior events
                for (int j = i + 1; j < events.size(); j++) {
                    discarded[j] = true;
                }
            }
        }

        final List<AeaaVulnerabilityAssessmentEvent> result = new ArrayList<>();
        for (int i = 0; i < events.size(); i++) {
            // log.info("{}: {} - {}", i, String.format("%-5s", discarded[i]), events.get(i));
            if (!discarded[i]) {
                result.add(events.get(i));
            }
        }

        return result;
    }

    // SECTION: computation logic

    public void applyToVulnerability(AeaaVulnerability vulnerability) {
        if (vulnerability == null) {
            throw new IllegalArgumentException("Vulnerability must not be null");
        }

        vulnerability.clearNonTransferableStatusDetails();

        if (!this.reviewedAdvisories.isEmpty()) {
            vulnerability.setAdditionalAttribute(AeaaInventoryAttribute.REVIEWED_ADVISORIES, AeaaVulnerabilityAssessmentEvent.ReviewedAdvisory.toJson(this.reviewedAdvisories));
        }

        if (this.status != null) {
            vulnerability.setAdditionalAttribute(VulnerabilityMetaData.Attribute.STATUS, this.status);
        }
        if (this.rationale != null) {
            vulnerability.setAdditionalAttribute(VulnerabilityMetaData.Attribute.RATIONALE, this.rationale);
        }
        if (this.risk != null) {
            vulnerability.setAdditionalAttribute(VulnerabilityMetaData.Attribute.RISK, this.risk);
        }
        if (this.measures != null) {
            vulnerability.setAdditionalAttribute(AeaaInventoryAttribute.MEASURES.getKey(), this.measures);
        }
    }

    public List<CvssVector> createVectors() {
        final List<CvssVector> vectors = new ArrayList<>();
        if (this.cvssV2 != null) vectors.addAll(this.cvssV2.createVectors(Cvss2::new, Cvss2.class));
        if (this.cvssV3P0 != null) vectors.addAll(this.cvssV3P0.createVectors(Cvss3P0::new, Cvss3P0.class));
        if (this.cvssV3P1 != null) vectors.addAll(this.cvssV3P1.createVectors(Cvss3P1::new, Cvss3P1.class));
        if (this.cvssV4P0 != null) vectors.addAll(this.cvssV4P0.createVectors(Cvss4P0::new, Cvss4P0.class));
        return vectors;
    }
}
