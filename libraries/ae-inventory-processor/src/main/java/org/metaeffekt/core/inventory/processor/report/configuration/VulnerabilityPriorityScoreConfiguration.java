/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.configuration;

import lombok.Data;
import lombok.EqualsAndHashCode;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.configuration.ProcessConfiguration;
import org.metaeffekt.core.inventory.processor.configuration.ProcessMisconfiguration;

import java.util.LinkedHashMap;
import java.util.List;

/**
 * Configuration class for the vulnerability priority score calculation.
 * <p>
 * The values listen in the priority section can be combined into a priority score as follows:
 * <ol>
 *     <li>The base score is determined by the first non-empty value of "Context CVSS" and "Initial CVSS".</li>
 *     <li>Keyword scores, if present, are added to the base score as before.</li>
 *     <li>The EPSS value 'p' is transformed into an addition factor using a truncated linear curve.
 *     This curve is defined by three parameters: 'min', 'f', and 'F'. Values of 'p' below 'min'
 *     are classified as 0. From 'min' onwards, a line is drawn between ('min', 'f') and (1, 'F'),
 *     which indicates the factor by which 'p' is multiplied.</li>
 *     <li>For KEV, a value 'e' is added if an exploit is known, and a value 'r' is added if ransomware is known.</li>
 *     <li>For EOL, 5 categories with individual scores are defined. These scores are added to the priority score
 *     if they apply. The categories are further differentiated on whether extended support is available:
 *     <ul>
 *         <li>No extended support: SUPPORT_VALID=1, SUPPORT_ENDING_SOON=4, SUPPORT_EXPIRED=5</li>
 *         <li>Extended support: SUPPORT_VALID=1, SUPPORT_ENDING_SOON=2, EXTENDED_SUPPORT_VALID=3,
 *         EXTENDED_SUPPORT_ENDING_SOON=4, EXTENDED_SUPPORT_EXPIRED=5</li>
 *     </ul>
 *     </li>
 * </ol>
 */
@Data
@EqualsAndHashCode(callSuper = true)
public class VulnerabilityPriorityScoreConfiguration extends ProcessConfiguration {

    private EpssConfiguration epss = new EpssConfiguration();
    private KevConfiguration kev = new KevConfiguration();
    private EolConfiguration eol = new EolConfiguration();

    public JSONObject toJson() {
        return new JSONObject()
                .put("epss", epss.toJson())
                .put("kev", kev.toJson())
                .put("eol", eol.toJson());
    }

    private void appendFromJson(JSONObject json) {
        if (json.has("epss")) {
            this.setEpss(EpssConfiguration.fromJson(json.getJSONObject("epss")));
        }
        if (json.has("kev")) {
            this.setKev(KevConfiguration.fromJson(json.getJSONObject("kev")));
        }
        if (json.has("eol")) {
            this.setEol(EolConfiguration.fromJson(json.getJSONObject("eol")));
        }
    }

    public static VulnerabilityPriorityScoreConfiguration fromJson(JSONObject json) {
        VulnerabilityPriorityScoreConfiguration configuration = new VulnerabilityPriorityScoreConfiguration();
        configuration.appendFromJson(json);
        return configuration;
    }

    @Override
    public LinkedHashMap<String, Object> getProperties() {
        return new LinkedHashMap<>(this.toJson().toMap());
    }

    @Override
    public void setProperties(LinkedHashMap<String, Object> properties) {
        this.appendFromJson(new JSONObject(properties));
    }

    @Override
    protected void collectMisconfigurations(List<ProcessMisconfiguration> misconfigurations) {
        // check for null
        if (epss == null) {
            misconfigurations.add(new ProcessMisconfiguration("epss", "EPSS configuration must not be null."));
        }
        if (kev == null) {
            misconfigurations.add(new ProcessMisconfiguration("kev", "KEV configuration must not be null."));
        }
        if (eol == null) {
            misconfigurations.add(new ProcessMisconfiguration("eol", "EOL configuration must not be null."));
        }

        // check for invalid value ranges
        if (epss.getMin() < 0.0 || epss.getMin() > 1.0) {
            misconfigurations.add(new ProcessMisconfiguration("epss.min", "EPSS min must be in the range [0, 1]."));
        }
        checkForNegativeMisconfiguration(misconfigurations, epss.getf(), "epss.f");
        checkForNegativeMisconfiguration(misconfigurations, epss.getF(), "epss.F");
        checkForNegativeMisconfiguration(misconfigurations, kev.getExploit(), "kev.exploit");
        checkForNegativeMisconfiguration(misconfigurations, kev.getRansomware(), "kev.ransomware");
        checkForNegativeMisconfiguration(misconfigurations, eol.getNoExtendedSupport().getSupportValid(), "eol.noExtendedSupport.supportValid");
        checkForNegativeMisconfiguration(misconfigurations, eol.getNoExtendedSupport().getSupportEndingSoon(), "eol.noExtendedSupport.supportEndingSoon");
        checkForNegativeMisconfiguration(misconfigurations, eol.getNoExtendedSupport().getSupportExpired(), "eol.noExtendedSupport.supportExpired");
        checkForNegativeMisconfiguration(misconfigurations, eol.getExtendedSupport().getSupportValid(), "eol.extendedSupport.supportValid");
        checkForNegativeMisconfiguration(misconfigurations, eol.getExtendedSupport().getSupportEndingSoon(), "eol.extendedSupport.supportEndingSoon");
        checkForNegativeMisconfiguration(misconfigurations, eol.getExtendedSupport().getExtendedSupportValid(), "eol.extendedSupport.extendedSupportValid");
    }

    private void checkForNegativeMisconfiguration(List<ProcessMisconfiguration> misconfigurations, double value, String configName) {
        if (value < 0.0) {
            misconfigurations.add(new ProcessMisconfiguration(configName, configName + " must be greater than or equal to 0"));
        }
    }

    @Data
    public static class EpssConfiguration {
        private double min = 0.0;
        private double f = 0.5;Ï€
        private double F = 1.0;

        public void setf(double f) {
            this.f = f;
        }

        public void setF(double F) {
            this.F = F;
        }

        public double getf() {
            return f;
        }

        public double getF() {
            return F;
        }

        public JSONObject toJson() {
            return new JSONObject()
                    .put("min", min)
                    .put("f", f)
                    .put("F", F);
        }

        public static EpssConfiguration fromJson(JSONObject json) {
            final EpssConfiguration configuration = new EpssConfiguration();
            if (json.has("min")) configuration.setMin(json.getDouble("min"));
            if (json.has("f")) configuration.setf(json.getDouble("f"));
            if (json.has("F")) configuration.setF(json.getDouble("F"));
            return configuration;
        }

        @Override
        public String toString() {
            return toJson().toString();
        }
    }

    @Data
    public static class KevConfiguration {
        private double exploit = 2.0;
        private double ransomware = 1.0;

        public JSONObject toJson() {
            return new JSONObject()
                    .put("exploit", exploit)
                    .put("ransomware", ransomware);
        }

        public static KevConfiguration fromJson(JSONObject json) {
            final KevConfiguration configuration = new KevConfiguration();
            if (json.has("exploit")) configuration.setExploit(json.getDouble("exploit"));
            if (json.has("ransomware")) configuration.setRansomware(json.getDouble("ransomware"));
            return configuration;
        }

        @Override
        public String toString() {
            return toJson().toString();
        }
    }

    @Data
    public static class EolConfiguration {
        private NoExtendedSupportConfiguration noExtendedSupport = new NoExtendedSupportConfiguration();
        private ExtendedSupportConfiguration extendedSupport = new ExtendedSupportConfiguration();

        public JSONObject toJson() {
            return new JSONObject()
                    .put("noExtendedSupport", noExtendedSupport)
                    .put("extendedSupport", extendedSupport);
        }

        public static EolConfiguration fromJson(JSONObject json) {
            final EolConfiguration configuration = new EolConfiguration();
            if (json.has("noExtendedSupport"))
                configuration.setNoExtendedSupport(NoExtendedSupportConfiguration.fromJson(json.getJSONObject("noExtendedSupport")));
            if (json.has("extendedSupport"))
                configuration.setExtendedSupport(ExtendedSupportConfiguration.fromJson(json.getJSONObject("extendedSupport")));
            return configuration;
        }

        @Override
        public String toString() {
            return toJson().toString();
        }

        @Data
        public static class NoExtendedSupportConfiguration {
            private double supportValid = 0.0;
            private double supportEndingSoon = 3.0;
            private double supportExpired = 4.0;

            public static NoExtendedSupportConfiguration fromJson(JSONObject json) {
                final NoExtendedSupportConfiguration configuration = new NoExtendedSupportConfiguration();
                if (json.has("supportValid")) configuration.setSupportValid(json.getDouble("supportValid"));
                if (json.has("supportEndingSoon"))
                    configuration.setSupportEndingSoon(json.getDouble("supportEndingSoon"));
                if (json.has("supportExpired")) configuration.setSupportExpired(json.getDouble("supportExpired"));
                return configuration;
            }
        }

        @Data
        public static class ExtendedSupportConfiguration {
            private double supportValid = 0.0;
            private double supportEndingSoon = 1.0;
            private double extendedSupportValid = 2.0;
            private double extendedSupportEndingSoon = 3.0;
            private double extendedSupportExpired = 4.0;

            public static ExtendedSupportConfiguration fromJson(JSONObject json) {
                final ExtendedSupportConfiguration configuration = new ExtendedSupportConfiguration();
                if (json.has("supportValid")) configuration.setSupportValid(json.getDouble("supportValid"));
                if (json.has("supportEndingSoon"))
                    configuration.setSupportEndingSoon(json.getDouble("supportEndingSoon"));
                if (json.has("extendedSupportValid"))
                    configuration.setExtendedSupportValid(json.getDouble("extendedSupportValid"));
                if (json.has("extendedSupportEndingSoon"))
                    configuration.setExtendedSupportEndingSoon(json.getDouble("extendedSupportEndingSoon"));
                if (json.has("extendedSupportExpired"))
                    configuration.setExtendedSupportExpired(json.getDouble("extendedSupportExpired"));
                return configuration;
            }
        }
    }
}
