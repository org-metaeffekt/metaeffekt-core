/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.configuration;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.configuration.ProcessConfiguration;
import org.metaeffekt.core.inventory.processor.configuration.ProcessMisconfiguration;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Configuration class responsible for calculating the vulnerability priority score.
 * <p>
 * The priority score is derived from multiple factors, which are combined as follows:
 * <ol>
 *     <li>The base score is determined by selecting the first non-empty value from either "Context CVSS" or "Initial
 *     CVSS".</li>
 *     <li>Any keyword scores present are summed and added to the base score.</li>
 *     <li>The EPSS value ('p') is transformed into an additive factor using a truncated linear function. This function
 *     is defined by three parameters: 'min', 'f', and 'F'. If 'p' is less than 'min', the score contribution is 0. For
 *     values greater than or equal to 'min', the score is calculated using a linear interpolation between ('min', 'f')
 *     and (1, 'F').</li>
 *     <li>For Known Exploited Vulnerabilities (KEV), a score increment is added if an exploit is known, with an
 *     additional increment if ransomware activity is also known.</li>
 *     <li>End-of-Life (EOL) scores are determined based on the software's support status. Five categories are defined,
 *     with differentiated scoring for scenarios with and without extended support:
 *         <ul>
 *             <li>No extended support: SUPPORT_VALID=1, SUPPORT_ENDING_SOON=4, SUPPORT_EXPIRED=5</li>
 *             <li>With extended support: SUPPORT_VALID=1, SUPPORT_ENDING_SOON=2, EXTENDED_SUPPORT_VALID=3,
 *             EXTENDED_SUPPORT_ENDING_SOON=4, EXTENDED_SUPPORT_EXPIRED=5</li>
 *         </ul>
 *         The highest applicable score is selected and added to the priority score.</li>
 *     <li>The vulnerability status section can be configured to add or set scores for specific status values. This can
 *     be used to deescalate <code>void</code> vulnerabilities.</li>
 * </ol>
 * <p>
 * Each of these components contributes linearly to the overall vulnerability priority score.
 */
@Slf4j
@Data
@EqualsAndHashCode(callSuper = true)
public class VulnerabilityPriorityScoreConfiguration extends ProcessConfiguration {

    private EpssConfiguration epss = new EpssConfiguration();
    private KevConfiguration kev = new KevConfiguration();
    private EolConfiguration eol = new EolConfiguration();
    private VulnerabilityStatusConfiguration vulnerabilityStatus = new VulnerabilityStatusConfiguration();

    public JSONObject toJson() {
        return new JSONObject()
                .put("epss", epss.toJson())
                .put("kev", kev.toJson())
                .put("eol", eol.toJson())
                .put("vulnerabilityStatus", vulnerabilityStatus.toJson());
    }

    private void appendFromJson(JSONObject json) {
        if (json.has("epss")) {
            this.setEpss(EpssConfiguration.fromJson(json.getJSONObject("epss")));
        }
        if (json.has("kev")) {
            this.setKev(KevConfiguration.fromJson(json.getJSONObject("kev")));
        }
        if (json.has("eol")) {
            this.setEol(EolConfiguration.fromJson(json.getJSONObject("eol")));
        }
        if (json.has("vulnerabilityStatus")) {
            this.setVulnerabilityStatus(VulnerabilityStatusConfiguration.fromJson(json.getJSONObject("vulnerabilityStatus")));
        }
    }

    public static VulnerabilityPriorityScoreConfiguration fromJson(JSONObject json) {
        VulnerabilityPriorityScoreConfiguration configuration = new VulnerabilityPriorityScoreConfiguration();
        configuration.appendFromJson(json);
        return configuration;
    }

    @Override
    public LinkedHashMap<String, Object> getProperties() {
        return new LinkedHashMap<>(this.toJson().toMap());
    }

    @Override
    public void setProperties(LinkedHashMap<String, Object> properties) {
        this.appendFromJson(new JSONObject(properties));
    }

    @Override
    protected void collectMisconfigurations(List<ProcessMisconfiguration> misconfigurations) {
        // check for null
        if (epss == null) {
            misconfigurations.add(new ProcessMisconfiguration("epss", "EPSS configuration must not be null."));
        }
        if (kev == null) {
            misconfigurations.add(new ProcessMisconfiguration("kev", "KEV configuration must not be null."));
        }
        if (eol == null) {
            misconfigurations.add(new ProcessMisconfiguration("eol", "EOL configuration must not be null."));
        }

        // check for invalid value ranges
        if (epss.getMin() < 0.0 || epss.getMin() > 1.0) {
            misconfigurations.add(new ProcessMisconfiguration("epss.min", "EPSS min must be in the range [0, 1]."));
        }
        checkForNegativeMisconfiguration(misconfigurations, epss.getf(), "epss.f");
        checkForNegativeMisconfiguration(misconfigurations, epss.getF(), "epss.F");
        checkForNegativeMisconfiguration(misconfigurations, kev.getExploit(), "kev.exploit");
        checkForNegativeMisconfiguration(misconfigurations, kev.getRansomware(), "kev.ransomware");
        checkForNegativeMisconfiguration(misconfigurations, eol.getNoExtendedSupport().getSupportValid(), "eol.noExtendedSupport.supportValid");
        checkForNegativeMisconfiguration(misconfigurations, eol.getNoExtendedSupport().getSupportEndingSoon(), "eol.noExtendedSupport.supportEndingSoon");
        checkForNegativeMisconfiguration(misconfigurations, eol.getNoExtendedSupport().getSupportExpired(), "eol.noExtendedSupport.supportExpired");
        checkForNegativeMisconfiguration(misconfigurations, eol.getExtendedSupport().getSupportValid(), "eol.extendedSupport.supportValid");
        checkForNegativeMisconfiguration(misconfigurations, eol.getExtendedSupport().getSupportEndingSoon(), "eol.extendedSupport.supportEndingSoon");
        checkForNegativeMisconfiguration(misconfigurations, eol.getExtendedSupport().getExtendedSupportValid(), "eol.extendedSupport.extendedSupportValid");
    }

    private void checkForNegativeMisconfiguration(List<ProcessMisconfiguration> misconfigurations, double value, String configName) {
        if (value < 0.0) {
            misconfigurations.add(new ProcessMisconfiguration(configName, configName + " must be greater than or equal to 0"));
        }
    }

    @Data
    public static class EpssConfiguration {
        private double min = 0.5;
        private double f = 0.5;
        private double F = 2.0;

        // do not use lombok annotations for getter/setter, cannot handle lowercase/uppercase naming
        public void setf(double f) {
            this.f = f;
        }

        public void setF(double F) {
            this.F = F;
        }

        public double getf() {
            return f;
        }

        public double getF() {
            return F;
        }

        public JSONObject toJson() {
            return new JSONObject()
                    .put("min", min)
                    .put("f", f)
                    .put("F", F);
        }

        public static EpssConfiguration fromJson(JSONObject json) {
            final EpssConfiguration configuration = new EpssConfiguration();
            if (json.has("min")) configuration.setMin(json.getDouble("min"));
            if (json.has("f")) configuration.setf(json.getDouble("f"));
            if (json.has("F")) configuration.setF(json.getDouble("F"));
            return configuration;
        }

        @Override
        public String toString() {
            return toJson().toString();
        }
    }

    @Data
    public static class KevConfiguration {
        private double exploit = 2.0;
        private double ransomware = 1.0;

        public JSONObject toJson() {
            return new JSONObject()
                    .put("exploit", exploit)
                    .put("ransomware", ransomware);
        }

        public static KevConfiguration fromJson(JSONObject json) {
            final KevConfiguration configuration = new KevConfiguration();
            if (json.has("exploit")) configuration.setExploit(json.getDouble("exploit"));
            if (json.has("ransomware")) configuration.setRansomware(json.getDouble("ransomware"));
            return configuration;
        }

        @Override
        public String toString() {
            return toJson().toString();
        }
    }

    @Data
    public static class EolConfiguration {
        private NoExtendedSupportConfiguration noExtendedSupport = new NoExtendedSupportConfiguration();
        private ExtendedSupportConfiguration extendedSupport = new ExtendedSupportConfiguration();

        public JSONObject toJson() {
            return new JSONObject()
                    .put("noExtendedSupport", noExtendedSupport.toJson())
                    .put("extendedSupport", extendedSupport.toJson());
        }

        public static EolConfiguration fromJson(JSONObject json) {
            final EolConfiguration configuration = new EolConfiguration();
            if (json.has("noExtendedSupport"))
                configuration.setNoExtendedSupport(NoExtendedSupportConfiguration.fromJson(json.getJSONObject("noExtendedSupport")));
            if (json.has("extendedSupport"))
                configuration.setExtendedSupport(ExtendedSupportConfiguration.fromJson(json.getJSONObject("extendedSupport")));
            return configuration;
        }

        @Override
        public String toString() {
            return toJson().toString();
        }

        @Data
        public static class NoExtendedSupportConfiguration {
            private double supportValid = 0.0;
            private double supportEndingSoon = 3.0;
            private double supportExpired = 4.0;

            public static NoExtendedSupportConfiguration fromJson(JSONObject json) {
                final NoExtendedSupportConfiguration configuration = new NoExtendedSupportConfiguration();
                if (json.has("supportValid")) configuration.setSupportValid(json.getDouble("supportValid"));
                if (json.has("supportEndingSoon"))
                    configuration.setSupportEndingSoon(json.getDouble("supportEndingSoon"));
                if (json.has("supportExpired")) configuration.setSupportExpired(json.getDouble("supportExpired"));
                return configuration;
            }

            public JSONObject toJson() {
                return new JSONObject()
                        .put("supportValid", supportValid)
                        .put("supportEndingSoon", supportEndingSoon)
                        .put("supportExpired", supportExpired);
            }
        }

        @Data
        public static class ExtendedSupportConfiguration {
            private double supportValid = 0.0;
            private double supportEndingSoon = 1.0;
            private double extendedSupportValid = 2.0;
            private double extendedSupportEndingSoon = 3.0;
            private double extendedSupportExpired = 4.0;

            public static ExtendedSupportConfiguration fromJson(JSONObject json) {
                final ExtendedSupportConfiguration configuration = new ExtendedSupportConfiguration();
                if (json.has("supportValid")) configuration.setSupportValid(json.getDouble("supportValid"));
                if (json.has("supportEndingSoon"))
                    configuration.setSupportEndingSoon(json.getDouble("supportEndingSoon"));
                if (json.has("extendedSupportValid"))
                    configuration.setExtendedSupportValid(json.getDouble("extendedSupportValid"));
                if (json.has("extendedSupportEndingSoon"))
                    configuration.setExtendedSupportEndingSoon(json.getDouble("extendedSupportEndingSoon"));
                if (json.has("extendedSupportExpired"))
                    configuration.setExtendedSupportExpired(json.getDouble("extendedSupportExpired"));
                return configuration;
            }

            public JSONObject toJson() {
                return new JSONObject()
                        .put("supportValid", supportValid)
                        .put("supportEndingSoon", supportEndingSoon)
                        .put("extendedSupportValid", extendedSupportValid)
                        .put("extendedSupportEndingSoon", extendedSupportEndingSoon)
                        .put("extendedSupportExpired", extendedSupportExpired);
            }
        }
    }

    /**
     * Configuration class for including vulnerability status in the calculation of the priority score.
     * <p>
     * The contribution of the vulnerability status to the priority score is optional and disabled by default (no modification).
     * The configuration consists of two sections: add and set.
     * Each section is represented by an object that contains a map of status names to their corresponding scores.
     * These configured values are used to contribute to the overall priority score.
     * </p>
     */
    @Data
    public static class VulnerabilityStatusConfiguration {
        private Entry add = new Entry();
        private Entry set = new Entry();

        public void clear() {
            add.getValues().clear();
            set.getValues().clear();
        }

        public JSONObject toJson() {
            return new JSONObject()
                    .put("add", add.toJson())
                    .put("set", set.toJson());
        }

        public static VulnerabilityStatusConfiguration fromJson(JSONObject json) {
            final VulnerabilityStatusConfiguration configuration = new VulnerabilityStatusConfiguration();
            if (json.has("add")) configuration.setAdd(Entry.fromJson(json.getJSONObject("add")));
            if (json.has("set")) configuration.setSet(Entry.fromJson(json.getJSONObject("set")));
            return configuration;
        }

        @Data
        public static class Entry {
            private Map<String, Double> values = new HashMap<>();

            public void setValue(String key, Double value) {
                values.put(key.toLowerCase(), value);
            }

            public Double getValue(String key) {
                if (key == null) {
                    if (values.containsKey("null")) {
                        return values.get("null");
                    } else if (values.containsKey("none")) {
                        return values.get("none");
                    } else {
                        return null;
                    }
                }

                if (values.containsKey(key)) {
                    return values.get(key);
                } else if (values.containsKey(key.toLowerCase())) {
                    return values.get(key.toLowerCase());
                } else {
                    return null;
                }
            }

            public JSONObject toJson() {
                return new JSONObject(values);
            }

            public static Entry fromJson(JSONObject json) {
                final Entry entry = new Entry();
                json.toMap().forEach((key, value) -> {
                    if (value instanceof Number) {
                        entry.setValue(key, ((Number) value).doubleValue());
                    } else {
                        log.warn("Invalid value [{}] for vulnerability status score inside vulnerability priority score configuration: {}", value, json);
                        entry.setValue(key, null);
                    }
                });
                return entry;
            }
        }
    }
}
