/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.configuration;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.configuration.ProcessConfiguration;
import org.metaeffekt.core.inventory.processor.configuration.ProcessMisconfiguration;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

/**
 * Configuration class responsible for calculating the vulnerability priority score.
 * <p>
 * The priority score is derived from multiple factors.
 * Each of these components contributes linearly to the overall vulnerability priority score.
 */
@Slf4j
@Data
@EqualsAndHashCode(callSuper = true)
public class VulnerabilityPriorityScoreConfiguration extends ProcessConfiguration {

    private CvssConfiguration cvss = new CvssConfiguration();
    private EpssConfiguration epss = new EpssConfiguration();
    private KevConfiguration kev = new KevConfiguration();
    private EolConfiguration eol = new EolConfiguration();
    private VulnerabilityStatusConfiguration vulnerabilityStatus = new VulnerabilityStatusConfiguration();
    private KeywordsConfiguration keywords = new KeywordsConfiguration();

    public double calculateUpperBound() {
        final double maxCvss = cvss.getF();
        final double maxEpss = epss.getF();
        final double maxKev = kev.getExploit() + kev.getRansomware();
        final double maxKeywords = keywords.getMax();

        final EolConfiguration.NoExtendedSupportConfiguration nes = eol.getNoExtendedSupport();
        final EolConfiguration.ExtendedSupportConfiguration es = eol.getExtendedSupport();
        final double maxEol = Math.max(
                Math.max(nes.getSupportValid(), nes.getSupportEndingSoon()),
                Math.max(nes.getSupportExpired(), Math.max(
                        Math.max(es.getSupportValid(), es.getSupportEndingSoon()),
                        Math.max(es.getExtendedSupportValid(), Math.max(es.getExtendedSupportEndingSoon(), es.getExtendedSupportExpired()))
                ))
        );

        final double maxStatus = vulnerabilityStatus.getAdd().getValues().values().stream()
                .mapToDouble(d -> d != null ? d : 0.0)
                .max()
                .orElse(0.0);

        return maxCvss + maxEpss + maxKev + maxEol + maxStatus + maxKeywords;
    }

    public JSONObject toJson() {
        return new JSONObject()
                .put("cvss", cvss.toJson())
                .put("epss", epss.toJson())
                .put("kev", kev.toJson())
                .put("eol", eol.toJson())
                .put("vulnerabilityStatus", vulnerabilityStatus.toJson())
                .put("keywords", keywords.toJson());
    }

    private void appendFromJson(JSONObject json) {
        if (json.has("cvss")) {
            this.setCvss(CvssConfiguration.fromJson(json.getJSONObject("cvss"), CvssConfiguration::new));
        }
        if (json.has("epss")) {
            this.setEpss(EpssConfiguration.fromJson(json.getJSONObject("epss"), EpssConfiguration::new));
        }
        if (json.has("kev")) {
            this.setKev(KevConfiguration.fromJson(json.getJSONObject("kev")));
        }
        if (json.has("eol")) {
            this.setEol(EolConfiguration.fromJson(json.getJSONObject("eol")));
        }
        if (json.has("vulnerabilityStatus")) {
            this.setVulnerabilityStatus(VulnerabilityStatusConfiguration.fromJson(json.getJSONObject("vulnerabilityStatus")));
        }
        if (json.has("keywords")) {
            this.setKeywords(KeywordsConfiguration.fromJson(json.getJSONObject("keywords")));
        }
    }

    public static VulnerabilityPriorityScoreConfiguration fromJson(JSONObject json) {
        VulnerabilityPriorityScoreConfiguration configuration = new VulnerabilityPriorityScoreConfiguration();
        configuration.appendFromJson(json);
        return configuration;
    }

    @Override
    public LinkedHashMap<String, Object> getProperties() {
        return new LinkedHashMap<>(this.toJson().toMap());
    }

    @Override
    public void setProperties(LinkedHashMap<String, Object> properties) {
        this.appendFromJson(new JSONObject(properties));
    }

    @Override
    protected void collectMisconfigurations(List<ProcessMisconfiguration> misconfigurations) {
        // check for null
        if (cvss == null) {
            misconfigurations.add(new ProcessMisconfiguration("cvss", "CVSS configuration must not be null."));
        }
        if (epss == null) {
            misconfigurations.add(new ProcessMisconfiguration("epss", "EPSS configuration must not be null."));
        }
        if (kev == null) {
            misconfigurations.add(new ProcessMisconfiguration("kev", "KEV configuration must not be null."));
        }
        if (eol == null) {
            misconfigurations.add(new ProcessMisconfiguration("eol", "EOL configuration must not be null."));
        }
        if (keywords == null) {
            misconfigurations.add(new ProcessMisconfiguration("keywords", "Keywords configuration must not be null."));
        }

        // check for invalid value ranges
        if (epss.getMin() < 0.0 || epss.getMin() > 1.0) {
            misconfigurations.add(new ProcessMisconfiguration("epss.min", "EPSS min must be in the range [0, 1]."));
        }
        if (cvss.getMin() < 0.0 || cvss.getMin() > 1.0) {
            misconfigurations.add(new ProcessMisconfiguration("cvss.min", "CVSS min must be in the range [0, 1]."));
        }
        checkForOutOfRangeInclusiveMisconfiguration(misconfigurations, epss.getMin(), 0.0, 1.0, "");
        checkForNegativeMisconfiguration(misconfigurations, cvss.getf(), "cvss.f");
        checkForNegativeMisconfiguration(misconfigurations, cvss.getF(), "cvss.F");
        checkForNegativeMisconfiguration(misconfigurations, epss.getf(), "epss.f");
        checkForNegativeMisconfiguration(misconfigurations, epss.getF(), "epss.F");
        checkForNegativeMisconfiguration(misconfigurations, kev.getExploit(), "kev.exploit");
        checkForNegativeMisconfiguration(misconfigurations, kev.getRansomware(), "kev.ransomware");
        checkForNegativeMisconfiguration(misconfigurations, eol.getNoExtendedSupport().getSupportValid(), "eol.noExtendedSupport.supportValid");
        checkForNegativeMisconfiguration(misconfigurations, eol.getNoExtendedSupport().getSupportEndingSoon(), "eol.noExtendedSupport.supportEndingSoon");
        checkForNegativeMisconfiguration(misconfigurations, eol.getNoExtendedSupport().getSupportExpired(), "eol.noExtendedSupport.supportExpired");
        checkForNegativeMisconfiguration(misconfigurations, eol.getExtendedSupport().getSupportValid(), "eol.extendedSupport.supportValid");
        checkForNegativeMisconfiguration(misconfigurations, eol.getExtendedSupport().getSupportEndingSoon(), "eol.extendedSupport.supportEndingSoon");
        checkForNegativeMisconfiguration(misconfigurations, eol.getExtendedSupport().getExtendedSupportValid(), "eol.extendedSupport.extendedSupportValid");
    }

    private void checkForNegativeMisconfiguration(List<ProcessMisconfiguration> misconfigurations, double value, String configName) {
        if (value < 0.0) {
            misconfigurations.add(new ProcessMisconfiguration(configName, configName + " must be greater than or equal to 0"));
        }
    }

    private void checkForOutOfRangeInclusiveMisconfiguration(List<ProcessMisconfiguration> misconfigurations, double value, double min, double max, String configName) {
        if (value < min || value > max) {
            misconfigurations.add(new ProcessMisconfiguration(configName, configName + " must be in range [" + min + ", " + max + "]"));
        }
    }

    public static class CvssConfiguration extends LinearScalingConfiguration {
        public CvssConfiguration() {
            super(0.0, 0.0, 10.0);
        }
    }

    public static class EpssConfiguration extends LinearScalingConfiguration {
        public EpssConfiguration() {
            super(0.5, 0.5, 2.0);
        }
    }

    @Data
    @AllArgsConstructor
    public static class LinearScalingConfiguration {
        private double min;
        private double f;
        private double F;

        // do not use lombok annotations for getter/setter, cannot handle lowercase/uppercase naming
        public void setf(double f) {
            this.f = f;
        }

        public void setF(double F) {
            this.F = F;
        }

        public double getf() {
            return f;
        }

        public double getF() {
            return F;
        }

        public JSONObject toJson() {
            return new JSONObject().put("min", min).put("f", f).put("F", F);
        }

        public static <T extends LinearScalingConfiguration> T fromJson(JSONObject json, Supplier<T> constructor) {
            final T configuration = constructor.get();
            if (json.has("min")) configuration.setMin(json.getDouble("min"));
            if (json.has("f")) configuration.setf(json.getDouble("f"));
            if (json.has("F")) configuration.setF(json.getDouble("F"));
            return configuration;
        }

        @Override
        public String toString() {
            return toJson().toString();
        }

        @Data
        public static class LinearScalingResult {
            private final double score;
            private final String reasoning;
        }

        public LinearScalingResult calculateLinearScalingContribution(double p, double maxRange, String name) {
            if (p < this.min) {
                final String reasoning = "The " + name + " score is below the minimum threshold (" + this.min + ")";
                return new LinearScalingResult(0.0, reasoning);
            }

            final double score = f + ((p - min) / (maxRange - min)) * (F - f);
            final String reasoning = "The " + name + " score " + p + " (with min: " + min + ", f: " + f + ", F: " + F + ")" + " is used in [" + f + " + ((" + p + " - " + min + ") / (" + maxRange + " - " + min + ")) * (" + F + " - " + f + ")]";

            return new LinearScalingResult(score, reasoning);
        }
    }

    @Data
    public static class KevConfiguration {
        private double exploit = 2.0;
        private double ransomware = 1.0;

        public JSONObject toJson() {
            return new JSONObject()
                    .put("exploit", exploit)
                    .put("ransomware", ransomware);
        }

        public static KevConfiguration fromJson(JSONObject json) {
            final KevConfiguration configuration = new KevConfiguration();
            if (json.has("exploit")) configuration.setExploit(json.getDouble("exploit"));
            if (json.has("ransomware")) configuration.setRansomware(json.getDouble("ransomware"));
            return configuration;
        }

        @Override
        public String toString() {
            return toJson().toString();
        }
    }

    @Data
    public static class EolConfiguration {
        private NoExtendedSupportConfiguration noExtendedSupport = new NoExtendedSupportConfiguration();
        private ExtendedSupportConfiguration extendedSupport = new ExtendedSupportConfiguration();

        public JSONObject toJson() {
            return new JSONObject()
                    .put("noExtendedSupport", noExtendedSupport.toJson())
                    .put("extendedSupport", extendedSupport.toJson());
        }

        public static EolConfiguration fromJson(JSONObject json) {
            final EolConfiguration configuration = new EolConfiguration();
            if (json.has("noExtendedSupport"))
                configuration.setNoExtendedSupport(NoExtendedSupportConfiguration.fromJson(json.getJSONObject("noExtendedSupport")));
            if (json.has("extendedSupport"))
                configuration.setExtendedSupport(ExtendedSupportConfiguration.fromJson(json.getJSONObject("extendedSupport")));
            return configuration;
        }

        @Override
        public String toString() {
            return toJson().toString();
        }

        @Data
        public static class NoExtendedSupportConfiguration {
            private double supportValid = 0.0;
            private double supportEndingSoon = 3.0;
            private double supportExpired = 4.0;

            public static NoExtendedSupportConfiguration fromJson(JSONObject json) {
                final NoExtendedSupportConfiguration configuration = new NoExtendedSupportConfiguration();
                if (json.has("supportValid")) configuration.setSupportValid(json.getDouble("supportValid"));
                if (json.has("supportEndingSoon"))
                    configuration.setSupportEndingSoon(json.getDouble("supportEndingSoon"));
                if (json.has("supportExpired")) configuration.setSupportExpired(json.getDouble("supportExpired"));
                return configuration;
            }

            public JSONObject toJson() {
                return new JSONObject()
                        .put("supportValid", supportValid)
                        .put("supportEndingSoon", supportEndingSoon)
                        .put("supportExpired", supportExpired);
            }
        }

        @Data
        public static class ExtendedSupportConfiguration {
            private double supportValid = 0.0;
            private double supportEndingSoon = 1.0;
            private double extendedSupportValid = 2.0;
            private double extendedSupportEndingSoon = 3.0;
            private double extendedSupportExpired = 4.0;

            public static ExtendedSupportConfiguration fromJson(JSONObject json) {
                final ExtendedSupportConfiguration configuration = new ExtendedSupportConfiguration();
                if (json.has("supportValid")) configuration.setSupportValid(json.getDouble("supportValid"));
                if (json.has("supportEndingSoon"))
                    configuration.setSupportEndingSoon(json.getDouble("supportEndingSoon"));
                if (json.has("extendedSupportValid"))
                    configuration.setExtendedSupportValid(json.getDouble("extendedSupportValid"));
                if (json.has("extendedSupportEndingSoon"))
                    configuration.setExtendedSupportEndingSoon(json.getDouble("extendedSupportEndingSoon"));
                if (json.has("extendedSupportExpired"))
                    configuration.setExtendedSupportExpired(json.getDouble("extendedSupportExpired"));
                return configuration;
            }

            public JSONObject toJson() {
                return new JSONObject()
                        .put("supportValid", supportValid)
                        .put("supportEndingSoon", supportEndingSoon)
                        .put("extendedSupportValid", extendedSupportValid)
                        .put("extendedSupportEndingSoon", extendedSupportEndingSoon)
                        .put("extendedSupportExpired", extendedSupportExpired);
            }
        }
    }

    /**
     * Configuration class for including vulnerability status in the calculation of the priority score.
     * <p>
     * The contribution of the vulnerability status to the priority score is optional and disabled by default (no modification).
     * The configuration consists of two sections: add and set.
     * Each section is represented by an object that contains a map of status names to their corresponding scores.
     * These configured values are used to contribute to the overall priority score.
     * </p>
     */
    @Data
    public static class VulnerabilityStatusConfiguration {
        private Entry add = new Entry();
        private Entry set = new Entry();

        public VulnerabilityStatusConfiguration() {
            this.set.setValue(VulnerabilityMetaData.STATUS_VALUE_VOID, 0.0);
            this.set.setValue(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE, 0.0);
        }

        public void clear() {
            add.getValues().clear();
            set.getValues().clear();
        }

        public JSONObject toJson() {
            return new JSONObject()
                    .put("add", add.toJson())
                    .put("set", set.toJson());
        }

        public static VulnerabilityStatusConfiguration fromJson(JSONObject json) {
            final VulnerabilityStatusConfiguration configuration = new VulnerabilityStatusConfiguration();
            configuration.clear();
            if (json.has("add")) configuration.setAdd(Entry.fromJson(json.getJSONObject("add")));
            if (json.has("set")) configuration.setSet(Entry.fromJson(json.getJSONObject("set")));
            return configuration;
        }

        @Data
        public static class Entry {
            private Map<String, Double> values = new HashMap<>();

            public void setValue(String key, Double value) {
                values.put(key.toLowerCase(), value);
            }

            public Double getValue(String key) {
                if (key == null) {
                    if (values.containsKey("null")) {
                        return values.get("null");
                    } else if (values.containsKey("none")) {
                        return values.get("none");
                    } else {
                        return null;
                    }
                }

                if (values.containsKey(key)) {
                    return values.get(key);
                } else if (values.containsKey(key.toLowerCase())) {
                    return values.get(key.toLowerCase());
                } else {
                    return null;
                }
            }

            public JSONObject toJson() {
                return new JSONObject(values);
            }

            public static Entry fromJson(JSONObject json) {
                final Entry entry = new Entry();
                json.toMap().forEach((key, value) -> {
                    if (value instanceof Number) {
                        entry.setValue(key, ((Number) value).doubleValue());
                    } else {
                        log.warn("Invalid value [{}] for vulnerability status score inside vulnerability priority score configuration: {}", value, json);
                        entry.setValue(key, null);
                    }
                });
                return entry;
            }
        }
    }

    @Data
    public static class KeywordsConfiguration {
        /**
         * The maximum possible score that the keyword contribution can reach. It defines the horizontal asymptote.
         */
        private double max = 5.0;

        /**
         * The "knee" parameter, controlling the sharpness of the transition from linear growth to saturation.
         * Recommended values are >= 1, with 3 forming a nice curve.
         */
        private double knee = 3.0;

        public JSONObject toJson() {
            return new JSONObject().put("max", max).put("knee", knee);
        }

        public static KeywordsConfiguration fromJson(JSONObject json) {
            final KeywordsConfiguration config = new KeywordsConfiguration();
            if (json.has("max")) config.setMax(json.getDouble("max"));
            if (json.has("knee")) config.setKnee(json.getDouble("knee"));
            return config;
        }

        public double applyFunction(double inputScore) {
            if (inputScore <= 0 || max <= 0) return 0.0;

            final double denominator = Math.pow(Math.pow(max, knee) + Math.pow(inputScore, knee), 1.0 / knee);
            if (denominator == 0) return 0.0;

            final double result = (max * inputScore) / denominator;
            if (result <= 0.1) return 0.0;
            return Math.ceil(result * 10) / 10.0;
        }
    }
}
