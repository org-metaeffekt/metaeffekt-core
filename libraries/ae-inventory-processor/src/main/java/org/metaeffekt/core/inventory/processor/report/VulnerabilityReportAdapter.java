/*
 * Copyright 2009-2021 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report;

import org.metaeffekt.core.inventory.processor.model.Inventory;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Dedicated adapter for producing the detailed vulnerability content.
 */
public class VulnerabilityReportAdapter {

    private Inventory inventory;

    public VulnerabilityReportAdapter(Inventory inventory) {
        this.inventory = inventory;
    }

    public List<VulnerabilityMetaData> getVulnerabilityMetaDataForDetailReport(float threshold) {
        return VulnerabilityMetaData.filterVulnerabilitiesForDetails(inventory.getVulnerabilityMetaData(), threshold);
    }

    public List<AdvisoryData> getAdvisories(VulnerabilityMetaData vulnerabilityMetaData) {

        List<AdvisoryData> advisoryDataList = new ArrayList<>();

        final String certFr = vulnerabilityMetaData.getComplete("CertFr");
        if (certFr != null) {
            advisoryDataList.addAll(AdvisoryData.fromCertFr(certFr));
        }

        final String certSei = vulnerabilityMetaData.getComplete("CertSei");
        if (certSei != null) {
            advisoryDataList.addAll(AdvisoryData.fromCertSei(certSei));
        }

        final String msrc = vulnerabilityMetaData.getComplete("MS Vulnerability Information");
        if (msrc != null) {
            advisoryDataList.addAll(AdvisoryData.fromMsrc(msrc, vulnerabilityMetaData));
        }

        return advisoryDataList;
    }

    public String hyperlinkedAdvisories(List<AdvisoryData> advisoryDataList) {
        Map<String, AdvisoryData> map = new HashMap<>();

        for (AdvisoryData advisoryData : advisoryDataList) {
            map.put(advisoryData.getId(), advisoryData);
        }

        List<String> orderedIds = new ArrayList<>(map.keySet());
        Collections.sort(orderedIds);

        final StringBuilder sb = new StringBuilder();
        for (String id : orderedIds) {
            AdvisoryData advisoryData = map.get(id);
            if (sb.length() > 0) sb.append(", ");
            sb.append("<xref href=\"").
                    append(advisoryData.getUrl()).append("\" type=\"html\" scope=\"external\">").
                    append(id).append("</xref>");
        }

        return sb.toString();
    }

    public List<AdvisoryData> filterType(List<AdvisoryData> advisoryDataList, String type) {
        return advisoryDataList.stream().filter(a -> type.equalsIgnoreCase(a.getType())).collect(Collectors.toList());
    }

}
