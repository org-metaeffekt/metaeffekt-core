/*
 * Copyright 2009-2021 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report;

import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.Artifact;
import org.metaeffekt.core.inventory.processor.model.CertMetaData;
import org.metaeffekt.core.inventory.processor.model.Inventory;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;

import java.io.File;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Dedicated adapter for producing the detailed vulnerability content.
 */
public class VulnerabilityReportAdapter {

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityReportAdapter.class);

    protected final Inventory inventory;

    public VulnerabilityReportAdapter(Inventory inventory) {
        this.inventory = inventory;
    }

    public List<VulnerabilityMetaData> getVulnerabilityMetaDataForDetailReport(float threshold) {
        return VulnerabilityMetaData.filterVulnerabilitiesForDetails(inventory.getVulnerabilityMetaData(), threshold).stream()
                .sorted(VulnerabilityMetaData.VULNERABILITY_COMPARATOR_OVERALL_SCORE)
                .collect(Collectors.toList());
    }

    public boolean hasDetails(VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        return VulnerabilityMetaData.hasDetails(vulnerabilityMetaData, threshold);
    }

    public static List<AdvisoryData> getAdvisories(VulnerabilityMetaData vulnerabilityMetaData) {
        List<AdvisoryData> advisoryDataList = new ArrayList<>();

        final String advisories = vulnerabilityMetaData.getComplete("Advisories");
        if (advisories != null) {
            JSONArray advisoriesJsonArray = new JSONArray(advisories);
            advisoryDataList.addAll(AdvisoryData.fromJson(advisoriesJsonArray));
        }

        return advisoryDataList;
    }

    public String hyperlinkedAdvisory(AdvisoryData advisoryData) {
        final StringBuilder sb = new StringBuilder();
        appendHyperlink(sb, advisoryData);
        return sb.toString();
    }

    public String hyperlinkedAdvisories(List<AdvisoryData> advisoryDataList) {
        Map<String, AdvisoryData> map = new HashMap<>();

        for (AdvisoryData advisoryData : advisoryDataList) {
            map.put(advisoryData.getId(), advisoryData);
        }

        List<String> orderedIds = new ArrayList<>(map.keySet());
        Collections.sort(orderedIds);

        final StringBuilder sb = new StringBuilder();
        for (String id : orderedIds) {
            AdvisoryData advisoryData = map.get(id);
            if (sb.length() > 0) sb.append(", ");
            appendHyperlink(sb, advisoryData);
        }

        return sb.toString();
    }

    private void appendHyperlink(StringBuilder sb, AdvisoryData advisoryData) {
        sb.append("<xref href=\"").
                append(advisoryData.getUrl()).append("\" type=\"html\" scope=\"external\">").
                append(advisoryData.getId()).append("</xref>");
    }

    public List<AdvisoryData> filterType(List<AdvisoryData> advisoryDataList, String type) {
        return advisoryDataList.stream().filter(a -> type.equalsIgnoreCase(a.getType())).collect(Collectors.toList());
    }

    public List<CertMetaData> getCertMetaData() {
        return inventory.getCertMetaData();
    }

    public List<CertMetaData> getNewCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_NEW);
    }

    public List<CertMetaData> getInReviewCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_IN_REVIEW);
    }

    public List<CertMetaData> getReviewedCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_REVIEWED);
    }

    public List<CertMetaData> getUnaffectedCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_UNAFFECTED);
    }

    public List<CertMetaData> getUnclassifiedCertMetaData() {
        return getCertMetaDataByStatus(null);
    }

    public List<CertMetaData> getCertMetaDataByStatus(String status) {
        return inventory.getCertMetaData().stream()
                .filter(e -> Objects.equals(status, e.get(CertMetaData.Attribute.REVIEW_STATUS)))
                .sorted(CertMetaData.CERT_COMPARATOR_LAST_UPDATED_DESC)
                .collect(Collectors.toList());
    }

    public List<Artifact> getAffectedComponents(VulnerabilityMetaData vmd) {
        String name = vmd.get(VulnerabilityMetaData.Attribute.NAME);

        return inventory.getArtifacts().stream().filter(
                a -> getCveForArtifact(a).stream().anyMatch(cve -> cve.get(VulnerabilityMetaData.Attribute.NAME).equals(name))
        ).collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> getCveForArtifact(Artifact artifact) {
        List<VulnerabilityMetaData> vulnerabilities = new ArrayList<>();
        String vulnerabilitiesString = artifact.getComplete(Artifact.Attribute.VULNERABILITY);

        if (vulnerabilitiesString != null) {
            for (String vulnerability : vulnerabilitiesString.split(", ?")) {
                String name = vulnerability.trim().replaceAll(" .+", "");
                VulnerabilityMetaData vmd = findVulnerabilityMetaData(name);
                if (vmd != null) {
                    vulnerabilities.add(vmd);
                }
            }
        }

        return vulnerabilities;
    }

    private VulnerabilityMetaData findVulnerabilityMetaData(String name) {
        for (VulnerabilityMetaData vmd : inventory.getVulnerabilityMetaData()) {
            if (vmd.get(VulnerabilityMetaData.Attribute.NAME).equals(name)) {
                return vmd;
            }
        }

        return null;
    }

    /* cvss score determination by method start */

    public final static String CVSS_SCORING_PREFERENCE_LATEST_FIRST = "v3 v2";
    public final static String CVSS_SCORING_PREFERENCE_MAX = "max v3 v2";

    public String getUnmodifiedCvssScoreByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Unmodified Overall");
    }

    public String getModifiedCvssScoreByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Modified Overall");
    }

    public String getUnmodifiedCvssSeverityByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Unmodified Severity");
    }

    public String getModifiedCvssSeverityByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Modified Severity");
    }

    public List<VulnerabilityMetaData> sortVulnerabilitiesByUnmodifiedCvssScore(List<VulnerabilityMetaData> vulnerabilities, String preference) {
        if (vulnerabilities == null) return null;
        return vulnerabilities.stream().sorted((v1, v2) -> {
            final String cvssScore1 = getUnmodifiedCvssScoreByScoringPreference(v1, preference);
            final String cvssScore2 = getUnmodifiedCvssScoreByScoringPreference(v2, preference);

            if (cvssScore1.equals("N/A") && cvssScore2.equals("N/A")) {
                return 0;
            } else if (cvssScore1.equals("N/A")) {
                return 1;
            } else if (cvssScore2.equals("N/A")) {
                return -1;
            } else {
                return Double.compare(Double.parseDouble(cvssScore2), Double.parseDouble(cvssScore1));
            }
        }).collect(Collectors.toList());
    }

    private String getCvssScoreByScoringPreference(VulnerabilityMetaData vmd, String preference, String type) {
        final String[] parts = preference.replace(", ", ",").split(" ");

        for (String part : parts) {
            if (part.startsWith("v3")) {
                if (vmd.has("CVSS " + type + " (v3)")) {
                    return vmd.get("CVSS " + type + " (v3)");
                }

            } else if (part.startsWith("v2")) {
                if (vmd.has("CVSS " + type + " (v2)")) {
                    return vmd.get("CVSS " + type + " (v2)");
                }

            } else if (part.startsWith("max")) {
                if (vmd.has("CVSS " + type + " (v3)") && vmd.has("CVSS " + type + " (v2)") && type.contains("Overall")) {
                    return (int) (Math.max(Double.parseDouble(vmd.get("CVSS " + type + " (v3)")), Double.parseDouble(vmd.get("CVSS " + type + " (v2)"))) * 100) / 100.0 + "";
                } else if (vmd.has("CVSS " + type + " (max)")) {
                    return vmd.get("CVSS " + type + " (max)");
                }
            }
        }

        return "N/A";
    }

    /* components start */

    public List<String> getComponentsFromInventory() {
        return inventory.getArtifacts().stream().map(Artifact::getComponent).distinct().collect(Collectors.toList());
    }

    public List<Artifact> getArtifactsForComponent(String component) {
        if (component == null) return Collections.emptyList();
        return inventory.getArtifacts().stream()
                .filter(a -> a.getComponent() != null && a.getComponent().equals(component))
                .collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> getVulnerabilitiesForArtifact(Artifact artifact) {
        if (artifact == null) return Collections.emptyList();
        return this.getCveForArtifact(artifact).stream()
                .sorted(VulnerabilityMetaData.VULNERABILITY_COMPARATOR_OVERALL_SCORE)
                .collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> getVulnerabilitiesForComponent(String component) {
        if (component == null) return Collections.emptyList();
        return this.getArtifactsForComponent(component).stream()
                .flatMap(a -> getVulnerabilitiesForArtifact(a).stream())
                .distinct()
                .collect(Collectors.toList());
    }

    /* components end, ms start */

    public List<String> getMicrosoftRemediationKBsForVulnerabilityOnArtifact(VulnerabilityMetaData vmd, Artifact artifact) {
        final List<String> kbIdentifiers = new ArrayList<>();

        if (artifact.has("MS Remediations")) {
            String vulnerabilityName = vmd.get(VulnerabilityMetaData.Attribute.NAME);
            JSONObject remediationForVulnerability = new JSONObject(artifact.getComplete("MS Remediations"));

            JSONArray remediationArray = remediationForVulnerability.optJSONArray(vulnerabilityName);
            if (remediationArray != null) {
                for (int i = 0; i < remediationArray.length(); i++) {
                    JSONObject remediation = remediationArray.optJSONObject(i);
                    if (remediation.has("kb")) {
                        String kb = remediation.optString("kb", "N/A");
                        kbIdentifiers.add(kb);
                    }
                }
            }
        }

        return kbIdentifiers;
    }

    public Map<String, String> getMicrosoftRemediationUrlAndDescriptionForVulnerabilityOnArtifact(VulnerabilityMetaData vmd, Artifact artifact) {
        final Map<String, String> kbIdentifiers = new HashMap<>();

        if (artifact.has("MS Remediations")) {
            String vulnerabilityName = vmd.get(VulnerabilityMetaData.Attribute.NAME);
            JSONObject remediationForVulnerability = new JSONObject(artifact.getComplete("MS Remediations"));

            JSONArray remediationArray = remediationForVulnerability.optJSONArray(vulnerabilityName);
            if (remediationArray != null) {
                for (int i = 0; i < remediationArray.length(); i++) {
                    JSONObject remediation = remediationArray.optJSONObject(i);
                    if (remediation.has("url")) {
                        String url = remediation.optString("url", "N/A");
                        String description = remediation.optString("description", url);
                        kbIdentifiers.put(url, description);
                    }
                }
            }
        }

        return kbIdentifiers;
    }

    public boolean hasVulnerabilityMicrosoftRemediationInformationOnArtifact(VulnerabilityMetaData vmd, Collection<Artifact> artifacts) {
        if (vmd == null) return false;
        for (Artifact artifact : artifacts) {
            if (getMicrosoftRemediationKBsForVulnerabilityOnArtifact(vmd, artifact).size() > 0) return true;
            if (getMicrosoftRemediationUrlAndDescriptionForVulnerabilityOnArtifact(vmd, artifact).size() > 0)
                return true;
        }
        return false;
    }

    /* ms end, statistics table start */

    /**
     * See {@link StatisticsOverviewTable#VULNERABILITY_STATUS_MAPPER_ABSTRACTED} for more details.
     *
     * @param category The category to convert
     * @return The abstracted status
     */
    public String getFurtherAbstractedVulnerabilityCategory(final String category) {
        return StatisticsOverviewTable.VULNERABILITY_STATUS_MAPPER_ABSTRACTED.apply(category);
    }

    public StatisticsOverviewTable createUnmodifiedStatisticsOverviewTable(String filterCert, float threshold, Function<String, String> statusMapperFunction) {
        return StatisticsOverviewTable.fromInventoryUnmodified(this, filterCert, threshold, statusMapperFunction);
    }

    public StatisticsOverviewTable createModifiedStatisticsOverviewTable(String filterCert, float threshold, Function<String, String> statusMapperFunction) {
        return StatisticsOverviewTable.fromInventoryModified(this, filterCert, threshold, statusMapperFunction);
    }

    /* statistics table end, utilities start */

    public boolean fileExists(String path) {
        if (path == null) return false;
        return new File(path).exists();
    }

    public static String modulateSeverityText(String severity) {
        if (severity == null) {
            return "n.a.";
        }
        return severity;
    }

    /**
     * Converts a HEX color into a label color by evaluating the brightness and setting the foreground to either black
     * or white depending on that.
     *
     * @param color The background color to use.
     * @return A LabelColor containing background and foreground colors.
     */
    public static LabelColor getLabelColor(String color) {
        if (color != null) {
            int rgb = Integer.parseInt(color.substring(1), 16);
            int r = (rgb >> 16) & 0xff;
            int g = (rgb >> 8) & 0xff;
            int b = (rgb) & 0xff;
            double luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            String backgroundColor = luma < 120 ? "white" : "black";
            return new LabelColor(color, backgroundColor);
        }
        return new LabelColor("#cfcfc4", "black");
    }

    public String getStatusText(final VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);

        // evaluate implicit status based on threshold
        if (!StringUtils.hasText(status)) {
            if (isBelowThreshold(vulnerabilityMetaData, threshold)) {
                status = "insignificant";
            } else {
                status = "in review";
            }
        }
        return status.toLowerCase();
    }

    private boolean isBelowThreshold(VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        final String maxScoreString = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.MAX_SCORE);
        return maxScoreString != null && Float.valueOf(maxScoreString) < threshold;
    }

    public String getPlainStatusText(final VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);
        if (status == null) {
            if (isBelowThreshold(vulnerabilityMetaData, threshold)) {
                status = "insignificant";
            } else {
                status = "in review";
            }
        }
        return status.toLowerCase();
    }

    public LabelColor getStatusLabelColor(String statusText) {
        switch (statusText) {
            case "in review":
                return new LabelColor("#84bfff", "black"); // pastel-blue
            case "not applicable":
                return new LabelColor("#77dd77", "black"); // pastel-green
            case "insignificant":
                return new LabelColor("#84bfff", "#black"); // pastel-blue
            case "potential vulnerability":
                return new LabelColor("#e3b2f2", "black"); // pastel-purple
            case "void":
                return new LabelColor("#636363", "white"); // strong-gray

            default:
                return new LabelColor("#ffcc00", "black"); // strong-yellow
        }
    }

    // FIXME: the whole status and label handling needs to be revised. Currently implemented very inefficiently
    //   Perhaps the inventory can be enhanced based on the given threshold. Such that we have an inventory
    //   reflecting the final status with threshold applied. Then this logic here is simplified.

    public boolean isPotentialVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "applicable":
                return true;
            case "in review":
                return true;
        }
        return false;
    }

    public boolean isVoidVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "unset": // this needs investigation; should not be required.
            case "void":
                return true;
        }
        return false;
    }

    public boolean isNotApplicableVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "not applicable":
                return true;
        }
        return false;
    }

    public boolean isInsignificantVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "insignificant":
                return true;
        }
        return false;
    }

    public boolean isInReviewVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "in review":
                return true;
        }
        return false;
    }

    public boolean isReviewedVulnerability(VulnerabilityMetaData vmd, float threshold) {
        // a vulnerability is reviewed, when the status attribute is provided
        if (vmd == null) return false;
        return vmd.get(VulnerabilityMetaData.Attribute.STATUS) != null;
    }

    /**
     * Evaluates the color of the specified severity category using the date availble in the inventory.
     * In case no color information is available, the implementation falls back to pastel-gray.
     *
     * @param severityCategory The security category to evaluate the color for.
     * @return Color string.
     */
    public String evaluateColor(String severityCategory) {
        if (severityCategory != null) {
            for (VulnerabilityMetaData vmd : inventory.getVulnerabilityMetaData()) {

                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Unmodified Severity (max)"))) {
                    return vmd.get("CVSS Unmodified Severity Color (max)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Unmodified Severity (v2)"))) {
                    return vmd.get("CVSS Unmodified Severity Color (v2)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Unmodified Severity (v3)"))) {
                    return vmd.get("CVSS Unmodified Severity Color (v3)");
                }

                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Modified Severity (max)"))) {
                    return vmd.get("CVSS Modified Severity Color (max)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Modified Severity (v2)"))) {
                    return vmd.get("CVSS Modified Severity Color (v2)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Modified Severity (v3)"))) {
                    return vmd.get("CVSS Modified Severity Color (v3)");
                }

            }

            return getSeverityLabelColor(severityCategory);
        }

        return "#cacecf";
    }

    public String getSeverityLabelColor(String severityCategory) {
        // use defaults:
        switch (severityCategory.toLowerCase()) {
            case "none":
                return "#cacecf";
            case "low":
                return "#ffcc00";
            case "medium":
                return "#ff9b05";
            case "high":
                return "#ff5a0e";
            case "critical":
                return "#ff172d";
        }
        return "#cacecf"; // pastel-gray
    }

    public VulnerabilitySummaryData getVulnerabilitySummaryData(String preference) {
        return new VulnerabilitySummaryData(inventory, this, preference);
    }

    public List<VulnerabilityMetaData> collectAffectedCategory() {
        return inventory.getVulnerabilityMetaData().stream().filter(vmd -> {
            boolean hasStatus = vmd.has(VulnerabilityMetaData.Attribute.STATUS.getKey()) && !vmd.get(VulnerabilityMetaData.Attribute.STATUS).isEmpty();
            boolean isCategoryAffected = vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE) || vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT);
            return hasStatus && isCategoryAffected;
        }).collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> collectPotentiallyAffectedCategory(float threshold) {
        return inventory.getVulnerabilityMetaData().stream().filter(vmd -> {
            final boolean hasStatus = vmd.has(VulnerabilityMetaData.Attribute.STATUS.getKey()) && !vmd.get(VulnerabilityMetaData.Attribute.STATUS).isEmpty();
            final boolean isCategoryPotentiallyAffected = !hasStatus;

            // NOTE: in review is an implicit status, that cannot be set. In case this is changed, this has to be
            //   anticipated here.

            return isCategoryPotentiallyAffected;
        }).collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> collectNotAffectedCategory() {
        return inventory.getVulnerabilityMetaData().stream().filter(vmd -> {
            boolean hasStatus = vmd.has(VulnerabilityMetaData.Attribute.STATUS.getKey()) && !vmd.get(VulnerabilityMetaData.Attribute.STATUS).isEmpty();
            boolean isCategoryNotAffected = vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE) || vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_VOID);
            return hasStatus && isCategoryNotAffected;
        }).collect(Collectors.toList());
    }

}
