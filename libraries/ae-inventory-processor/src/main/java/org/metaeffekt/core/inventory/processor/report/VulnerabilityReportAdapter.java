/*
 * Copyright 2009-2021 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report;

import org.json.JSONArray;
import org.metaeffekt.core.inventory.processor.model.CertMetaData;
import org.metaeffekt.core.inventory.processor.model.Inventory;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Dedicated adapter for producing the detailed vulnerability content.
 */
public class VulnerabilityReportAdapter {

    private Inventory inventory;

    public VulnerabilityReportAdapter(Inventory inventory) {
        this.inventory = inventory;
    }

    public List<VulnerabilityMetaData> getVulnerabilityMetaDataForDetailReport(float threshold) {
        List<VulnerabilityMetaData> filtered = VulnerabilityMetaData.filterVulnerabilitiesForDetails(inventory.getVulnerabilityMetaData(), threshold);
        filtered.sort(VulnerabilityMetaData.VULNERABILITY_COMPARATOR_OVERALL_SCORE);
        return filtered;
    }

    public boolean hasDetails(VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        return VulnerabilityMetaData.hasDetails(vulnerabilityMetaData, threshold);
    }

    public static List<AdvisoryData> getAdvisories(VulnerabilityMetaData vulnerabilityMetaData) {
        List<AdvisoryData> advisoryDataList = new ArrayList<>();

        final String advisories = vulnerabilityMetaData.getComplete("Advisories");
        if (advisories != null) {
            JSONArray advisoriesJsonArray = new JSONArray(advisories);
            advisoryDataList.addAll(AdvisoryData.fromJson(advisoriesJsonArray));
        }

        return advisoryDataList;
    }

    public String hyperlinkedAdvisory(AdvisoryData advisoryData) {
        final StringBuilder sb = new StringBuilder();
        appendHyperlink(sb, advisoryData);
        return sb.toString();
    }

    public String hyperlinkedAdvisories(List<AdvisoryData> advisoryDataList) {
        Map<String, AdvisoryData> map = new HashMap<>();

        for (AdvisoryData advisoryData : advisoryDataList) {
            map.put(advisoryData.getId(), advisoryData);
        }

        List<String> orderedIds = new ArrayList<>(map.keySet());
        Collections.sort(orderedIds);

        final StringBuilder sb = new StringBuilder();
        for (String id : orderedIds) {
            AdvisoryData advisoryData = map.get(id);
            if (sb.length() > 0) sb.append(", ");
            appendHyperlink(sb, advisoryData);
        }

        return sb.toString();
    }

    private void appendHyperlink(StringBuilder sb, AdvisoryData advisoryData) {
        sb.append("<xref href=\"").
                append(advisoryData.getUrl()).append("\" type=\"html\" scope=\"external\">").
                append(advisoryData.getId()).append("</xref>");
    }

    public List<AdvisoryData> filterType(List<AdvisoryData> advisoryDataList, String type) {
        return advisoryDataList.stream().filter(a -> type.equalsIgnoreCase(a.getType())).collect(Collectors.toList());
    }

    public List<CertMetaData> getCertMetaData() {
        return inventory.getCertMetaData();
    }

    public List<CertMetaData> getNewCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_NEW);
    }

    public List<CertMetaData> getInReviewCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_IN_REVIEW);
    }

    public List<CertMetaData> getReviewedCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_REVIEWED);
    }

    public List<CertMetaData> getUnaffectedCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_UNAFFECTED);
    }

    public List<CertMetaData> getUnclassifiedCertMetaData() {
        return getCertMetaDataByStatus(null);
    }

    public List<CertMetaData> getCertMetaDataByStatus(String status) {
        return inventory.getCertMetaData().stream()
                .filter(e -> Objects.equals(status, e.get(CertMetaData.Attribute.REVIEW_STATUS)))
                .sorted(CertMetaData.CERT_COMPARATOR_LAST_UPDATED_DESC)
                .collect(Collectors.toList());
    }

    public static class LabelColor {
        private String background;
        private String foreground;

        LabelColor(String background, String foreground) {
            this.background = background;
            this.foreground = foreground;
        }

        public String getBackground() {
            return background;
        }

        public String getForeground() {
            return foreground;
        }
    }

    public static String modulateSeverityText(String severity) {
        if (severity == null) {
            return "n.a.";
        }
        return severity;
    }

    /**
     * Converts a HEX color into a label color by evaluating the brightness and setting the foreground to either black
     * or white depending on that.
     *
     * @param color The background color to use.
     * @return A LabelColor containing background and foreground colors.
     */
    public static LabelColor getLabelColor(String color) {
        if (color != null) {
            int rgb = Integer.parseInt(color.substring(1), 16);
            int r = (rgb >> 16) & 0xff;
            int g = (rgb >> 8) & 0xff;
            int b = (rgb) & 0xff;
            double luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            String backgroundColor = luma < 120 ? "white" : "black";
            return new LabelColor(color, backgroundColor);
        }
        return new LabelColor("#cfcfc4", "black");
    }

    public String getStatusText(VulnerabilityMetaData vulnerabilityMetaData) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);
        if (status == null) {
            status = "in review";
        }

        if ("applicable".equalsIgnoreCase(status)) {
            status = "potential vulnerability";
        }

        if ("not applicable".equalsIgnoreCase(status)) {
            status = "not applicable";
        }

        if ("insignificant".equalsIgnoreCase(status)) {
            status = "insignificant";
        }

        return status;
    }

    public LabelColor getStatusLabelColor(String statusText) {
        switch (statusText) {
            case "in review":
                return new LabelColor("#cacecf", "black"); // pastel-gray
            case "not applicable":
                return new LabelColor("#77dd77", "black"); // pastel-green
            case "insignificant":
                return new LabelColor("#84bfff", "#black"); // pastel-blue
            case "potential vulnerability":
                return new LabelColor("#e3b2f2", "black"); // pastel-purple

            default:
                return new LabelColor("#ffcc00", "black"); // strong-yellow
        }
    }

}
