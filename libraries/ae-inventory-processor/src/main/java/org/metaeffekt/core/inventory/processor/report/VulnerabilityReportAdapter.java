/*
 * Copyright 2009-2021 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report;

import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.Artifact;
import org.metaeffekt.core.inventory.processor.model.CertMetaData;
import org.metaeffekt.core.inventory.processor.model.Inventory;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Dedicated adapter for producing the detailed vulnerability content.
 */
public class VulnerabilityReportAdapter {

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityReportAdapter.class);

    private final Inventory inventory;

    public VulnerabilityReportAdapter(Inventory inventory) {
        this.inventory = inventory;
    }

    public List<VulnerabilityMetaData> getVulnerabilityMetaDataForDetailReport(float threshold) {
        List<VulnerabilityMetaData> filtered = VulnerabilityMetaData.filterVulnerabilitiesForDetails(inventory.getVulnerabilityMetaData(), threshold);
        filtered.sort(VulnerabilityMetaData.VULNERABILITY_COMPARATOR_OVERALL_SCORE);
        return filtered;
    }

    public boolean hasDetails(VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        return VulnerabilityMetaData.hasDetails(vulnerabilityMetaData, threshold);
    }

    public static List<AdvisoryData> getAdvisories(VulnerabilityMetaData vulnerabilityMetaData) {
        List<AdvisoryData> advisoryDataList = new ArrayList<>();

        final String advisories = vulnerabilityMetaData.getComplete("Advisories");
        if (advisories != null) {
            JSONArray advisoriesJsonArray = new JSONArray(advisories);
            advisoryDataList.addAll(AdvisoryData.fromJson(advisoriesJsonArray));
        }

        return advisoryDataList;
    }

    public String hyperlinkedAdvisory(AdvisoryData advisoryData) {
        final StringBuilder sb = new StringBuilder();
        appendHyperlink(sb, advisoryData);
        return sb.toString();
    }

    public String hyperlinkedAdvisories(List<AdvisoryData> advisoryDataList) {
        Map<String, AdvisoryData> map = new HashMap<>();

        for (AdvisoryData advisoryData : advisoryDataList) {
            map.put(advisoryData.getId(), advisoryData);
        }

        List<String> orderedIds = new ArrayList<>(map.keySet());
        Collections.sort(orderedIds);

        final StringBuilder sb = new StringBuilder();
        for (String id : orderedIds) {
            AdvisoryData advisoryData = map.get(id);
            if (sb.length() > 0) sb.append(", ");
            appendHyperlink(sb, advisoryData);
        }

        return sb.toString();
    }

    private void appendHyperlink(StringBuilder sb, AdvisoryData advisoryData) {
        sb.append("<xref href=\"").
                append(advisoryData.getUrl()).append("\" type=\"html\" scope=\"external\">").
                append(advisoryData.getId()).append("</xref>");
    }

    public List<AdvisoryData> filterType(List<AdvisoryData> advisoryDataList, String type) {
        return advisoryDataList.stream().filter(a -> type.equalsIgnoreCase(a.getType())).collect(Collectors.toList());
    }

    public List<CertMetaData> getCertMetaData() {
        return inventory.getCertMetaData();
    }

    public List<CertMetaData> getNewCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_NEW);
    }

    public List<CertMetaData> getInReviewCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_IN_REVIEW);
    }

    public List<CertMetaData> getReviewedCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_REVIEWED);
    }

    public List<CertMetaData> getUnaffectedCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_UNAFFECTED);
    }

    public List<CertMetaData> getUnclassifiedCertMetaData() {
        return getCertMetaDataByStatus(null);
    }

    public List<CertMetaData> getCertMetaDataByStatus(String status) {
        return inventory.getCertMetaData().stream()
                .filter(e -> Objects.equals(status, e.get(CertMetaData.Attribute.REVIEW_STATUS)))
                .sorted(CertMetaData.CERT_COMPARATOR_LAST_UPDATED_DESC)
                .collect(Collectors.toList());
    }

    public List<Artifact> getAffectedComponents(VulnerabilityMetaData vmd) {
        String name = vmd.get(VulnerabilityMetaData.Attribute.NAME);

        return inventory.getArtifacts().stream().filter(
                a -> getCveForArtifact(a).stream().anyMatch(cve -> cve.get(VulnerabilityMetaData.Attribute.NAME).equals(name))
        ).collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> getCveForArtifact(Artifact artifact) {
        List<VulnerabilityMetaData> vulnerabilities = new ArrayList<>();
        String vulnerabilitiesString = artifact.getComplete(Artifact.Attribute.VULNERABILITY);

        if (vulnerabilitiesString != null) {
            for (String vulnerability : vulnerabilitiesString.split(", ?")) {
                String name = vulnerability.trim().replaceAll(" .+", "");
                VulnerabilityMetaData vmd = findVulnerabilityMetaData(name);
                if (vmd != null) {
                    vulnerabilities.add(vmd);
                }
            }
        }

        return vulnerabilities;
    }

    private VulnerabilityMetaData findVulnerabilityMetaData(String name) {
        for (VulnerabilityMetaData vmd : inventory.getVulnerabilityMetaData()) {
            if (vmd.get(VulnerabilityMetaData.Attribute.NAME).equals(name)) {
                return vmd;
            }
        }

        return null;
    }

    public List<String> getMicrosoftRemediationKBsForVulnerabilityOnArtifact(VulnerabilityMetaData vmd, Artifact artifact) {
        List<String> kbIdentifiers = new ArrayList<>();

        if (artifact.has("MS Remediations")) {
            String vulnerabilityName = vmd.get(VulnerabilityMetaData.Attribute.NAME);
            JSONObject remediationForVulnerability = new JSONObject(artifact.getComplete("MS Remediations"));

            JSONArray remediationArray = remediationForVulnerability.optJSONArray(vulnerabilityName);
            if (remediationArray != null) {
                for (int i = 0; i < remediationArray.length(); i++) {
                    JSONObject remediation = remediationArray.optJSONObject(i);
                    if (remediation.has("kb")) {
                        String kb = remediation.optString("kb", "N/A");
                        kbIdentifiers.add(kb);
                    }
                }
            }
        }

        return kbIdentifiers;
    }

    public Map<String, String> getMicrosoftRemediationUrlAndDescriptionForVulnerabilityOnArtifact(VulnerabilityMetaData vmd, Artifact artifact) {
        Map<String, String> kbIdentifiers = new HashMap<>();

        if (artifact.has("MS Remediations")) {
            String vulnerabilityName = vmd.get(VulnerabilityMetaData.Attribute.NAME);
            JSONObject remediationForVulnerability = new JSONObject(artifact.getComplete("MS Remediations"));

            JSONArray remediationArray = remediationForVulnerability.optJSONArray(vulnerabilityName);
            if (remediationArray != null) {
                for (int i = 0; i < remediationArray.length(); i++) {
                    JSONObject remediation = remediationArray.optJSONObject(i);
                    if (remediation.has("url")) {
                        String url = remediation.optString("url", "N/A");
                        String description = remediation.optString("description", url);
                        kbIdentifiers.put(url, description);
                    }
                }
            }
        }

        return kbIdentifiers;
    }

    public boolean hasVulnerabilityMicrosoftRemediationInformationOnArtifact(VulnerabilityMetaData vmd, Collection<Artifact> artifacts) {
        for (Artifact artifact : artifacts) {
            if (getMicrosoftRemediationKBsForVulnerabilityOnArtifact(vmd, artifact).size() > 0) return true;
            if (getMicrosoftRemediationUrlAndDescriptionForVulnerabilityOnArtifact(vmd, artifact).size() > 0)
                return true;
        }
        return false;
    }

    /**
     * See {@link StatisticsOverviewTable#VULNERABILITY_STATUS_MAPPER_ABSTRACTED} for more details.
     *
     * @param category The category to convert
     * @return The abstracted status
     */
    public String getFurtherAbstractedVulnerabilityCategory(final String category) {
        return StatisticsOverviewTable.VULNERABILITY_STATUS_MAPPER_ABSTRACTED.apply(category);
    }

    private static void filterVulnerabilityMetaDataForAdvisories(List<VulnerabilityMetaData> vmds, String filterCert) {
        vmds.removeIf(
                vmd -> {
                    String adv = vmd.getComplete("Advisories");
                    if (adv == null) return true;
                    JSONArray advisories = new JSONArray(adv);
                    for (int j = 0; j < advisories.length(); j++) {
                        if (advisories.optJSONObject(j).optString("source", "").equals(filterCert)) {
                            return false;
                        }
                    }
                    return true;
                }
        );
    }

    public StatisticsOverviewTable createUnmodifiedStatisticsOverviewTable(String filterCert, float threshold, Function<String, String> statusMapperFunction) {
        return StatisticsOverviewTable.fromInventoryUnmodified(this, filterCert, threshold, statusMapperFunction);
    }

    public StatisticsOverviewTable createModifiedStatisticsOverviewTable(String filterCert, float threshold, Function<String, String> statusMapperFunction) {
        return StatisticsOverviewTable.fromInventoryModified(this, filterCert, threshold, statusMapperFunction);
    }

    public static class StatisticsOverviewTable {

        private final Map<String, Map<String, Integer>> severityStatusCountMap = new LinkedHashMap<>();

        private void addSeverityCategory(String severityCategory) {
            severityStatusCountMap.putIfAbsent(normalize(severityCategory), new LinkedHashMap<>());
        }

        private void addStatus(String status) {
            final String normalizedStatus = normalize(status);
            severityStatusCountMap.values().forEach(m -> m.putIfAbsent(normalizedStatus, 0));
        }

        private void incrementCount(String severity, String status) {
            severity = normalize(severity);
            status = normalize(status);
            addSeverityCategory(severity);
            addStatus(status);
            severityStatusCountMap.get(severity).put(status, severityStatusCountMap.get(severity).get(status) + 1);
        }

        public List<String> getHeaders() {
            List<String> headers = new ArrayList<>();
            headers.add("Severity");
            headers.addAll(severityStatusCountMap.values().stream().findFirst().orElse(new LinkedHashMap<>()).keySet());
            return headers.stream().map(this::capitalizeWords).collect(Collectors.toList());
        }

        public List<String> getSeverityCategories() {
            return severityStatusCountMap.keySet().stream().map(this::capitalizeWords).collect(Collectors.toList());
        }

        public List<Integer> getCountsForSeverityCategory(String severityCategory) {
            severityCategory = normalize(severityCategory);
            List<Integer> counts = new ArrayList<>();
            for (String status : severityStatusCountMap.get(severityCategory).keySet()) {
                counts.add(severityStatusCountMap.get(severityCategory).get(status));
            }
            return counts;
        }

        /**
         * Checks if the table is empty.<br>
         * The table is considered empty if all cells have the value "0", except for the "% assessed" column.
         *
         * @return true if the table is empty, false otherwise.
         */
        public boolean isEmpty() {
            for (Map<String, Integer> m : severityStatusCountMap.values()) {
                for (Map.Entry<String, Integer> e : m.entrySet()) {
                    if (!e.getKey().equals("% assessed")) {
                        if (e.getValue() != 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        private String normalize(String s) {
            return s.toLowerCase();
        }

        private String capitalizeWords(String s) {
            if (s == null || s.isEmpty()) {
                return s;
            }
            return Arrays.stream(s.split(" "))
                    .map(word -> Character.toUpperCase(word.charAt(0)) + word.substring(1))
                    .collect(Collectors.joining(" "));
        }

        private static String getSeverityFromVMD(VulnerabilityMetaData vulnerabilityMetaData, boolean modified) {
            return ObjectUtils.firstNonNull(
                    modified ? vulnerabilityMetaData.getComplete("CVSS Modified Severity (v3)") : null,
                    vulnerabilityMetaData.getComplete("CVSS Unmodified Severity (v3)"),
                    modified ? vulnerabilityMetaData.getComplete("CVSS Modified Severity (v2)") : null,
                    vulnerabilityMetaData.getComplete("CVSS Unmodified Severity (v2)"),
                    "unset"
            );
        }

        private static String getStatusFromVMD(VulnerabilityMetaData vulnerabilityMetaData, float threshold, VulnerabilityReportAdapter adapter) {
            return adapter.getStatusText(vulnerabilityMetaData, threshold);
        }

        public static StatisticsOverviewTable fromInventoryUnmodified(VulnerabilityReportAdapter adapter, String filterCert, float threshold, Function<String, String> vulnerabilityStatusMapper) {
            return StatisticsOverviewTable.fromInventory(adapter, filterCert, threshold, false, vulnerabilityStatusMapper);
        }

        public static StatisticsOverviewTable fromInventoryModified(VulnerabilityReportAdapter adapter, String filterCert, float threshold, Function<String, String> vulnerabilityStatusMapper) {
            return StatisticsOverviewTable.fromInventory(adapter, filterCert, threshold, true, vulnerabilityStatusMapper);
        }

        private static StatisticsOverviewTable fromInventory(VulnerabilityReportAdapter adapter, String filterCert, float threshold, boolean useModifiedSeverity, Function<String, String> vulnerabilityStatusMapper) {
            final List<VulnerabilityMetaData> vmds = new ArrayList<>(adapter.inventory.getVulnerabilityMetaData());

            if (filterCert != null && !filterCert.isEmpty()) {
                filterVulnerabilityMetaDataForAdvisories(vmds, filterCert);
            }

            final StatisticsOverviewTable table = new StatisticsOverviewTable();

            // add the default severity categories in the case there are no vulnerabilities with that category
            for (String severityCategory : new String[]{"critical", "high", "medium", "low"}) {
                table.addSeverityCategory(severityCategory);
            }

            // the columns and rows have to be created first, for them to be added in the correct order below
            for (VulnerabilityMetaData vmd : vmds) {
                final String severity = StatisticsOverviewTable.getSeverityFromVMD(vmd, useModifiedSeverity);
                table.addSeverityCategory(severity);
            }
            final Set<String> allStatuses = new HashSet<>();
            for (VulnerabilityMetaData vmd : vmds) {
                final String status = vulnerabilityStatusMapper.apply(StatisticsOverviewTable.getStatusFromVMD(vmd, threshold, adapter));
                allStatuses.add(status);
            }
            allStatuses.stream().sorted((o1, o2) -> {
                final String[] order = new String[]{"reviewed", "affected", "potentially affected", "potential vulnerability", "not affected", "in review", "insignificant", "void"};
                return Integer.compare(Arrays.asList(order).indexOf(o1), Arrays.asList(order).indexOf(o2));
            }).forEach(table::addStatus);

            // now that the cells exist, count the individual severity and status combinations
            for (VulnerabilityMetaData vmd : vmds) {
                final String status = vulnerabilityStatusMapper.apply(StatisticsOverviewTable.getStatusFromVMD(vmd, threshold, adapter));
                final String severity = StatisticsOverviewTable.getSeverityFromVMD(vmd, useModifiedSeverity);

                table.incrementCount(severity, status);
            }

            if (useModifiedSeverity) {
                table.removeStatus("not applicable");
                table.removeStatus("void");
            }

            // add up the total number of vulnerabilities for each severity category
            for (Map.Entry<String, Map<String, Integer>> severityMap : table.severityStatusCountMap.entrySet()) {
                int total = 0;
                for (Map.Entry<String, Integer> statusMap : severityMap.getValue().entrySet()) {
                    total += statusMap.getValue();
                }
                severityMap.getValue().put("total", total);
            }

            // find the % of assessed vulnerabilities for each severity category
            for (Map.Entry<String, Map<String, Integer>> severityMap : table.severityStatusCountMap.entrySet()) {
                final int applicable = severityMap.getValue().getOrDefault("reviewed", 0);
                final int notApplicable = useModifiedSeverity ? 0 : severityMap.getValue().getOrDefault("not applicable", 0);
                final int inReview = severityMap.getValue().getOrDefault("in review", 0);
                final int insignificant = severityMap.getValue().getOrDefault("insignificant", 0);
                final int voidCat = severityMap.getValue().getOrDefault("void", 0);

                final int affected = severityMap.getValue().getOrDefault("affected", 0);
                final int potentiallyAffected = severityMap.getValue().getOrDefault("potentially affected", 0);
                final int notAffected = severityMap.getValue().getOrDefault("not affected", 0);

                if (vulnerabilityStatusMapper == VULNERABILITY_STATUS_MAPPER_DEFAULT) {
                    if (inReview == 0 && insignificant == 0) {
                        severityMap.getValue().put("% assessed", 100);
                    } else {
                        final int total = inReview + applicable + notApplicable + insignificant + voidCat;
                        final double ratio = ((double) (applicable + notApplicable + voidCat)) / total;

                        severityMap.getValue().put("% assessed", (int) (ratio * 100));
                    }

                } else if (vulnerabilityStatusMapper == VULNERABILITY_STATUS_MAPPER_ABSTRACTED) {
                    if (potentiallyAffected == 0 && insignificant == 0) {
                        severityMap.getValue().put("% assessed", 100);
                    } else {
                        final int total = affected + potentiallyAffected + notAffected + insignificant;
                        final double ratio = ((double) (affected + notAffected)) / total;

                        severityMap.getValue().put("% assessed", (int) (ratio * 100));
                    }
                }
            }

            // remove 'unset' if all but the '% assessed' column are 0
            if (table.severityStatusCountMap.containsKey("unset")
                    && table.severityStatusCountMap.get("unset").values().stream().filter(i -> i != 0).count() == 1) {
                table.severityStatusCountMap.remove("unset");
            }

            LOG.debug("Generated Overview Table for [{}] vulnerabilities:\n{}", vmds.size(), table);

            return table;
        }

        private void removeStatus(String status) {
            for (Map<String, Integer> m : severityStatusCountMap.values()) {
                m.remove(status);
            }
        }

        @Override
        public String toString() {
            final StringBuilder sb = new StringBuilder();

            final List<List<String>> rows = new ArrayList<>();
            rows.add(getHeaders());
            for (String severityCategory : getSeverityCategories()) {
                final List<String> row = new ArrayList<>();
                row.add(severityCategory);
                row.addAll(getCountsForSeverityCategory(severityCategory).stream().map(String::valueOf).collect(Collectors.toList()));
                rows.add(row);
            }

            final int[] columnWidths = new int[rows.get(0).size()];
            for (List<String> row : rows) {
                for (int i = 0; i < row.size(); i++) {
                    columnWidths[i] = Math.max(columnWidths[i], row.get(i).length());
                }
            }

            boolean isFirst = true;
            for (List<String> row : rows) {
                for (int i = 0; i < row.size(); i++) {
                    sb.append(String.format("%" + columnWidths[i] + "s", row.get(i)));
                    if (i < row.size() - 1) {
                        sb.append(" │ ");
                    }
                }
                sb.append("\n");

                if (isFirst) {
                    isFirst = false;
                    for (int i = 0; i < columnWidths.length; i++) {
                        sb.append(String.join("", Collections.nCopies(columnWidths[i], "─")));
                        if (i < columnWidths.length - 1) {
                            sb.append("─┼─");
                        }
                    }
                    sb.append("\n");
                }
            }

            return sb.toString();
        }

        public final static Function<String, String> VULNERABILITY_STATUS_MAPPER_DEFAULT = name -> {
            if ("Applicable".equalsIgnoreCase(name)) {
                return "Reviewed";
            }

            if ("Potential Vulnerability".equalsIgnoreCase(name)) {
                return "Reviewed";
            }

            return name;
        };

        /**
         * Where the category
         * <ul>
         *     <li>
         *         <code>not affected</code> covers vulnerabilities with status <code>not applicable</code> or
         *         <code>void</code>
         *     </li>
         *     <li>
         *         <code>potentially affected</code> covers vulnerabilities <code>in review</code> and have not yet been
         *         fully assessed (no category)
         *     </li>
         *     <li>
         *         <code>affected</code> covers reviewed and assesses as <code>applicable</code> vulnerabilities
         *     </li>
         * </ul>
         * see <code>AEAA-221</code> for more details.
         */
        public final static Function<String, String> VULNERABILITY_STATUS_MAPPER_ABSTRACTED = name -> {
            if (StringUtils.isEmpty(name)) { // in review
                return "potentially affected";
            }

            switch (name) {
                case VulnerabilityMetaData.STATUS_VALUE_APPLICABLE:
                case "reviewed":
                case "potential vulnerability":
                    return "affected";

                case VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE:
                case VulnerabilityMetaData.STATUS_VALUE_VOID:
                    return "not affected";

                case "in review":
                    return "potentially affected";

                default:
                    return name;
            }
        };

        public static Function<String, String> getStatusMapperFunction(String statusMapper) {
            if ("abstracted".equals(statusMapper)) {
                return StatisticsOverviewTable.VULNERABILITY_STATUS_MAPPER_ABSTRACTED;
            } else {
                return StatisticsOverviewTable.VULNERABILITY_STATUS_MAPPER_DEFAULT;
            }
        }
    }

    public boolean fileExists(String path) {
        if (path == null) return false;
        return new File(path).exists();
    }

    public static class LabelColor {
        private final String background;
        private final String foreground;

        LabelColor(String background, String foreground) {
            this.background = background;
            this.foreground = foreground;
        }

        public String getBackground() {
            return background;
        }

        public String getForeground() {
            return foreground;
        }
    }

    public static String modulateSeverityText(String severity) {
        if (severity == null) {
            return "n.a.";
        }
        return severity;
    }

    /**
     * Converts a HEX color into a label color by evaluating the brightness and setting the foreground to either black
     * or white depending on that.
     *
     * @param color The background color to use.
     * @return A LabelColor containing background and foreground colors.
     */
    public static LabelColor getLabelColor(String color) {
        if (color != null) {
            int rgb = Integer.parseInt(color.substring(1), 16);
            int r = (rgb >> 16) & 0xff;
            int g = (rgb >> 8) & 0xff;
            int b = (rgb) & 0xff;
            double luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            String backgroundColor = luma < 120 ? "white" : "black";
            return new LabelColor(color, backgroundColor);
        }
        return new LabelColor("#cfcfc4", "black");
    }

    public String getStatusText(final VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);
        if (status == null) {
            if (isBelowThreshold(vulnerabilityMetaData, threshold)) {
                status = "insignificant";
            } else {
                status = "in review";
            }
        }

        if ("applicable".equalsIgnoreCase(status)) {
            status = "potential vulnerability";
        }

        return status.toLowerCase();
    }

    private boolean isBelowThreshold(VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        final String maxScoreString = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.MAX_SCORE);
        return maxScoreString != null && Float.valueOf(maxScoreString) < threshold;
    }

    public String getPlainStatusText(final VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);
        if (status == null) {
            if (isBelowThreshold(vulnerabilityMetaData, threshold)) {
                status = "insignificant";
            } else {
                status = "in review";
            }
        }
        return status.toLowerCase();
    }

    public LabelColor getStatusLabelColor(String statusText) {
        switch (statusText) {
            case "in review":
                return new LabelColor("#84bfff", "black"); // pastel-blue
            case "not applicable":
                return new LabelColor("#77dd77", "black"); // pastel-green
            case "insignificant":
                return new LabelColor("#84bfff", "#black"); // pastel-blue
            case "potential vulnerability":
                return new LabelColor("#e3b2f2", "black"); // pastel-purple
            case "void":
                return new LabelColor("#636363", "white"); // strong-gray

            default:
                return new LabelColor("#ffcc00", "black"); // strong-yellow
        }
    }

    // FIXME: the whole status and label handling needs to be revised. Currently implemented very inefficiently
    //   Perhaps the inventory can be enhanced based on the given threshold. Such that we have an inventory
    //   reflecting the final status with threshold applied. Then this logic here is simplified.

    public boolean isPotentialVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "applicable":
                return true;
            case "in review":
                return true;
        }
        return false;
    }

    public boolean isVoidVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "unset": // this needs investigation; should not be required.
            case "void":
                return true;
        }
        return false;
    }

    public boolean isNotApplicableVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "not applicable":
                return true;
        }
        return false;
    }

    public boolean isInsignificantVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "insignificant":
                return true;
        }
        return false;
    }

    public boolean isInReviewVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "in review":
                return true;
        }
        return false;
    }

    public boolean isReviewedVulnerability(VulnerabilityMetaData vmd, float threshold) {
        switch (getPlainStatusText(vmd, threshold)) {
            case "applicable":
                return true;
        }
        return false;
    }

    /**
     * Evaluates the color of the specified severity category using the date availble in the inventory.
     * In case no color information is available, the implementation falls back to pastel-gray.
     *
     * @param severityCategory The security category to evaluate the color for.
     * @return Color string.
     */
    public String evaluateColor(String severityCategory) {
        if (severityCategory != null) {
            for (VulnerabilityMetaData vmd : inventory.getVulnerabilityMetaData()) {

                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Unmodified Severity (max)"))) {
                    return vmd.get("CVSS Unmodified Severity Color (max)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Unmodified Severity (v2)"))) {
                    return vmd.get("CVSS Unmodified Severity Color (v2)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Unmodified Severity (v3)"))) {
                    return vmd.get("CVSS Unmodified Severity Color (v3)");
                }

                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Modified Severity (max)"))) {
                    return vmd.get("CVSS Modified Severity Color (max)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Modified Severity (v2)"))) {
                    return vmd.get("CVSS Modified Severity Color (v2)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Modified Severity (v3)"))) {
                    return vmd.get("CVSS Modified Severity Color (v3)");
                }

            }

            // use defaults:
            switch (severityCategory.toLowerCase()) {
                case "none":
                    return "#cacecf";
                case "low":
                    return "#ffcc00";
                case "medium":
                    return "#ff9b05";
                case "high":
                    return "#ff5a0e";
                case "critical":
                    return "#ff172d";
            }
        }

        return "#cacecf"; // pastel-gray
    }

}
