/*
 * Copyright 2009-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report;

import org.apache.commons.math3.exception.NotANumberException;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.model.Artifact;
import org.metaeffekt.core.inventory.processor.model.CertMetaData;
import org.metaeffekt.core.inventory.processor.model.Inventory;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.springframework.util.StringUtils;

import java.io.File;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Dedicated adapter for producing the detailed vulnerability content.
 */
public class VulnerabilityReportAdapter {

    public final static String CVSS_SCORING_PREFERENCE_LATEST_FIRST = "v3 v2";

    public final static String CVSS_SCORING_PREFERENCE_MAX = "max v3 v2";

    protected final Inventory inventory;

    protected final String scoringPreference;

    protected final float insignificantThreshold;

    public VulnerabilityReportAdapter(Inventory inventory, String scoringPreference, float insignificantThreshold) {
        this.inventory = inventory;
        this.scoringPreference = scoringPreference;
        this.insignificantThreshold = insignificantThreshold;
    }

    public VulnerabilityReportAdapter(Inventory inventory) {
        this.inventory = inventory;
        this.scoringPreference = CVSS_SCORING_PREFERENCE_LATEST_FIRST;
        this.insignificantThreshold = 7;
    }

    public List<VulnerabilityMetaData> getVulnerabilityMetaDataForDetailReport() {
        final List<VulnerabilityMetaData> vulnerabilityMetaDataList = VulnerabilityMetaData.
                filterVulnerabilitiesForDetails(inventory.getVulnerabilityMetaData(), insignificantThreshold);
        return vulnerabilityMetaDataList.stream()
                .sorted(VulnerabilityMetaData.VULNERABILITY_COMPARATOR_NAME_DESC)
                .collect(Collectors.toList());
    }

    public boolean hasDetails(VulnerabilityMetaData vulnerabilityMetaData) {
        return VulnerabilityMetaData.hasDetails(vulnerabilityMetaData, insignificantThreshold);
    }

    // FIXME: as the methods does not require any information from the local class it should be rather a
    //        method on VulnerabilityMetaData or on Advisory data not to mix model with supporting classes.
    //        Revise usages in core and artifact analysis.
    public List<AdvisoryData> getAdvisories(VulnerabilityMetaData vulnerabilityMetaData, String[] includeAdvisoryTypes) {
        final String advisories = vulnerabilityMetaData.getComplete("Advisories");

        final List<AdvisoryData> advisoryDataList = (advisories != null) ?
                AdvisoryData.fromJson(new JSONArray(advisories)) : new ArrayList<>();

        if (advisories != null && includeAdvisoryTypes != null) {
            return filterIncludeAdvisoryTypes(advisoryDataList, includeAdvisoryTypes);
        } else {
            return advisoryDataList;
        }
    }

    public String getAdvisoryHeader(String[] includeAdvisoryTypes) {
        if (includeAdvisoryTypes == null || includeAdvisoryTypes.length == 0) {
            return "Alerts / Notices / Updates";
        }
        final StringBuilder sb = new StringBuilder();
        List<String> set = Arrays.asList(includeAdvisoryTypes);
        if (set.contains("all")) {
            return "Alerts / Notices / Updates";
        }
        if (set.contains("alert")) sb.append("Alerts");
        if (set.contains("notice")) {
            if (sb.length() > 0) sb.append(" / ");
            sb.append("Notices");
        }
        if (set.contains("news")) {
            if (sb.length() > 0) sb.append(" / ");
            sb.append("Updates");
        }
        return sb.toString();
    }

    public String hyperlinkedAdvisory(AdvisoryData advisoryData) {
        final StringBuilder sb = new StringBuilder();
        appendHyperlink(sb, advisoryData);
        return sb.toString();
    }

    public String hyperlinkedAdvisories(List<AdvisoryData> advisoryDataList) {
        Map<String, AdvisoryData> map = new HashMap<>();

        for (AdvisoryData advisoryData : advisoryDataList) {
            map.put(advisoryData.getId(), advisoryData);
        }

        List<String> orderedIds = new ArrayList<>(map.keySet());
        Collections.sort(orderedIds);

        final StringBuilder sb = new StringBuilder();
        for (String id : orderedIds) {
            AdvisoryData advisoryData = map.get(id);
            if (sb.length() > 0) sb.append(", ");
            appendHyperlink(sb, advisoryData);
        }

        return sb.toString();
    }

    private void appendHyperlink(StringBuilder sb, AdvisoryData advisoryData) {
        sb.append("<xref href=\"").
                append(advisoryData.getUrl()).append("\" type=\"html\" scope=\"external\">").
                append(advisoryData.getId()).append("</xref>");
    }

    public List<AdvisoryData> filterType(List<AdvisoryData> advisoryDataList, String type) {
        return advisoryDataList.stream().filter(a -> type.equalsIgnoreCase(a.getType())).collect(Collectors.toList());
    }

    private boolean isAdvisoryTypeIncluded(String advisoryType, String[] includeAdvisoryTypes) {
        if (includeAdvisoryTypes == null) {
            return true;
        } else if (includeAdvisoryTypes.length == 0) {
            return false;
        }

        // includeAdvisoryTypes might contain 'all', which means all advisory types should be included
        if (Arrays.stream(includeAdvisoryTypes).anyMatch(e -> e.equalsIgnoreCase("all"))) {
            return true;
        }

        for (String includeAdvisoryType : includeAdvisoryTypes) {
            if (includeAdvisoryType.equalsIgnoreCase(advisoryType)) {
                return true;
            }
        }

        return false;
    }

    public List<AdvisoryData> filterIncludeAdvisoryTypes(List<AdvisoryData> advisoryDataList, String[] includeAdvisoryTypes) {
        return advisoryDataList.stream()
                .filter(a -> isAdvisoryTypeIncluded(a.getType(), includeAdvisoryTypes))
                .collect(Collectors.toList());
    }

    public List<CertMetaData> getCertMetaData() {
        return inventory.getCertMetaData();
    }

    public List<CertMetaData> getNewCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_NEW);
    }

    public List<CertMetaData> getInReviewCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_IN_REVIEW);
    }

    public List<CertMetaData> getReviewedCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_REVIEWED);
    }

    public List<CertMetaData> getUnaffectedCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_UNAFFECTED);
    }

    public List<CertMetaData> getUnclassifiedCertMetaData() {
        return getCertMetaDataByStatus(null);
    }

    public List<CertMetaData> getCertMetaDataByStatus(String status) {
        return inventory.getCertMetaData().stream()
                .filter(e -> Objects.equals(status, e.get(CertMetaData.Attribute.REVIEW_STATUS)))
                .sorted(CertMetaData.CERT_COMPARATOR_LAST_UPDATED_DESC)
                .collect(Collectors.toList());
    }

    public List<Artifact> getAffectedComponents(VulnerabilityMetaData vmd) {
        String name = vmd.get(VulnerabilityMetaData.Attribute.NAME);

        return inventory.getArtifacts().stream().filter(
                a -> getCveForArtifact(a).stream().anyMatch(
                        cve -> cve.get(VulnerabilityMetaData.Attribute.NAME).equals(name))
        ).collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> getCveForArtifact(Artifact artifact) {
        List<VulnerabilityMetaData> vulnerabilities = new ArrayList<>();
        String vulnerabilitiesString = artifact.getComplete(Artifact.Attribute.VULNERABILITY);

        if (vulnerabilitiesString != null) {
            for (String vulnerability : vulnerabilitiesString.split(", ?")) {
                String name = vulnerability.trim().replaceAll(" .+", "");
                VulnerabilityMetaData vmd = findVulnerabilityMetaData(name);
                if (vmd != null) {
                    vulnerabilities.add(vmd);
                }
            }
        }

        return vulnerabilities;
    }

    private VulnerabilityMetaData findVulnerabilityMetaData(String name) {
        for (VulnerabilityMetaData vmd : inventory.getVulnerabilityMetaData()) {
            if (vmd.get(VulnerabilityMetaData.Attribute.NAME).equals(name)) {
                return vmd;
            }
        }

        return null;
    }

    public List<KeywordsInstance> parseKeywordsFromInputJsonArrayString(String input) {
        if (org.apache.commons.lang3.StringUtils.isEmpty(input) || "[]".equals(input)) {
            return new ArrayList<>();

        } else if (!input.startsWith("[")) {
            LOG.warn("Invalid input for keywords: {}", input);
            return new ArrayList<>();
        }

        final List<KeywordsInstance> keywords = new ArrayList<>();
        final JSONArray jsonArray = new JSONArray(input);
        for (int i = 0; i < jsonArray.length(); i++) {
            keywords.add(new KeywordsInstance(jsonArray.getJSONObject(i)));
        }

        return keywords;
    }

    public boolean notNull(Object input) {
        return input != null;
    }

    /* cvss score determination by method start */

    public String getUnmodifiedCvssScoreByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Unmodified Overall");
    }

    public String getModifiedCvssScoreByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Modified Overall");
    }

    public String getUnmodifiedCvssSeverityByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Unmodified Severity");
    }

    public String getModifiedCvssSeverityByScoringPreference(VulnerabilityMetaData vmd, String preference) {
        return getCvssScoreByScoringPreference(vmd, preference, "Modified Severity");
    }

    public List<VulnerabilityMetaData> sortVulnerabilitiesByUnmodifiedCvssScore(List<VulnerabilityMetaData> vulnerabilities) {
        if (vulnerabilities == null) return null;
        return vulnerabilities.stream().sorted((v1, v2) -> {
            final String cvssScore1 = getUnmodifiedCvssScoreByScoringPreference(v1, scoringPreference);
            final String cvssScore2 = getUnmodifiedCvssScoreByScoringPreference(v2, scoringPreference);

            if (cvssScore1.equals("N/A") && cvssScore2.equals("N/A")) {
                return 0;
            } else if (cvssScore1.equals("N/A")) {
                return 1;
            } else if (cvssScore2.equals("N/A")) {
                return -1;
            } else {
                return Double.compare(Double.parseDouble(cvssScore2), Double.parseDouble(cvssScore1));
            }
        }).collect(Collectors.toList());
    }

    private String getCvssScoreByScoringPreference(VulnerabilityMetaData vmd, String preference, String type) {
        final String[] parts = preference.replace(", ", ",").split(" ");

        for (String part : parts) {
            if (part.startsWith("v3")) {
                if (vmd.has("CVSS " + type + " (v3)")) {
                    return vmd.get("CVSS " + type + " (v3)");
                }

            } else if (part.startsWith("v2")) {
                if (vmd.has("CVSS " + type + " (v2)")) {
                    return vmd.get("CVSS " + type + " (v2)");
                }

            } else if (part.startsWith("max")) {
                if (vmd.has("CVSS " + type + " (v3)") && vmd.has("CVSS " + type + " (v2)") && type.contains("Overall")) {
                    return (int) (Math.max(Double.parseDouble(vmd.get("CVSS " + type + " (v3)")), Double.parseDouble(vmd.get("CVSS " + type + " (v2)"))) * 100) / 100.0 + "";
                } else if (vmd.has("CVSS " + type + " (max)")) {
                    return vmd.get("CVSS " + type + " (max)");
                }
            }
        }

        return "N/A";
    }

    /* components start */

    public List<String> getComponentsFromInventory() {
        return inventory.getArtifacts().stream().map(Artifact::getComponent).distinct().collect(Collectors.toList());
    }

    public List<Artifact> getArtifactsForComponent(String component) {
        if (component == null) return Collections.emptyList();
        return inventory.getArtifacts().stream()
                .filter(a -> a.getComponent() != null && a.getComponent().equals(component))
                .collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> getVulnerabilitiesForArtifact(Artifact artifact) {
        if (artifact == null) return Collections.emptyList();
        return this.getCveForArtifact(artifact).stream()
                .sorted(VulnerabilityMetaData.VULNERABILITY_COMPARATOR_OVERALL_SCORE)
                .collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> getVulnerabilitiesForComponent(String component) {
        if (component == null) return Collections.emptyList();
        return this.getArtifactsForComponent(component).stream()
                .flatMap(a -> getVulnerabilitiesForArtifact(a).stream())
                .distinct()
                .collect(Collectors.toList());
    }

    /* components end, ms start */

    public List<String> getMicrosoftRemediationKBsForVulnerabilityOnArtifact(VulnerabilityMetaData vmd, Artifact artifact) {
        // the set ensures, we do not collect duplicates
        final Set<String> kbIdentifiers = new HashSet<>();
        if (artifact.has("MS Remediations")) {
            final String vulnerabilityName = vmd.get(VulnerabilityMetaData.Attribute.NAME);
            final JSONObject remediationForVulnerability = new JSONObject(artifact.getComplete("MS Remediations"));
            final JSONArray remediationArray = remediationForVulnerability.optJSONArray(vulnerabilityName);
            if (remediationArray != null) {
                for (int i = 0; i < remediationArray.length(); i++) {
                    final JSONObject remediation = remediationArray.optJSONObject(i);
                    String kb = remediation.optString("kb", "").trim();
                    if (StringUtils.hasText(kb)) {
                        if (kb.startsWith("KB")) {
                            kbIdentifiers.add(kb);
                        } else {
                            kbIdentifiers.add("KB" + kb);
                        }
                    }
                }
            }
        }

        // return as sorted list
        return kbIdentifiers.stream().sorted().collect(Collectors.toList());
    }

    public Map<String, String> getMicrosoftRemediationUrlAndDescriptionForVulnerabilityOnArtifact(VulnerabilityMetaData vmd, Artifact artifact) {
        final Map<String, String> kbIdentifiers = new HashMap<>();

        if (artifact.has("MS Remediations")) {
            String vulnerabilityName = vmd.get(VulnerabilityMetaData.Attribute.NAME);
            JSONObject remediationForVulnerability = new JSONObject(artifact.getComplete("MS Remediations"));

            JSONArray remediationArray = remediationForVulnerability.optJSONArray(vulnerabilityName);
            if (remediationArray != null) {
                for (int i = 0; i < remediationArray.length(); i++) {
                    JSONObject remediation = remediationArray.optJSONObject(i);
                    if (remediation.has("url")) {
                        String url = remediation.optString("url", "N/A");
                        String description = remediation.optString("description", url);
                        kbIdentifiers.put(url, description);
                    }
                }
            }
        }

        return kbIdentifiers;
    }

    public boolean hasVulnerabilityMicrosoftRemediationInformationOnArtifact(VulnerabilityMetaData vmd, Collection<Artifact> artifacts) {
        if (vmd == null) return false;
        for (Artifact artifact : artifacts) {
            if (getMicrosoftRemediationKBsForVulnerabilityOnArtifact(vmd, artifact).size() > 0) return true;
            if (getMicrosoftRemediationUrlAndDescriptionForVulnerabilityOnArtifact(vmd, artifact).size() > 0)
                return true;
        }
        return false;
    }

    /* ms end, statistics table start */

    /**
     * See {@link StatisticsOverviewTable#VULNERABILITY_STATUS_MAPPER_ABSTRACTED} for more details.
     *
     * @param category The category to convert
     * @return The abstracted status
     */
    public String getFurtherAbstractedVulnerabilityCategory(final String category) {
        return StatisticsOverviewTable.VULNERABILITY_STATUS_MAPPER_ABSTRACTED.apply(category);
    }

    public StatisticsOverviewTable createUnmodifiedStatisticsOverviewTable(String filterCert, Function<String, String> statusMapperFunction) {
        return StatisticsOverviewTable.fromInventoryUnmodified(this, filterCert, statusMapperFunction);
    }

    public StatisticsOverviewTable createModifiedStatisticsOverviewTable(String filterCert, Function<String, String> statusMapperFunction) {
        return StatisticsOverviewTable.fromInventoryModified(this, filterCert, statusMapperFunction);
    }

    /* statistics table end, utilities start */

    public boolean fileExists(String path) {
        if (path == null) return false;
        return new File(path).exists();
    }

    public static String modulateSeverityText(String severity) {
        if (severity == null) {
            return "n.a.";
        }
        return severity;
    }

    /**
     * Converts a HEX color into a label color by evaluating the brightness and setting the foreground to either black
     * or white depending on that.
     *
     * @param color The background color to use.
     * @return A LabelColor containing background and foreground colors.
     */
    public static LabelColor getLabelColor(String color) {
        if (color != null) {
            int rgb = Integer.parseInt(color.substring(1), 16);
            int r = (rgb >> 16) & 0xff;
            int g = (rgb >> 8) & 0xff;
            int b = (rgb) & 0xff;
            double luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            String backgroundColor = luma < 120 ? "white" : "black";
            return new LabelColor(color, backgroundColor);
        }
        return new LabelColor("#cfcfc4", "black");
    }

    public String getStatusText(final VulnerabilityMetaData vulnerabilityMetaData) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);

        // evaluate implicit status based on threshold
        if (!StringUtils.hasText(status) ||
                vulnerabilityMetaData.isStatus(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW)) {
            if (isBelowThreshold(vulnerabilityMetaData)) {
                status = "insignificant";
            } else {
                status = "in review";
            }
        }
        return status.toLowerCase();
    }

    /**
     * Implements to CVSSv3 over CVSSv2 strategy to check whether the vulnerability is below the threshold.
     *
     * @param vulnerabilityMetaData
     *
     * @return Returns <code>true</code> is the {@link VulnerabilityMetaData} relevant score is below the
     *    insignificant threshold.
     */
    private boolean isBelowThreshold(VulnerabilityMetaData vulnerabilityMetaData) {
        final Float score = getFloat(getUnmodifiedCvssScoreByScoringPreference(vulnerabilityMetaData, scoringPreference));
        return score != null && score < insignificantThreshold;
    }

    private static Float getFloat(String maxScoreString) {
        try {
            return StringUtils.hasText(maxScoreString) ? Float.valueOf(maxScoreString) : null;
        } catch (NumberFormatException e) {
            // ignore the exception; the score may be N/A
        }
        return null;
    }

    public String getPlainStatusText(final VulnerabilityMetaData vulnerabilityMetaData) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);
        if (status == null) {
            if (isBelowThreshold(vulnerabilityMetaData)) {
                status = "insignificant";
            } else {
                status = "in review";
            }
        }
        return status.toLowerCase();
    }

    public LabelColor getStatusLabelColor(String statusText) {
        switch (statusText) {
            case "in review":
                return new LabelColor("#84bfff", "black"); // pastel-blue
            case "not applicable":
                return new LabelColor("#77dd77", "black"); // pastel-green
            case "insignificant":
                return new LabelColor("#84bfff", "#black"); // pastel-blue
            case "potential vulnerability": // deprecated; kept due to compatibility concerns
                return new LabelColor("#e3b2f2", "black"); // pastel-purple
            case "potential risk":
                return new LabelColor("#e3b2f2", "black"); // pastel-purple
            case "void":
                return new LabelColor("#636363", "white"); // strong-gray

            default:
                return new LabelColor("#ffcc00", "black"); // strong-yellow
        }
    }

    // FIXME: the whole status and label handling needs to be revised. Currently implemented very inefficiently
    //   Perhaps the inventory can be enhanced based on the given threshold. Such that we have an inventory
    //   reflecting the final status with threshold applied. Then this logic here is simplified.

    public boolean isApplicableVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "applicable":
                return true;
        }
        return false;
    }

    public boolean isPotentialVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "applicable":
                return true;
            case "in review":
                return true;
        }
        return false;
    }

    public boolean isVoidVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "unset": // this needs investigation; should not be required.
            case "void":
                return true;
        }
        return false;
    }

    public boolean isNotApplicableVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "not applicable":
                return true;
        }
        return false;
    }

    public boolean isInsignificantVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "insignificant":
                return true;
        }
        return false;
    }

    public boolean isInReviewVulnerability(VulnerabilityMetaData vmd) {
        switch (getPlainStatusText(vmd)) {
            case "in review":
                return true;
        }
        return false;
    }

    public boolean isReviewedVulnerability(VulnerabilityMetaData vmd) {
        // a vulnerability is reviewed, when the status attribute is provided
        if (vmd == null) return false;
        return vmd.get(VulnerabilityMetaData.Attribute.STATUS) != null;
    }

    /**
     * Evaluates the color of the specified severity category using the date availble in the inventory.
     * In case no color information is available, the implementation falls back to pastel-gray.
     *
     * @param severityCategory The security category to evaluate the color for.
     * @return Color string.
     */
    public String evaluateColor(String severityCategory) {
        if (severityCategory != null) {
            for (VulnerabilityMetaData vmd : inventory.getVulnerabilityMetaData()) {

                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Unmodified Severity (max)"))) {
                    return vmd.get("CVSS Unmodified Severity Color (max)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Unmodified Severity (v2)"))) {
                    return vmd.get("CVSS Unmodified Severity Color (v2)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Unmodified Severity (v3)"))) {
                    return vmd.get("CVSS Unmodified Severity Color (v3)");
                }

                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Modified Severity (max)"))) {
                    return vmd.get("CVSS Modified Severity Color (max)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Modified Severity (v2)"))) {
                    return vmd.get("CVSS Modified Severity Color (v2)");
                }
                if (severityCategory.equalsIgnoreCase(vmd.get("CVSS Modified Severity (v3)"))) {
                    return vmd.get("CVSS Modified Severity Color (v3)");
                }

            }

            return getSeverityLabelColor(severityCategory);
        }

        return "#cacecf";
    }

    public String getSeverityLabelColor(String severityCategory) {
        // use defaults:
        switch (severityCategory.toLowerCase()) {
            case "none":
                return "#cacecf";
            case "low":
                return "#ffcc00";
            case "medium":
                return "#ff9b05";
            case "high":
                return "#ff5a0e";
            case "critical":
                return "#ff172d";
        }
        return "#cacecf"; // pastel-gray
    }

    public VulnerabilitySummaryData getVulnerabilitySummaryData() {
        return new VulnerabilitySummaryData(inventory, this, scoringPreference);
    }

    public List<VulnerabilityMetaData> collectAffectedCategory() {
        return inventory.getVulnerabilityMetaData().stream().filter(vmd -> {
            boolean hasStatus = vmd.has(VulnerabilityMetaData.Attribute.STATUS.getKey()) && !vmd.get(VulnerabilityMetaData.Attribute.STATUS).isEmpty();
            boolean isCategoryAffected = vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE) || vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT);
            return hasStatus && isCategoryAffected;
        }).collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> collectPotentiallyAffectedCategory() {
        return inventory.getVulnerabilityMetaData().stream().filter(vmd -> {
            final boolean hasStatus = vmd.has(VulnerabilityMetaData.Attribute.STATUS.getKey()) && !vmd.get(VulnerabilityMetaData.Attribute.STATUS).isEmpty();
            final boolean isCategoryPotentiallyAffected = !hasStatus || vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_IN_REVIEW);

            // NOTE: in review used to be an implicit status, but now can be explicitly set. The above implementation
            //   anticipates this.

            return isCategoryPotentiallyAffected;
        }).collect(Collectors.toList());
    }

    public List<VulnerabilityMetaData> collectNotAffectedCategory() {
        return inventory.getVulnerabilityMetaData().stream().filter(vmd -> {
            boolean hasStatus = vmd.has(VulnerabilityMetaData.Attribute.STATUS.getKey()) && !vmd.get(VulnerabilityMetaData.Attribute.STATUS).isEmpty();
            boolean isCategoryNotAffected = vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE) || vmd.isStatus(VulnerabilityMetaData.STATUS_VALUE_VOID);
            return hasStatus && isCategoryNotAffected;
        }).collect(Collectors.toList());
    }

}
