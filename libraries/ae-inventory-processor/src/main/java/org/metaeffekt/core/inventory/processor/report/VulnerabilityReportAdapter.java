/*
 * Copyright 2009-2021 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report;

import org.json.JSONArray;
import org.metaeffekt.core.inventory.processor.model.Inventory;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Dedicated adapter for producing the detailed vulnerability content.
 */
public class VulnerabilityReportAdapter {

    private Inventory inventory;

    public VulnerabilityReportAdapter(Inventory inventory) {
        this.inventory = inventory;
    }

    public List<VulnerabilityMetaData> getVulnerabilityMetaDataForDetailReport(float threshold) {
        return VulnerabilityMetaData.filterVulnerabilitiesForDetails(inventory.getVulnerabilityMetaData(), threshold);
    }

    public boolean hasDetails(VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        return VulnerabilityMetaData.hasDetails(vulnerabilityMetaData, threshold);
    }

    public List<AdvisoryData> getAdvisories(VulnerabilityMetaData vulnerabilityMetaData) {
        List<AdvisoryData> advisoryDataList = new ArrayList<>();

        final String advisories = vulnerabilityMetaData.getComplete("Advisories");
        if (advisories != null) {
            JSONArray advisoriesJsonArray = new JSONArray(advisories);
            advisoryDataList.addAll(AdvisoryData.fromJson(advisoriesJsonArray));
        }

        return advisoryDataList;
    }

    public String hyperlinkedAdvisory(AdvisoryData advisoryData) {
        final StringBuilder sb = new StringBuilder();
        appendHyperlink(sb, advisoryData);
        return sb.toString();
    }

    public String hyperlinkedAdvisories(List<AdvisoryData> advisoryDataList) {
        Map<String, AdvisoryData> map = new HashMap<>();

        for (AdvisoryData advisoryData : advisoryDataList) {
            map.put(advisoryData.getId(), advisoryData);
        }

        List<String> orderedIds = new ArrayList<>(map.keySet());
        Collections.sort(orderedIds);

        final StringBuilder sb = new StringBuilder();
        for (String id : orderedIds) {
            AdvisoryData advisoryData = map.get(id);
            if (sb.length() > 0) sb.append(", ");
            appendHyperlink(sb, advisoryData);
        }

        return sb.toString();
    }

    private void appendHyperlink(StringBuilder sb, AdvisoryData advisoryData) {
        sb.append("<xref href=\"").
                append(advisoryData.getUrl()).append("\" type=\"html\" scope=\"external\">").
                append(advisoryData.getId()).append("</xref>");
    }

    public List<AdvisoryData> filterType(List<AdvisoryData> advisoryDataList, String type) {
        return advisoryDataList.stream().filter(a -> type.equalsIgnoreCase(a.getType())).collect(Collectors.toList());
    }

    public static class LabelColor {
        private String background;
        private String foreground;

        LabelColor(String background, String foreground) {
            this.background = background;
            this.foreground = foreground;
        }

        public String getBackground() {
            return background;
        }

        public String getForeground() {
            return foreground;
        }
    }

    public static String modulateSeverityText(String severity) {
        if (severity == null) {
            return "n.a.";
        }
        return severity;
    }

    public static LabelColor getSeverityLabelColor(String severity) {
        if (severity != null) {
            if ("Low".equalsIgnoreCase(severity)) return new LabelColor("#ffcc00", "black");
            if ("Medium".equalsIgnoreCase(severity)) return new LabelColor("#ff9b05", "black");
            if ("High".equalsIgnoreCase(severity)) return new LabelColor("#ff5a0e", "white");
            if ("Critical".equalsIgnoreCase(severity)) return new LabelColor("#ff172d", "white");
        }
        return new LabelColor("#cfcfc4", "black");
    }

    public String getStatusText(VulnerabilityMetaData vulnerabilityMetaData) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);
        if (status == null) {
            status = "in review";
        }

        if ("applicable".equalsIgnoreCase(status)) {
            status = "potential vulnerability";
        }

        if ("not applicable".equalsIgnoreCase(status)) {
            status = "not applicable";
        }

        if ("insignificant".equalsIgnoreCase(status)) {
            status = "insignificant";
        }

        return status;
    }

    public LabelColor getStatusLabelColor(String statusText) {
        switch (statusText) {
            case "in review":
                return new LabelColor("#cacecf", "black"); // pastel-gray
            case "not applicable":
                return new LabelColor("#77dd77", "black"); // pastel-green
            case "insignificant":
                return new LabelColor("#84bfff", "#black"); // pastel-blue
            case "potential vulnerability":
                return new LabelColor("#e3b2f2", "black"); // pastel-purple

            default:
                return new LabelColor("#ffcc00", "black"); // strong-yellow
        }
    }

}
