/*
 * Copyright 2009-2021 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report;

import org.json.JSONArray;
import org.metaeffekt.core.inventory.processor.model.CertMetaData;
import org.metaeffekt.core.inventory.processor.model.Inventory;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Dedicated adapter for producing the detailed vulnerability content.
 */
public class VulnerabilityReportAdapter {

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityReportAdapter.class);

    private final Inventory inventory;

    public VulnerabilityReportAdapter(Inventory inventory) {
        this.inventory = inventory;
    }

    public List<VulnerabilityMetaData> getVulnerabilityMetaDataForDetailReport(float threshold) {
        List<VulnerabilityMetaData> filtered = VulnerabilityMetaData.filterVulnerabilitiesForDetails(inventory.getVulnerabilityMetaData(), threshold);
        filtered.sort(VulnerabilityMetaData.VULNERABILITY_COMPARATOR_OVERALL_SCORE);
        return filtered;
    }

    public boolean hasDetails(VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        return VulnerabilityMetaData.hasDetails(vulnerabilityMetaData, threshold);
    }

    public static List<AdvisoryData> getAdvisories(VulnerabilityMetaData vulnerabilityMetaData) {
        List<AdvisoryData> advisoryDataList = new ArrayList<>();

        final String advisories = vulnerabilityMetaData.getComplete("Advisories");
        if (advisories != null) {
            JSONArray advisoriesJsonArray = new JSONArray(advisories);
            advisoryDataList.addAll(AdvisoryData.fromJson(advisoriesJsonArray));
        }

        return advisoryDataList;
    }

    public String hyperlinkedAdvisory(AdvisoryData advisoryData) {
        final StringBuilder sb = new StringBuilder();
        appendHyperlink(sb, advisoryData);
        return sb.toString();
    }

    public String hyperlinkedAdvisories(List<AdvisoryData> advisoryDataList) {
        Map<String, AdvisoryData> map = new HashMap<>();

        for (AdvisoryData advisoryData : advisoryDataList) {
            map.put(advisoryData.getId(), advisoryData);
        }

        List<String> orderedIds = new ArrayList<>(map.keySet());
        Collections.sort(orderedIds);

        final StringBuilder sb = new StringBuilder();
        for (String id : orderedIds) {
            AdvisoryData advisoryData = map.get(id);
            if (sb.length() > 0) sb.append(", ");
            appendHyperlink(sb, advisoryData);
        }

        return sb.toString();
    }

    private void appendHyperlink(StringBuilder sb, AdvisoryData advisoryData) {
        sb.append("<xref href=\"").
                append(advisoryData.getUrl()).append("\" type=\"html\" scope=\"external\">").
                append(advisoryData.getId()).append("</xref>");
    }

    public List<AdvisoryData> filterType(List<AdvisoryData> advisoryDataList, String type) {
        return advisoryDataList.stream().filter(a -> type.equalsIgnoreCase(a.getType())).collect(Collectors.toList());
    }

    public List<CertMetaData> getCertMetaData() {
        return inventory.getCertMetaData();
    }

    public List<CertMetaData> getNewCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_NEW);
    }

    public List<CertMetaData> getInReviewCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_IN_REVIEW);
    }

    public List<CertMetaData> getReviewedCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_REVIEWED);
    }

    public List<CertMetaData> getUnaffectedCertMetaData() {
        return getCertMetaDataByStatus(CertMetaData.STATUS_VALUE_UNAFFECTED);
    }

    public List<CertMetaData> getUnclassifiedCertMetaData() {
        return getCertMetaDataByStatus(null);
    }

    public List<CertMetaData> getCertMetaDataByStatus(String status) {
        return inventory.getCertMetaData().stream()
                .filter(e -> Objects.equals(status, e.get(CertMetaData.Attribute.REVIEW_STATUS)))
                .sorted(CertMetaData.CERT_COMPARATOR_LAST_UPDATED_DESC)
                .collect(Collectors.toList());
    }

    public StatisticsOverviewTable createStatisticsOverviewTable() {
        return createStatisticsOverviewTable(null);
    }

    public StatisticsOverviewTable createStatisticsOverviewTable(String filterCert) {
        return StatisticsOverviewTable.generateFromInventory(inventory, filterCert);
    }

    private static void filterVulnerabilityMetaDataForAdvisories(List<VulnerabilityMetaData> vmds, String filterCert) {
        vmds.removeIf(
                vmd -> {
                    String adv = vmd.getComplete("Advisories");
                    if (adv == null) return true;
                    JSONArray advisories = new JSONArray(adv);
                    for (int j = 0; j < advisories.length(); j++) {
                        if (advisories.optJSONObject(j).optString("source", "").equals(filterCert)) {
                            return false;
                        }
                    }
                    return true;
                }
        );
    }

    public static class StatisticsOverviewTable {
        private final Map<String, Map<String, Integer>> severityStatusCountMap = new LinkedHashMap<>();

        private void addSeverityCategory(String severityCategory) {
            severityStatusCountMap.putIfAbsent(normalize(severityCategory), new LinkedHashMap<>());
        }

        private void addStatus(String status) {
            final String normalizedStatus = normalize(status);
            severityStatusCountMap.values().forEach(m -> m.putIfAbsent(normalizedStatus, 0));
        }

        private void incrementCount(String severity, String status) {
            severity = normalize(severity);
            status = normalize(status);
            addSeverityCategory(severity);
            addStatus(status);
            severityStatusCountMap.get(severity).put(status, severityStatusCountMap.get(severity).get(status) + 1);
        }

        public List<String> getHeaders() {
            List<String> headers = new ArrayList<>();
            headers.add("Severity");
            headers.addAll(severityStatusCountMap.values().stream().findFirst().orElse(new LinkedHashMap<>()).keySet());
            return headers.stream().map(this::capitalizeWords).collect(Collectors.toList());
        }

        public List<String> getSeverityCategories() {
            return severityStatusCountMap.keySet().stream().map(this::capitalizeWords).collect(Collectors.toList());
        }

        public List<Integer> getCountsForSeverityCategory(String severityCategory) {
            severityCategory = normalize(severityCategory);
            List<Integer> counts = new ArrayList<>();
            for (String status : severityStatusCountMap.get(severityCategory).keySet()) {
                counts.add(severityStatusCountMap.get(severityCategory).get(status));
            }
            return counts;
        }

        /**
         * Checks if the table is empty.<br>
         * The table is considered empty if all cells have the value "0", except for the "% assessed" column.
         *
         * @return true if the table is empty, false otherwise.
         */
        public boolean isEmpty() {
            for (Map<String, Integer> m : severityStatusCountMap.values()) {
                for (Map.Entry<String, Integer> e : m.entrySet()) {
                    if (!e.getKey().equals("% assessed")) {
                        if (e.getValue() != 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        private String normalize(String s) {
            return s.toLowerCase();
        }

        private String capitalizeWords(String s) {
            if (s == null || s.isEmpty()) {
                return s;
            }
            return Arrays.stream(s.split(" "))
                    .map(word -> Character.toUpperCase(word.charAt(0)) + word.substring(1))
                    .collect(Collectors.joining(" "));
        }

        private static String getSeverityFromVMD(VulnerabilityMetaData vulnerabilityMetaData) {
            final String severity = vulnerabilityMetaData.getComplete("CVSS Unmodified Severity (max)");
            if (severity == null) return "unset";
            return severity;
        }

        private static String getStatusFromVMD(VulnerabilityMetaData vulnerabilityMetaData) {
            final String status = vulnerabilityMetaData.getComplete(VulnerabilityMetaData.Attribute.STATUS);
            if (status == null) return "in review";
            return status;
        }

        public static StatisticsOverviewTable generateFromInventory(Inventory inventory, String filterCert) {
            List<VulnerabilityMetaData> vmds = new ArrayList<>(inventory.getVulnerabilityMetaData());
            if (filterCert != null && !filterCert.isEmpty()) {
                filterVulnerabilityMetaDataForAdvisories(vmds, filterCert);
            }

            StatisticsOverviewTable table = new StatisticsOverviewTable();

            // add the default severity categories in the case there are no vulnerabilities with that category
            for (String severityCategory : new String[]{"critical", "high", "medium", "low"}) {
                table.addSeverityCategory(severityCategory);
            }

            // the columns have to be created first, for them to be added in the correct order below
            for (VulnerabilityMetaData vmd : vmds) {
                table.addStatus(getStatusFromVMD(vmd));
                table.addSeverityCategory(getSeverityFromVMD(vmd));
            }

            // now that the cells exist, count the individual severity and status combinations
            for (VulnerabilityMetaData vmd : vmds) {
                String status = getStatusFromVMD(vmd);
                String severity = getSeverityFromVMD(vmd);
                table.incrementCount(severity, status);
            }

            // add up the total number of vulnerabilities for each severity category
            for (Map.Entry<String, Map<String, Integer>> severityMap : table.severityStatusCountMap.entrySet()) {
                int total = 0;
                for (Map.Entry<String, Integer> statusMap : severityMap.getValue().entrySet()) {
                    total += statusMap.getValue();
                }
                severityMap.getValue().put("total", total);
            }

            // find the % of assessed vulnerabilities for each severity category
            for (Map.Entry<String, Map<String, Integer>> severityMap : table.severityStatusCountMap.entrySet()) {
                int applicable = severityMap.getValue().getOrDefault("applicable", 0);
                int notApplicable = severityMap.getValue().getOrDefault("not applicable", 0);
                int inReview = severityMap.getValue().getOrDefault("in review", 0);
                if (inReview == 0) {
                    severityMap.getValue().put("% assessed", 100);
                } else {
                    // ratio of (applicable + not applicable) to (applicable + not applicable + in review)
                    double ratio = (double) (applicable + notApplicable) / (inReview + applicable + notApplicable);
                    severityMap.getValue().put("% assessed", (int) (ratio * 100));
                }
            }

            return table;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();

            sb.append(String.join(" ", getHeaders())).append("\n");
            for (String severityCategory : getSeverityCategories()) {
                sb.append(String.format("%8s", severityCategory)).append("\t");
                sb.append(getCountsForSeverityCategory(severityCategory).stream().map(String::valueOf).collect(Collectors.joining("\t\t"))).append("\n");
            }
            sb.append("\n");

            return sb.toString();
        }
    }

    public boolean fileExists(String path) {
        if (path == null) return false;
        return new File(path).exists();
    }

    public static class LabelColor {
        private final String background;
        private final String foreground;

        LabelColor(String background, String foreground) {
            this.background = background;
            this.foreground = foreground;
        }

        public String getBackground() {
            return background;
        }

        public String getForeground() {
            return foreground;
        }
    }

    public static String modulateSeverityText(String severity) {
        if (severity == null) {
            return "n.a.";
        }
        return severity;
    }

    /**
     * Converts a HEX color into a label color by evaluating the brightness and setting the foreground to either black
     * or white depending on that.
     *
     * @param color The background color to use.
     * @return A LabelColor containing background and foreground colors.
     */
    public static LabelColor getLabelColor(String color) {
        if (color != null) {
            int rgb = Integer.parseInt(color.substring(1), 16);
            int r = (rgb >> 16) & 0xff;
            int g = (rgb >> 8) & 0xff;
            int b = (rgb) & 0xff;
            double luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            String backgroundColor = luma < 120 ? "white" : "black";
            return new LabelColor(color, backgroundColor);
        }
        return new LabelColor("#cfcfc4", "black");
    }

    public String getStatusText(final VulnerabilityMetaData vulnerabilityMetaData, float threshold) {
        String status = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.STATUS);
        if (status == null) {
            final String maxScoreString = vulnerabilityMetaData.get(VulnerabilityMetaData.Attribute.MAX_SCORE);
            if (maxScoreString != null && Float.valueOf(maxScoreString) < threshold) {
                status = "insignificant";
            } else {
                status = "in review";
            }
        }

        if ("applicable".equalsIgnoreCase(status)) {
            status = "potential vulnerability";
        }

        if ("not applicable".equalsIgnoreCase(status)) {
            status = "not applicable";
        }

        if ("insignificant".equalsIgnoreCase(status)) {
            status = "insignificant";
        }

        return status;
    }

    public LabelColor getStatusLabelColor(String statusText) {
        switch (statusText) {
            case "in review":
                return new LabelColor("#cacecf", "black"); // pastel-gray
            case "not applicable":
                return new LabelColor("#77dd77", "black"); // pastel-green
            case "insignificant":
                return new LabelColor("#84bfff", "#black"); // pastel-blue
            case "potential vulnerability":
                return new LabelColor("#e3b2f2", "black"); // pastel-purple
            case "void":
                return new LabelColor("#636363", "white"); // strong-gray

            default:
                return new LabelColor("#ffcc00", "black"); // strong-yellow
        }
    }

}
