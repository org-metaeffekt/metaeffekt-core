/*
 * Copyright 2009-2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report.chapters;

import org.junit.Before;
import org.junit.Test;
import org.metaeffekt.core.inventory.InventoryUtils;
import org.metaeffekt.core.inventory.processor.report.InventoryReport;
import org.metaeffekt.core.inventory.processor.report.ReportContext;
import org.metaeffekt.core.inventory.processor.report.configuration.ReportConfigurationParameters;
import org.metaeffekt.core.util.FileUtils;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;

import static org.assertj.core.api.Assertions.assertThat;

public class InventoryReportVulnerabilityTest {

    private static InventoryReport report;

    @Before
    public void setUp() throws Exception {

        report = new InventoryReport(ReportConfigurationParameters.builder()
                .inventoryBomReportEnabled(false)
                .inventoryDiffReportEnabled(false)
                .inventoryPomEnabled(false)
                .inventoryVulnerabilityReportEnabled(true)
                .inventoryVulnerabilityReportSummaryEnabled(true)
                .inventoryVulnerabilityStatisticsReportEnabled(true)
                .assetBomReportEnabled(false)
                .assessmentReportEnabled(false)
                .build());

        report.setReportContext(new ReportContext("test", "Test", "Test Context"));
        report.setReferenceLicensePath("licenses");
        report.setReferenceComponentPath("components");
    }

    @Test
    public void testInventoryVulnerabilityDetails() throws IOException, XMLStreamException {
        final File inventoryDir = new File("src/test/resources/inventory-report-vulnerability");
        final File reportDir = new File("target/inventory-report-vulnerability/inventory-vulnerability-details");
        final File targetLicensesDir = new File(reportDir, "licenses");
        final File targetComponentDir = new File(reportDir, "components");

        reportDir.mkdirs();

        report.setInventory(InventoryUtils.readInventory(inventoryDir, "*.xls"));
        report.setTargetReportDir(new File(reportDir, "report"));
        report.setTargetLicenseDir(targetLicensesDir);
        report.setTargetComponentDir(targetComponentDir);
        report.setTargetInventoryDir(reportDir);
        report.setTargetInventoryPath("result.xls");
        report.createReport();

        final File inventoryVulnerabilitiesDetailsFile = new File(reportDir, "report/tpc_inventory-vulnerability-details.dita");
        assertThat(inventoryVulnerabilitiesDetailsFile).exists();
        assertThat(testContainsVulnerabilityStatusDetails(inventoryVulnerabilitiesDetailsFile)).isTrue();
    }

    public boolean testContainsVulnerabilityStatusDetails(File templateFile) throws IOException {
        return Files.lines(templateFile.toPath())
                .anyMatch(l -> l.contains("The vulnerability is applicable."))
                &&
                Files.lines(templateFile.toPath())
                        .anyMatch(l -> l.contains("Application shutdown using remote connection."));
    }
}
