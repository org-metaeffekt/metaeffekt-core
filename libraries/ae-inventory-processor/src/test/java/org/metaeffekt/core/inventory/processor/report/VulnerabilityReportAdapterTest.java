/*
 * Copyright 2009-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.metaeffekt.core.inventory.processor.report;

import org.junit.Assert;
import org.junit.Test;
import org.metaeffekt.core.inventory.processor.model.Inventory;
import org.metaeffekt.core.inventory.processor.model.VulnerabilityMetaData;
import org.metaeffekt.core.inventory.processor.report.adapter.VulnerabilityReportAdapter;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;

import java.util.Arrays;
import java.util.List;

public class VulnerabilityReportAdapterTest {

    @Test
    public void getFurtherAbstractedVulnerabilityCategoryTest() {
        Assert.assertEquals("potentially affected", CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_ABSTRACTED.getMapper().apply(null));
        Assert.assertEquals("potentially affected", CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_ABSTRACTED.getMapper().apply(""));
        Assert.assertEquals("potentially affected", CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_ABSTRACTED.getMapper().apply("in review"));
        Assert.assertEquals("potentially affected", CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_ABSTRACTED.getMapper().apply(VulnerabilityMetaData.STATUS_VALUE_INSIGNIFICANT));

        Assert.assertEquals("affected", CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_ABSTRACTED.getMapper().apply(VulnerabilityMetaData.STATUS_VALUE_APPLICABLE));

        Assert.assertEquals("not affected", CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_ABSTRACTED.getMapper().apply(VulnerabilityMetaData.STATUS_VALUE_NOTAPPLICABLE));
        Assert.assertEquals("not affected", CentralSecurityPolicyConfiguration.VULNERABILITY_STATUS_DISPLAY_MAPPER_ABSTRACTED.getMapper().apply(VulnerabilityMetaData.STATUS_VALUE_VOID));
    }

    @Test
    public void postProcessCvssSourceStringAssessmentTest() {
        final VulnerabilityReportAdapter adapter = new VulnerabilityReportAdapter(new Inventory());
        Assert.assertEquals("NVD-CNA-NVD", adapter.postProcessCvssSource("NVD-CNA-NVD"));
        Assert.assertEquals("NVD-CNA-NVD + Assessment", adapter.postProcessCvssSource("NVD-CNA-NVD + Assessment + Assessment-all"));
        Assert.assertEquals("NVD-CNA-NVD + Assessment", adapter.postProcessCvssSource("NVD-CNA-NVD + Assessment-all + Assessment-lower"));
    }

    private VulnerabilityMetaData createVmdWithScores(double unmodifiedV2, double unmodifiedV3, double unmodifiedMax, double modifiedV2, double modifiedV3, double modifiedMax) {
        final VulnerabilityMetaData vmd = new VulnerabilityMetaData();

        if (unmodifiedV2 != -1) vmd.set("CVSS Unmodified Overall (v2)", String.valueOf(unmodifiedV2));
        if (unmodifiedV3 != -1) vmd.set("CVSS Unmodified Overall (v3)", String.valueOf(unmodifiedV3));
        if (unmodifiedMax != -1) vmd.set("CVSS Unmodified Overall (max)", String.valueOf(unmodifiedMax));

        if (modifiedV2 != -1) vmd.set("CVSS Modified Overall (v2)", String.valueOf(modifiedV2));
        if (modifiedV3 != -1) vmd.set("CVSS Modified Overall (v3)", String.valueOf(modifiedV3));
        if (modifiedMax != -1) vmd.set("CVSS Modified Overall (max)", String.valueOf(modifiedMax));

        return vmd;
    }

    private VulnerabilityMetaData createVmdWithSeverity(String unmodifiedV2, String unmodifiedV3, String unmodifiedMax, String modifiedV2, String modifiedV3, String modifiedMax) {
        final VulnerabilityMetaData vmd = new VulnerabilityMetaData();

        if (unmodifiedV2 != null) vmd.set("CVSS Unmodified Severity (v2)", unmodifiedV2);
        if (unmodifiedV3 != null) vmd.set("CVSS Unmodified Severity (v3)", unmodifiedV3);
        if (unmodifiedMax != null) vmd.set("CVSS Unmodified Severity (max)", unmodifiedMax);

        if (modifiedV2 != null) vmd.set("CVSS Modified Severity (v2)", modifiedV2);
        if (modifiedV3 != null) vmd.set("CVSS Modified Severity (v3)", modifiedV3);
        if (modifiedMax != null) vmd.set("CVSS Modified Severity (max)", modifiedMax);


        return vmd;
    }

    @Test
    public void splitVulnerabilityMatchingSourcesIntoMultipleLines1Test() {
        final List<String> inputLines = Arrays.asList("cpe:/a:apache:log4j:2.14.0", "GHSA [2.13.0.0, 2.15.0.0) org.apache.logging.log4j:log4j-core (Maven)", "NVD cpe:/a:vmware:spring_framework:5.3.14", "this is one long space test1:test2:test3:test4");
        final List<String> expectedLines = Arrays.asList("cpe:/a:apache:log4j:2.14.0", "", "GHSA [2.13.0.0, 2.15.0.0)", "org.apache.logging.log4j:", "log4j-core (Maven)", "", "NVD cpe:/a:vmware:spring_", "framework:5.3.14", "", "this is one long space", "test1:test2:test3:test4");
        final List<String> actualLines = new VulnerabilityReportAdapter(new Inventory(), new CentralSecurityPolicyConfiguration()).splitVulnerabilityMatchingSourcesIntoMultipleLines(inputLines, 20, 28);
        Assert.assertEquals(expectedLines, actualLines);
    }
}