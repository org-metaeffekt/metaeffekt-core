
# Here goes stuff that's portable between (most) distributions.
# Stuff that's specific to a package-manager should probably be sourced separately.

# this function will prepare variables to be used as double-quoted strings in scripts or eval.
# the reason we use a global variable to return is so spaces aren't automagically trimmed by shells.
escapeStringResult=""
escapeString()
{
  printf "string to escape: '%s'\n" "${1}"
  # escape backslash FIRST (since we'll use this to escape)
  escapeStringResult="$(printf %s "${1}" | sed 's/\\/\\\\/g' -)"
  # escape double quote
  escapeStringResult="$(printf %s "${escapeStringResult}" | sed 's/"/\\"/g' -)"
  # escape dollar sign
  escapeStringResult="$(printf %s "${escapeStringResult}" | sed 's/\$/\\\$/g' -)"
  # escape backquote
  escapeStringResult="$(printf %s "${escapeStringResult}" | sed 's/`/\\`/g' -)"
  printf "string escaped: '%s'\n" "${1}"
}

processArguments() {
  # check the input flags
  OPTIND=1
  OPTSPEC="t:e:"

  machineTag=""
  findExcludes=""

  # posix way to disable pathname expansion
  set -f

  while getopts "${OPTSPEC}" fopt ; do
    #echo "DEBUG: $fopt . $OPTARG"
    case "${fopt}" in
      t )
        # set, at runtime, a custom machineTag for identification.
        # should only contain the base64 characters and - and _
        machineTag="${OPTARG}"
        ;;
      e )
        # exclude this directory from find command.
        # each path requires its own option.
        # make sure that relative paths start with "./" .

        escapeString "${OPTARG}"
        printf 'output something pls optarg:%s\n' "a asdf $OPTARG"

        # prepare string that will later be used with eval
        findExcludes="${findExcludes} -path \"${escapeStringResult}\" -o"
        printf "output: %s\n" "${findExcludes}"
        ;;
      ? )
        exit 1
        ;;
    esac
  done

  # reenable pathname expansion while we may need it
  set +f
}

checkFirstArgDefined() {
  # checks that the first argument input to this function is defined (not empty).
  # usually outDir, important to check that it's there so we don't attempt to write into root
  if [ -z "${1}" ] ; then
    printf "%s\n" "outDir (passed to function as \$1) was empty! aborting to not write output to root. This may be a bug."
    exit 1
  fi
}

mkOutputDirs()
{
  checkFirstArgDefined "${1}"
  # create folder structure in analysis folder (assuming sufficient permissions)
  mkdir -p "${1}"/package-meta
  mkdir -p "${1}"/package-files
  mkdir -p "${1}"/filesystem
}

dumpFilepaths()
{
  checkFirstArgDefined "${1}"
  # exclude some paths by default
  # this also acts to finish the last "-o" arg generated by the argument appender.
  local localFindExcludes="${2} -path \"${1}/*\" -o -path \"/container-extractors/*\""
  # generate list of all files (excluding the analysis folders; excluding symlinks)
  # work around shell split / quoting issues by using specially prepared strings and eval.
  eval "find / ! \( \( ${localFindExcludes} \) -prune \) -type f" | sort > "${1}"/filesystem/files.txt
  eval "find / ! \( \( ${localFindExcludes} \) -prune \) -type d" | sort > "${1}"/filesystem/folders.txt
  eval "find / ! \( \( ${localFindExcludes} \) -prune \) -type l" | sort > "${1}"/filesystem/links.txt
  # output data with NUL-delimited paths (instead of unreliable newline) as file paths don't contain NUL
  eval "find / ! \( \( ${localFindExcludes} \) -prune \) -type f -print0" | sort > "${1}"/filesystem/files_z.bin || ( printf "%s\n" "find's -print0 failed on this system. removing files_z.bin" ; rm "${1}"/filesystem/files_z.bin )
  eval "find / ! \( \( ${localFindExcludes} \) -prune \) -type d -print0" | sort > "${1}"/filesystem/folders_z.bin || ( printf "%s\n" "find's -print0 failed on this system. removing folders_z.bin" ; rm "${1}"/filesystem/folders_z.bin )
  eval "find / ! \( \( ${localFindExcludes} \) -prune \) -type l -print0" | sort > "${1}"/filesystem/links_z.bin || ( printf "%s\n" "find's -print0 failed on this system. removing links_z.bin" ; rm "${1}"/filesystem/links_z.bin )
}

analyseSymbolicLinks()
{
  checkFirstArgDefined "${1}"
  # analyse symbolic links
  rm -f "${1}"/filesystem/symlinks.txt
  touch "${1}"/filesystem/symlinks.txt
  while IFS= read -r file
  do
    echo "$file --> `readlink $file`" >> "${1}"/filesystem/symlinks.txt
  done < "${1}"/filesystem/links.txt
  rm -f "${1}"/filesystem/symlinks_z.bin
  touch "${1}"/filesystem/symlinks_z.bin
  while IFS= read -r -d "" file
  do
    printf "%s\x00 --> %s\x00\n" "${file}" "$(readlink "$file")" >> "${1}"/filesystem/symlinks_z.bin
  done < "${1}"/filesystem/links_z.bin
}

dumpDockerIfPresent()
{
  checkFirstArgDefined "${1}"
  # if docker is installed dump the image list
  command -v docker > /dev/null && docker image list > "${1}"/docker-images.txt || true
  command -v docker > /dev/null && docker image list -a > "${1}"/docker-images-all.txt || true
}

dumpPodmanIfPresent()
{
  checkFirstArgDefined "${1}"
  # if podman is installed, dump the image list (might return the same as docker with present docker -> podman symlinks)
  command -v podman > /dev/null && podman image list > "${1}"/podman-images.txt || true
  command -v podman > /dev/null && podman image list -a > "${1}"/podman-images-all.txt || true
}

adaptOutdirOwnership()
{
  checkFirstArgDefined "${1}"
  # adapt ownership of extracted files to match folder creator user and group
  chown `stat -c '%u' "${1}"`:`stat -c '%g' "${1}"` -R "${1}"
}

checkPortableFunctionsPresent()
{
  # dummy function to fail early if functions where not included correctly
  :
}
